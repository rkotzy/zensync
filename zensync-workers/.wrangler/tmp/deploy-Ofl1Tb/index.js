var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b3) => (typeof require !== "undefined" ? require : a2)[b3]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except2)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/zod-is-type.js
var require_zod_is_type = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/zod-is-type.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAnyZodType = exports.isZodType = void 0;
    function isZodType(schema4, typeName) {
      var _a90;
      return ((_a90 = schema4 === null || schema4 === void 0 ? void 0 : schema4._def) === null || _a90 === void 0 ? void 0 : _a90.typeName) === typeName;
    }
    exports.isZodType = isZodType;
    function isAnyZodType(schema4) {
      return "_def" in schema4;
    }
    exports.isAnyZodType = isAnyZodType;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/zod-extensions.js
var require_zod_extensions = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/zod-extensions.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __rest = exports && exports.__rest || function(s2, e3) {
      var t2 = {};
      for (var p4 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p4) && e3.indexOf(p4) < 0)
          t2[p4] = s2[p4];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s2); i2 < p4.length; i2++) {
          if (e3.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p4[i2]))
            t2[p4[i2]] = s2[p4[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendZodWithOpenApi = void 0;
    var zod_is_type_1 = require_zod_is_type();
    function preserveMetadataFromModifier(zod, modifier) {
      const zodModifier = zod.ZodType.prototype[modifier];
      zod.ZodType.prototype[modifier] = function(...args) {
        const result = zodModifier.apply(this, args);
        result._def.openapi = this._def.openapi;
        return result;
      };
    }
    function extendZodWithOpenApi(zod) {
      if (typeof zod.ZodType.prototype.openapi !== "undefined") {
        return;
      }
      zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
        var _a90, _b, _c, _d, _e2, _f;
        const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
        const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
        const _internal = Object.assign(Object.assign({}, (_a90 = this._def.openapi) === null || _a90 === void 0 ? void 0 : _a90._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
        const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
          param: Object.assign(Object.assign({}, (_f = (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
        } : void 0);
        const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
        if ((0, zod_is_type_1.isZodType)(this, "ZodObject")) {
          const originalExtend = this.extend;
          result.extend = function(...args) {
            var _a91, _b2, _c2, _d2, _e3, _f2;
            const extendedResult = originalExtend.apply(this, args);
            extendedResult._def.openapi = {
              _internal: {
                extendedFrom: ((_b2 = (_a91 = this._def.openapi) === null || _a91 === void 0 ? void 0 : _a91._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_e3 = this._def.openapi) === null || _e3 === void 0 ? void 0 : _e3._internal.extendedFrom
              },
              metadata: (_f2 = extendedResult._def.openapi) === null || _f2 === void 0 ? void 0 : _f2.metadata
            };
            return extendedResult;
          };
        }
        return result;
      };
      preserveMetadataFromModifier(zod, "optional");
      preserveMetadataFromModifier(zod, "nullable");
      preserveMetadataFromModifier(zod, "default");
      preserveMetadataFromModifier(zod, "transform");
      preserveMetadataFromModifier(zod, "refine");
      const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
      zod.ZodObject.prototype.deepPartial = function() {
        const initialShape = this._def.shape();
        const result = zodDeepPartial.apply(this);
        const resultShape = result._def.shape();
        Object.entries(resultShape).forEach(([key, value]) => {
          var _a90, _b;
          value._def.openapi = (_b = (_a90 = initialShape[key]) === null || _a90 === void 0 ? void 0 : _a90._def) === null || _b === void 0 ? void 0 : _b.openapi;
        });
        return result;
      };
      const zodPick = zod.ZodObject.prototype.pick;
      zod.ZodObject.prototype.pick = function(...args) {
        const result = zodPick.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
      const zodOmit = zod.ZodObject.prototype.omit;
      zod.ZodObject.prototype.omit = function(...args) {
        const result = zodOmit.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
    }
    exports.extendZodWithOpenApi = extendZodWithOpenApi;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/object-set.js
var require_object_set = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/object-set.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectSet = exports.isEqual = void 0;
    function isEqual(x2, y2) {
      if (x2 === null || x2 === void 0 || y2 === null || y2 === void 0) {
        return x2 === y2;
      }
      if (x2 === y2 || x2.valueOf() === y2.valueOf()) {
        return true;
      }
      if (Array.isArray(x2)) {
        if (!Array.isArray(y2)) {
          return false;
        }
        if (x2.length !== y2.length) {
          return false;
        }
      }
      if (!(x2 instanceof Object) || !(y2 instanceof Object)) {
        return false;
      }
      const keysX = Object.keys(x2);
      return Object.keys(y2).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x2[key], y2[key]));
    }
    exports.isEqual = isEqual;
    var ObjectSet = class {
      constructor() {
        this.buckets = /* @__PURE__ */ new Map();
      }
      put(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          this.buckets.set(hashCode, [value]);
          return;
        }
        const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
        if (!alreadyHasItem) {
          itemsByCode.push(value);
        }
      }
      contains(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          return false;
        }
        return itemsByCode.some((_) => isEqual(_, value));
      }
      values() {
        return [...this.buckets.values()].flat();
      }
      stats() {
        let totalBuckets = 0;
        let totalValues = 0;
        let collisions = 0;
        for (const bucket of this.buckets.values()) {
          totalBuckets += 1;
          totalValues += bucket.length;
          if (bucket.length > 1) {
            collisions += 1;
          }
        }
        const hashEffectiveness = totalBuckets / totalValues;
        return { totalBuckets, collisions, totalValues, hashEffectiveness };
      }
      hashCodeOf(object) {
        let hashCode = 0;
        if (Array.isArray(object)) {
          for (let i2 = 0; i2 < object.length; i2++) {
            hashCode ^= this.hashCodeOf(object[i2]) * i2;
          }
          return hashCode;
        }
        if (typeof object === "string") {
          for (let i2 = 0; i2 < object.length; i2++) {
            hashCode ^= object.charCodeAt(i2) * i2;
          }
          return hashCode;
        }
        if (typeof object === "number") {
          return object;
        }
        if (typeof object === "object") {
          for (const [key, value] of Object.entries(object)) {
            hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
          }
        }
        return hashCode;
      }
    };
    exports.ObjectSet = ObjectSet;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/lodash.js
var require_lodash = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/lodash.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniq = exports.objectEquals = exports.compact = exports.omitBy = exports.omit = exports.mapValues = exports.isNil = exports.isUndefined = void 0;
    var object_set_1 = require_object_set();
    function isUndefined(value) {
      return value === void 0;
    }
    exports.isUndefined = isUndefined;
    function isNil(value) {
      return value === null || value === void 0;
    }
    exports.isNil = isNil;
    function mapValues(object, mapper) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        result[key] = mapper(value);
      });
      return result;
    }
    exports.mapValues = mapValues;
    function omit(object, keys) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!keys.some((keyToOmit) => keyToOmit === key)) {
          result[key] = value;
        }
      });
      return result;
    }
    exports.omit = omit;
    function omitBy(object, predicate) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!predicate(value, key)) {
          result[key] = value;
        }
      });
      return result;
    }
    exports.omitBy = omitBy;
    function compact(arr) {
      return arr.filter((elem) => !isNil(elem));
    }
    exports.compact = compact;
    exports.objectEquals = object_set_1.isEqual;
    function uniq(values) {
      const set2 = new object_set_1.ObjectSet();
      values.forEach((value) => set2.put(value));
      return [...set2.values()];
    }
    exports.uniq = uniq;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-metadata.js
var require_openapi_metadata = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-metadata.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOpenApiMetadata = void 0;
    var lodash_1 = require_lodash();
    function getOpenApiMetadata(zodSchema) {
      var _a90, _b;
      return (0, lodash_1.omitBy)((_b = (_a90 = zodSchema._def.openapi) === null || _a90 === void 0 ? void 0 : _a90.metadata) !== null && _b !== void 0 ? _b : {}, lodash_1.isNil);
    }
    exports.getOpenApiMetadata = getOpenApiMetadata;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-registry.js
var require_openapi_registry = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-registry.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAPIRegistry = void 0;
    var OpenAPIRegistry = class {
      constructor(parents) {
        this.parents = parents;
        this._definitions = [];
      }
      get definitions() {
        var _a90, _b;
        const parentDefinitions = (_b = (_a90 = this.parents) === null || _a90 === void 0 ? void 0 : _a90.flatMap((par) => par.definitions)) !== null && _b !== void 0 ? _b : [];
        return [...parentDefinitions, ...this._definitions];
      }
      /**
       * Registers a new component schema under /components/schemas/${name}
       */
      register(refId, zodSchema) {
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        this._definitions.push({ type: "schema", schema: schemaWithRefId });
        return schemaWithRefId;
      }
      /**
       * Registers a new parameter schema under /components/parameters/${name}
       */
      registerParameter(refId, zodSchema) {
        var _a90, _b, _c;
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        const currentMetadata = (_a90 = schemaWithRefId._def.openapi) === null || _a90 === void 0 ? void 0 : _a90.metadata;
        const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));
        this._definitions.push({
          type: "parameter",
          schema: schemaWithMetadata
        });
        return schemaWithMetadata;
      }
      /**
       * Registers a new path that would be generated under paths:
       */
      registerPath(route) {
        this._definitions.push({
          type: "route",
          route
        });
      }
      /**
       * Registers a new webhook that would be generated under webhooks:
       */
      registerWebhook(webhook) {
        this._definitions.push({
          type: "webhook",
          webhook
        });
      }
      /**
       * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
       *
       * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
       * @param name The name of the object, it is the key under the component
       *             type in the resulting OpenAPI document
       * @param component The actual object to put there
       */
      registerComponent(type, name, component) {
        this._definitions.push({
          type: "component",
          componentType: type,
          name,
          component
        });
        return {
          name,
          ref: { $ref: `#/components/${type}/${name}` }
        };
      }
      schemaWithRefId(refId, zodSchema) {
        return zodSchema.openapi(refId);
      }
    };
    exports.OpenAPIRegistry = OpenAPIRegistry;
  }
});

// node_modules/yaml/browser/dist/nodes/identity.js
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var ALIAS, DOC, MAP, PAIR, SCALAR, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar, isSeq, hasAnchor;
var init_identity = __esm({
  "node_modules/yaml/browser/dist/nodes/identity.js"() {
    init_modules_watch_stub();
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  }
});

// node_modules/yaml/browser/dist/visit.js
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = visit_(i2, node.items[i2], visitor, path);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = await visitAsync_(i2, node.items[i2], visitor, path);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return visitor.Map?.(key, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path);
  if (isPair(node))
    return visitor.Pair?.(key, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var BREAK, SKIP, REMOVE;
var init_visit = __esm({
  "node_modules/yaml/browser/dist/visit.js"() {
    init_modules_watch_stub();
    init_identity();
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove node");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
  }
});

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars, escapeTagName, Directives;
var init_directives = __esm({
  "node_modules/yaml/browser/dist/doc/directives.js"() {
    init_modules_watch_stub();
    init_identity();
    init_visit();
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version3] = parts;
            if (version3 === "1.1" || version3 === "1.2") {
              this.yaml.version = version3;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version3);
              onError(6, `Unsupported YAML version ${version3}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
          const tags = {};
          visit(doc.contents, (_key, node) => {
            if (isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  }
});

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name = `${prefix}${i2}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
var init_anchors = __esm({
  "node_modules/yaml/browser/dist/doc/anchors.js"() {
    init_modules_watch_stub();
    init_identity();
    init_visit();
  }
});

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len = val.length; i2 < len; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var init_applyReviver = __esm({
  "node_modules/yaml/browser/dist/doc/applyReviver.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v3, i2) => toJS(v3, String(i2), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
var init_toJS = __esm({
  "node_modules/yaml/browser/dist/nodes/toJS.js"() {
    init_modules_watch_stub();
    init_identity();
  }
});

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase;
var init_Node = __esm({
  "node_modules/yaml/browser/dist/nodes/Node.js"() {
    init_modules_watch_stub();
    init_applyReviver();
    init_identity();
    init_toJS();
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Alias.js
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c3 = getAliasCount(doc, item, anchors);
      if (c3 > count)
        count = c3;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
var Alias;
var init_Alias = __esm({
  "node_modules/yaml/browser/dist/nodes/Alias.js"() {
    init_modules_watch_stub();
    init_anchors();
    init_visit();
    init_identity();
    init_Node();
    init_toJS();
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue, Scalar;
var init_Scalar = __esm({
  "node_modules/yaml/browser/dist/nodes/Scalar.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Node();
    init_toJS();
    isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    Scalar = class extends NodeBase {
      constructor(value) {
        super(SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  }
});

// node_modules/yaml/browser/dist/doc/createNode.js
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t2) => t2.tag === tagName);
    const tagObj = match.find((t2) => !t2.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t2) => t2.identify?.(value) && !t2.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}
var defaultTagPrefix;
var init_createNode = __esm({
  "node_modules/yaml/browser/dist/doc/createNode.js"() {
    init_modules_watch_stub();
    init_Alias();
    init_identity();
    init_Scalar();
    defaultTagPrefix = "tag:yaml.org,2002:";
  }
});

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v3 = value;
  for (let i2 = path.length - 1; i2 >= 0; --i2) {
    const k2 = path[i2];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a2 = [];
      a2[k2] = v3;
      v3 = a2;
    } else {
      v3 = /* @__PURE__ */ new Map([[k2, v3]]);
    }
  }
  return createNode(v3, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath, Collection;
var init_Collection = __esm({
  "node_modules/yaml/browser/dist/nodes/Collection.js"() {
    init_modules_watch_stub();
    init_createNode();
    init_identity();
    init_Node();
    isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema4) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema4,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema4) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema4)
          copy.schema = schema4;
        copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar(node) ? node.value : node;
        else
          return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!isPair(node))
            return false;
          const n2 = node.value;
          return n2 == null || allowScalar && isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var stringifyComment, lineComment;
var init_stringifyComment = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
    init_modules_watch_stub();
    stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  }
});

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text2, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (let ch; ch = text2[i2 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text2[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text2, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text2[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i2 += 1];
            overflow = true;
          }
          const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text2;
          folds.push(j2);
          escapedFolds[j2] = true;
          end = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold = folds[i3];
    const end2 = folds[i3 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i2) {
  let ch = text2[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text2[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text2[i2 + 1];
  }
  return i2;
}
var FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED;
var init_foldFlowLines = __esm({
  "node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
    init_modules_watch_stub();
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyString.js
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
    if (str[i2] === "\n") {
      if (i2 - start > limit)
        return true;
      start = i2 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i2 = 0, ch = json[i2]; ch; ch = json[++i2]) {
    if (ch === " " && json[i2 + 1] === "\\" && json[i2 + 2] === "n") {
      str += json.slice(start, i2) + "\\ ";
      i2 += 1;
      start = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i2 + 1]) {
        case "u":
          {
            str += json.slice(start, i2);
            const code = json.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i2, 6);
            }
            i2 += 5;
            start = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i2 + 2] === '"' || json.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str += json.slice(start, i2) + "\n\n";
            while (json[i2 + 2] === "\\" && json[i2 + 3] === "n" && json[i2 + 4] !== '"') {
              str += "\n";
              i2 += 2;
            }
            str += indent;
            if (json[i2 + 2] === " ")
              str += "\\";
            i2 += 1;
            start = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs2;
  if (singleQuote === false)
    qs2 = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString;
    else
      qs2 = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs2(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}
var getFoldOptions, containsDocumentMarker, blockEndNewlines;
var init_stringifyString = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_foldFlowLines();
    getFoldOptions = (ctx, isBlock2) => ({
      indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
  }
});

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t2) => t2.tag === item.tag);
    if (match.length > 0)
      return match.find((t2) => t2.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t2) => t2.identify?.(obj));
    tagObj = match.find((t2) => t2.format === item.format) ?? match.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o2) => tagObj = o2 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
var init_stringify = __esm({
  "node_modules/yaml/browser/dist/stringify/stringify.js"() {
    init_modules_watch_stub();
    init_anchors();
    init_identity();
    init_stringifyComment();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws2 = " ";
  if (keyComment || vsb || vcb) {
    ws2 = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws2 += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws2 === "\n")
        ws2 = "\n\n";
    } else {
      ws2 += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws2 = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws2 = "";
  }
  str += ws2 + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
var init_stringifyPair = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var init_log = __esm({
  "node_modules/yaml/browser/dist/log.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx?.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
var MERGE_KEY, isMergeKey;
var init_addPairToJSMap = __esm({
  "node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
    init_modules_watch_stub();
    init_log();
    init_stringify();
    init_identity();
    init_Scalar();
    init_toJS();
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
  }
});

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v3 = createNode(value, void 0, ctx);
  return new Pair(k2, v3);
}
var Pair;
var init_Pair = __esm({
  "node_modules/yaml/browser/dist/nodes/Pair.js"() {
    init_modules_watch_stub();
    init_createNode();
    init_stringifyPair();
    init_addPairToJSMap();
    init_identity();
    Pair = class {
      constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema4) {
        let { key, value } = this;
        if (isNode(key))
          key = key.clone(schema4);
        if (isNode(value))
          value = value.clone(schema4);
        return new Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify5(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line = lines[i2];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i2 < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, indent, commentString(comment));
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
var init_stringifyCollection = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
    init_modules_watch_stub();
    init_Collection();
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k2 = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k2)
        return it;
      if (isScalar(it.key) && it.key.value === k2)
        return it;
    }
  }
  return void 0;
}
var YAMLMap;
var init_YAMLMap = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
    init_modules_watch_stub();
    init_stringifyCollection();
    init_addPairToJSMap();
    init_Collection();
    init_identity();
    init_Pair();
    init_Scalar();
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema4) {
        super(MAP, schema4);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema4, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map2 = new this(schema4);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map2.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema4.sortMapEntries === "function") {
          map2.items.sort(schema4.sortMapEntries);
        }
        return map2;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i2 === -1)
            this.items.push(_pair);
          else
            this.items.splice(i2, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          addPairToJSMap(ctx, map2, item);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/map.js
var map;
var init_map = __esm({
  "node_modules/yaml/browser/dist/schema/common/map.js"() {
    init_modules_watch_stub();
    init_identity();
    init_YAMLMap();
    map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq;
var init_YAMLSeq = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
    init_modules_watch_stub();
    init_createNode();
    init_stringifyCollection();
    init_Collection();
    init_identity();
    init_Scalar();
    init_toJS();
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema4) {
        super(SEQ, schema4);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i2 = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i2++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema4, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema4);
        if (obj && Symbol.iterator in Object(obj)) {
          let i2 = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i2++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq;
var init_seq = __esm({
  "node_modules/yaml/browser/dist/schema/common/seq.js"() {
    init_modules_watch_stub();
    init_identity();
    init_YAMLSeq();
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/string.js
var string;
var init_string = __esm({
  "node_modules/yaml/browser/dist/schema/common/string.js"() {
    init_modules_watch_stub();
    init_stringifyString();
    string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag;
var init_null = __esm({
  "node_modules/yaml/browser/dist/schema/common/null.js"() {
    init_modules_watch_stub();
    init_Scalar();
    nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag;
var init_bool = __esm({
  "node_modules/yaml/browser/dist/schema/core/bool.js"() {
    init_modules_watch_stub();
    init_Scalar();
    boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i2 = n2.indexOf(".");
    if (i2 < 0) {
      i2 = n2.length;
      n2 += ".";
    }
    let d4 = minFractionDigits - (n2.length - i2 - 1);
    while (d4-- > 0)
      n2 += "0";
  }
  return n2;
}
var init_stringifyNumber = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN, floatExp, float;
var init_float = __esm({
  "node_modules/yaml/browser/dist/schema/core/float.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyNumber();
    floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/int.js
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intIdentify, intResolve, intOct, int, intHex;
var init_int = __esm({
  "node_modules/yaml/browser/dist/schema/core/int.js"() {
    init_modules_watch_stub();
    init_stringifyNumber();
    intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema;
var init_schema = __esm({
  "node_modules/yaml/browser/dist/schema/core/schema.js"() {
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    schema = [
      map,
      seq,
      string,
      nullTag,
      boolTag,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float
    ];
  }
});

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON, jsonScalars, jsonError, schema2;
var init_schema2 = __esm({
  "node_modules/yaml/browser/dist/schema/json/schema.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_map();
    init_seq();
    stringifyJSON = ({ value }) => JSON.stringify(value);
    jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify2,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    schema2 = [map, seq].concat(jsonScalars, jsonError);
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary;
var init_binary = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyString();
    binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i2 = 0; i2 < str.length; ++i2)
            buffer[i2] = str.charCodeAt(i2);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s2 = "";
          for (let i2 = 0; i2 < buf.length; ++i2)
            s2 += String.fromCharCode(buf[i2]);
          str = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n2 = Math.ceil(str.length / lineWidth);
          const lines = new Array(n2);
          for (let i2 = 0, o2 = 0; i2 < n2; ++i2, o2 += lineWidth) {
            lines[i2] = str.substr(o2, lineWidth);
          }
          str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i2 = 0; i2 < seq2.items.length; ++i2) {
      let item = seq2.items[i2];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn2 = pair.value ?? pair.key;
          cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i2] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i2++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs;
var init_pairs = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLSeq();
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap, omap;
var init_omap = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
    init_modules_watch_stub();
    init_identity();
    init_toJS();
    init_YAMLMap();
    init_YAMLSeq();
    init_pairs();
    YAMLOMap = class extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map2 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
      static from(schema4, iterable, ctx) {
        const pairs2 = createPairs(schema4, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError) {
        const pairs2 = resolvePairs(seq2, onError);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag, falseTag;
var init_bool2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
    init_modules_watch_stub();
    init_Scalar();
    trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2, floatExp2, float2;
var init_float2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyNumber();
    floatNaN2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f3 = str.substring(dot + 1).replace(/_/g, "");
          if (f3[f3.length - 1] === "0")
            node.minFractionDigits = f3.length;
        }
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intIdentify3, intBin, intOct2, int2, intHex2;
var init_int2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
    init_modules_watch_stub();
    init_stringifyNumber();
    intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
    intBin = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
      stringify: (node) => intStringify2(node, 2, "0b")
    };
    intOct2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
      stringify: (node) => intStringify2(node, 8, "0")
    };
    int2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
      stringify: (node) => intStringify2(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet, set;
var init_set = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_YAMLMap();
    YAMLSet = class extends YAMLMap {
      constructor(schema4) {
        super(schema4);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema4, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema4);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
      resolve(map2, onError) {
        if (isMap(map2)) {
          if (map2.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map2);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p4) => res2 * num(60) + num(p4), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n2) => n2;
  if (typeof value === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n2) => String(n2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime, floatTime, timestamp;
var init_timestamp = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
    init_modules_watch_stub();
    init_stringifyNumber();
    intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d4 = parseSexagesimal(tz, false);
          if (Math.abs(d4) < 30)
            d4 *= 60;
          date -= 6e4 * d4;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3;
var init_schema3 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_binary();
    init_bool2();
    init_float2();
    init_int2();
    init_omap();
    init_pairs();
    init_set();
    init_timestamp();
    schema3 = [
      map,
      seq,
      string,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct2,
      int2,
      intHex2,
      floatNaN2,
      floatExp2,
      float2,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
  }
});

// node_modules/yaml/browser/dist/schema/tags.js
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var schemas, tagsByName, coreKnownTags;
var init_tags = __esm({
  "node_modules/yaml/browser/dist/schema/tags.js"() {
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    init_schema();
    init_schema2();
    init_binary();
    init_omap();
    init_pairs();
    init_schema3();
    init_set();
    init_timestamp();
    schemas = /* @__PURE__ */ new Map([
      ["core", schema],
      ["failsafe", [map, seq, string]],
      ["json", schema2],
      ["yaml11", schema3],
      ["yaml-1.1", schema3]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float,
      floatExp,
      floatNaN,
      floatTime,
      int,
      intHex,
      intOct,
      intTime,
      map,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
  }
});

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey, Schema;
var init_Schema = __esm({
  "node_modules/yaml/browser/dist/schema/Schema.js"() {
    init_modules_watch_stub();
    init_identity();
    init_map();
    init_seq();
    init_string();
    init_tags();
    sortMapEntriesByKey = (a2, b3) => a2.key < b3.key ? -1 : a2.key > b3.key ? 1 : 0;
    Schema = class {
      constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema4 === "string" && schema4 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
var init_stringifyDocument = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
    init_modules_watch_stub();
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/doc/Document.js
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document;
var init_Document = __esm({
  "node_modules/yaml/browser/dist/doc/Document.js"() {
    init_modules_watch_stub();
    init_Alias();
    init_Collection();
    init_identity();
    init_Pair();
    init_toJS();
    init_Schema();
    init_stringifyDocument();
    init_anchors();
    init_applyReviver();
    init_createNode();
    init_directives();
    Document = class {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version3 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version3 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version3 });
        this.setSchema(version3, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
        }
        return new Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v3) => typeof v3 === "number" || v3 instanceof String || v3 instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k2 = this.createNode(key, null, options);
        const v3 = this.createNode(value, null, options);
        return new Pair(k2, v3);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (isEmptyPath(path))
          return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
        return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (isEmptyPath(path))
          return this.contents !== void 0;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version3, options = {}) {
        if (typeof version3 === "number")
          version3 = String(version3);
        let opt;
        switch (version3) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version3;
            else
              this.directives = new Directives({ version: version3 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version3);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s2 = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s2}`);
        }
        return stringifyDocument(this, options);
      }
    };
  }
});

// node_modules/yaml/browser/dist/errors.js
var YAMLError, YAMLParseError, YAMLWarning, prettifyError;
var init_errors = __esm({
  "node_modules/yaml/browser/dist/errors.js"() {
    init_modules_watch_stub();
    YAMLError = class extends Error {
      constructor(name, pos, code, message2) {
        super();
        this.name = name;
        this.code = code;
        this.message = message2;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLParseError", pos, code, message2);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLWarning", pos, code, message2);
      }
    };
    prettifyError = (src, lc2) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc2.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc2.lineStarts[line - 1], lc2.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc2.lineStarts[line - 2], lc2.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
  }
});

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
var init_resolve_props = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-props.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
var init_util_contains_newline = __esm({
  "node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
var init_util_flow_indent_check = __esm({
  "node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
    init_modules_watch_stub();
    init_util_contains_newline();
  }
});

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b3) => a2 === b3 || isScalar(a2) && isScalar(b3) && a2.value === b3.value && !(a2.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var init_util_map_includes = __esm({
  "node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
    init_modules_watch_stub();
    init_identity();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}
var startColMsg;
var init_resolve_block_map = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
    init_modules_watch_stub();
    init_Pair();
    init_YAMLMap();
    init_resolve_props();
    init_util_contains_newline();
    init_util_flow_indent_check();
    init_util_map_includes();
    startColMsg = "All mapping items must start at the same column";
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs2, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs2.offset;
  let commentEnd = null;
  for (const { start, value } of bs2.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs2.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs2.offset, offset, commentEnd ?? offset];
  return seq2;
}
var init_resolve_block_seq = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
    init_modules_watch_stub();
    init_YAMLSeq();
    init_resolve_props();
    init_util_flow_indent_check();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}
var init_resolve_end = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-end.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
var blockMsg, isBlock;
var init_resolve_flow_collection = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_end();
    init_resolve_props();
    init_util_contains_newline();
    init_util_map_includes();
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  }
});

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq" || !expType) {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t2) => t2.tag === tagName && t2.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt?.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag?.format)
    node.format = tag.format;
  return node;
}
var init_compose_collection = __esm({
  "node_modules/yaml/browser/dist/compose/compose-collection.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_block_map();
    init_resolve_block_seq();
    init_resolve_flow_collection();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message2);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i2;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent, content] = lines[i2];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message2 = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value += "\n" + lines[i2][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error === -1)
        error = offset + i2;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token = props[i2];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message2 = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message2);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message2 = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message2);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m3 = first.match(/^( *)/);
  const line0 = m3?.[1] ? [m3[1], first.slice(m3[1].length)] : ["", first];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}
var init_resolve_block_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
    init_modules_watch_stub();
    init_Scalar();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i2);
      res += fold;
      i2 = offset;
    } else if (ch === "\\") {
      let next = source[++i2];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "\r" && source[i2 + 1] === "\n") {
        next = source[++i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next = source[i2 + 1];
      while (next === " " || next === "	")
        next = source[++i2 + 1];
      if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
var escapeCodes;
var init_resolve_flow_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
    init_modules_watch_stub();
    init_Scalar();
    init_resolve_end();
    escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
  }
});

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => tag2.default && tag2.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
var init_compose_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
  }
});

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i2];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset;
}
var init_util_empty_scalar_position = __esm({
  "node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/compose-node.js
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message2 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message2);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
var CN;
var init_compose_node = __esm({
  "node_modules/yaml/browser/dist/compose/compose-node.js"() {
    init_modules_watch_stub();
    init_Alias();
    init_compose_collection();
    init_compose_scalar();
    init_resolve_end();
    init_util_empty_scalar_position();
    CN = { composeNode, composeEmptyNode };
  }
});

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
var init_compose_doc = __esm({
  "node_modules/yaml/browser/dist/compose/compose-doc.js"() {
    init_modules_watch_stub();
    init_Document();
    init_compose_node();
    init_resolve_end();
    init_resolve_props();
  }
});

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i2 + 1]?.[0] !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer;
var init_composer = __esm({
  "node_modules/yaml/browser/dist/compose/composer.js"() {
    init_modules_watch_stub();
    init_directives();
    init_Document();
    init_errors();
    init_identity();
    init_compose_doc();
    init_resolve_end();
    Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message2, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message2));
          else
            this.errors.push(new YAMLParseError(pos, code, message2));
        };
        this.directives = new Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message2, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message2, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message2) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message2);
      else
        throw new YAMLParseError([offset, offset + 1], code, message2);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var init_cst_scalar = __esm({
  "node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
    init_modules_watch_stub();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
    init_errors();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/parse/cst-stringify.js
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
var stringify2;
var init_cst_stringify = __esm({
  "node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
    init_modules_watch_stub();
    stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  }
});

// node_modules/yaml/browser/dist/parse/cst-visit.js
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i2 = 0; i2 < token.items.length; ++i2) {
        const ci = _visit(Object.freeze(path.concat([[field, i2]])), token.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
var BREAK2, SKIP2, REMOVE2;
var init_cst_visit = __esm({
  "node_modules/yaml/browser/dist/parse/cst-visit.js"() {
    init_modules_watch_stub();
    BREAK2 = Symbol("break visit");
    SKIP2 = Symbol("skip children");
    REMOVE2 = Symbol("remove item");
    visit2.BREAK = BREAK2;
    visit2.SKIP = SKIP2;
    visit2.REMOVE = REMOVE2;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index2] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index2];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var BOM, DOCUMENT, FLOW_END, SCALAR2, isCollection2, isScalar2;
var init_cst = __esm({
  "node_modules/yaml/browser/dist/parse/cst.js"() {
    init_modules_watch_stub();
    init_cst_scalar();
    init_cst_stringify();
    init_cst_visit();
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR2 = "";
    isCollection2 = (token) => !!token && "items" in token;
    isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  }
});

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits, tagChars, invalidFlowScalarChars, invalidAnchorChars, isNotAnchorChar, Lexer;
var init_lexer = __esm({
  "node_modules/yaml/browser/dist/parse/lexer.js"() {
    init_modules_watch_stub();
    init_cst();
    hexDigits = "0123456789ABCDEFabcdef".split("");
    tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    invalidFlowScalarChars = ",[]{}".split("");
    invalidAnchorChars = " ,[]{}\n\r	".split("");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i2];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i2 + 1] === "\n";
        return false;
      }
      charAt(n2) {
        return this.buffer[this.pos + n2];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n2) {
        return this.pos + n2 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n2) {
        return this.buffer.substr(this.pos, n2);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n2);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s2 = this.peek(3);
          if (s2 === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s2 === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n2;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n2 = yield* this.pushIndicators();
        switch (line[n2]) {
          case "#":
            yield* this.pushCount(line.length - n2);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n2 += yield* this.parseBlockScalarHeader();
            n2 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n2);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n2 = 0;
        while (line[n2] === ",") {
          n2 += yield* this.pushCount(1);
          n2 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n2 += yield* this.pushIndicators();
        switch (line[n2]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n2);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n2 = 0;
            while (this.buffer[end - 1 - n2] === "\\")
              n2 += 1;
            if (n2 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i2 = this.pos;
        while (true) {
          const ch = this.buffer[++i2];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i2;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i2 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield SCALAR2;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i2 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i2]) {
          if (ch === ":") {
            const next = this.buffer[i2 + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i2;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i2 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i2 += 1;
                ch = "\n";
                next = this.buffer[i2 + 1];
              } else
                end = i2;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i2 + 1);
              if (cs === -1)
                break;
              i2 = Math.max(i2, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i2;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR2;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n2) {
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos += n2;
          return n2;
        }
        return 0;
      }
      *pushToIndex(i2, allowEmpty) {
        const s2 = this.buffer.slice(this.pos, i2);
        if (s2) {
          yield s2;
          this.pos += s2.length;
          return s2.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i2 = this.pos + 2;
          let ch = this.buffer[i2];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i2];
          return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
        } else {
          let i2 = this.pos + 1;
          let ch = this.buffer[i2];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i2];
            else if (ch === "%" && hexDigits.includes(this.buffer[i2 + 1]) && hexDigits.includes(this.buffer[i2 + 2])) {
              ch = this.buffer[i2 += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i2, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i2 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i2];
        } while (ch === " " || allowTabs && ch === "	");
        const n2 = i2 - this.pos;
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos = i2;
        }
        return n2;
      }
      *pushUntil(test) {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (!test(ch))
          ch = this.buffer[++i2];
        return yield* this.pushToIndex(i2, false);
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter;
var init_line_counter = __esm({
  "node_modules/yaml/browser/dist/parse/line-counter.js"() {
    init_modules_watch_stub();
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i2 = 0; i2 < list.length; ++i2)
    if (list[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i2 = 0; i2 < list.length; ++i2) {
    switch (list[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (prev[++i2]?.type === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser;
var init_parser = __esm({
  "node_modules/yaml/browser/dist/parse/parser.js"() {
    init_modules_watch_stub();
    init_cst();
    init_lexer();
    Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message2 = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message2, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n2) {
        return this.stack[this.stack.length - n2];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message2 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message2 };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map2 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map2) {
        const it = map2.items[map2.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map2.indent)) {
                const prev = map2.items[map2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map2.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i2 = 0; i2 < it.sep.length; ++i2) {
              const st = it.sep[i2];
              switch (st.type) {
                case "newline":
                  nl.push(i2);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map2.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map2.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map2.items.push({ start, key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map2);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                  map2.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map2 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map2;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options).toString(options);
}
var init_public_api = __esm({
  "node_modules/yaml/browser/dist/public-api.js"() {
    init_modules_watch_stub();
    init_composer();
    init_Document();
    init_errors();
    init_log();
    init_line_counter();
    init_parser();
  }
});

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var init_dist = __esm({
  "node_modules/yaml/browser/dist/index.js"() {
    init_modules_watch_stub();
    init_composer();
    init_Document();
    init_Schema();
    init_errors();
    init_Alias();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_cst();
    init_lexer();
    init_line_counter();
    init_parser();
    init_public_api();
    init_visit();
  }
});

// node_modules/yaml/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  default: () => browser_default,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var browser_default;
var init_browser = __esm({
  "node_modules/yaml/browser/index.js"() {
    init_modules_watch_stub();
    init_dist();
    init_dist();
    browser_default = dist_exports;
  }
});

// node_modules/openapi3-ts/dist/server-kRKy5879.js
var require_server_kRKy5879 = __commonJS({
  "node_modules/openapi3-ts/dist/server-kRKy5879.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var r2 = class {
      static isValidExtension(i2) {
        return /^x-/.test(i2);
      }
      getExtension(i2) {
        if (!r2.isValidExtension(i2))
          throw new Error(`Invalid specification extension: '${i2}'. Extensions must start with prefix 'x-`);
        return this[i2] ? this[i2] : null;
      }
      addExtension(i2, t2) {
        if (!r2.isValidExtension(i2))
          throw new Error(`Invalid specification extension: '${i2}'. Extensions must start with prefix 'x-`);
        this[i2] = t2;
      }
      listExtensions() {
        const i2 = [];
        for (const t2 in this)
          Object.prototype.hasOwnProperty.call(this, t2) && r2.isValidExtension(t2) && i2.push(t2);
        return i2;
      }
    };
    function e3(s2, i2) {
      if (s2 && r2.isValidExtension(i2))
        return s2[i2];
    }
    function o2(s2, i2, t2) {
      s2 && r2.isValidExtension(i2) && (s2[i2] = t2);
    }
    var a2 = class {
      constructor(i2, t2) {
        this.url = i2, this.description = t2, this.variables = {};
      }
      addVariable(i2, t2) {
        this.variables[i2] = t2;
      }
    };
    var l3 = class {
      constructor(i2, t2, n2) {
        this.default = i2, this.enum = t2, this.description = n2;
      }
    };
    exports.Server = a2;
    exports.ServerVariable = l3;
    exports.SpecificationExtension = r2;
    exports.addExtension = o2;
    exports.getExtension = e3;
  }
});

// node_modules/openapi3-ts/dist/oas30-zGY2VGOJ.js
var require_oas30_zGY2VGOJ = __commonJS({
  "node_modules/openapi3-ts/dist/oas30-zGY2VGOJ.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var h2 = (init_browser(), __toCommonJS(browser_exports));
    var s2 = require_server_kRKy5879();
    function p4(e3) {
      const o2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
      if (e3) {
        for (const t2 in e3)
          if (t2 !== "default") {
            const n2 = Object.getOwnPropertyDescriptor(e3, t2);
            Object.defineProperty(o2, t2, n2.get ? n2 : { enumerable: true, get: () => e3[t2] });
          }
      }
      return o2.default = e3, Object.freeze(o2);
    }
    var m3 = p4(h2);
    var r2 = class {
      static create(o2) {
        return new r2(o2);
      }
      constructor(o2) {
        this.rootDoc = o2 || { openapi: "3.0.0", info: { title: "app", version: "version" }, paths: {}, components: { schemas: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, securitySchemes: {}, links: {}, callbacks: {} }, tags: [], servers: [] };
      }
      getSpec() {
        return this.rootDoc;
      }
      getSpecAsJson(o2, t2) {
        return JSON.stringify(this.rootDoc, o2, t2);
      }
      getSpecAsYaml() {
        return m3.stringify(this.rootDoc);
      }
      static isValidOpenApiVersion(o2) {
        o2 = o2 || "";
        const t2 = /(\d+)\.(\d+).(\d+)/.exec(o2);
        return !!(t2 && parseInt(t2[1], 10) >= 3);
      }
      addOpenApiVersion(o2) {
        if (!r2.isValidOpenApiVersion(o2))
          throw new Error("Invalid OpenApi version: " + o2 + ". Follow convention: 3.x.y");
        return this.rootDoc.openapi = o2, this;
      }
      addInfo(o2) {
        return this.rootDoc.info = o2, this;
      }
      addContact(o2) {
        return this.rootDoc.info.contact = o2, this;
      }
      addLicense(o2) {
        return this.rootDoc.info.license = o2, this;
      }
      addTitle(o2) {
        return this.rootDoc.info.title = o2, this;
      }
      addDescription(o2) {
        return this.rootDoc.info.description = o2, this;
      }
      addTermsOfService(o2) {
        return this.rootDoc.info.termsOfService = o2, this;
      }
      addVersion(o2) {
        return this.rootDoc.info.version = o2, this;
      }
      addPath(o2, t2) {
        return this.rootDoc.paths[o2] = { ...this.rootDoc.paths[o2] || {}, ...t2 }, this;
      }
      addSchema(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.schemas = this.rootDoc.components.schemas || {}, this.rootDoc.components.schemas[o2] = t2, this;
      }
      addResponse(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.responses = this.rootDoc.components.responses || {}, this.rootDoc.components.responses[o2] = t2, this;
      }
      addParameter(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.parameters = this.rootDoc.components.parameters || {}, this.rootDoc.components.parameters[o2] = t2, this;
      }
      addExample(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.examples = this.rootDoc.components.examples || {}, this.rootDoc.components.examples[o2] = t2, this;
      }
      addRequestBody(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.requestBodies = this.rootDoc.components.requestBodies || {}, this.rootDoc.components.requestBodies[o2] = t2, this;
      }
      addHeader(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.headers = this.rootDoc.components.headers || {}, this.rootDoc.components.headers[o2] = t2, this;
      }
      addSecurityScheme(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.securitySchemes = this.rootDoc.components.securitySchemes || {}, this.rootDoc.components.securitySchemes[o2] = t2, this;
      }
      addLink(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.links = this.rootDoc.components.links || {}, this.rootDoc.components.links[o2] = t2, this;
      }
      addCallback(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.callbacks = this.rootDoc.components.callbacks || {}, this.rootDoc.components.callbacks[o2] = t2, this;
      }
      addServer(o2) {
        return this.rootDoc.servers = this.rootDoc.servers || [], this.rootDoc.servers.push(o2), this;
      }
      addTag(o2) {
        return this.rootDoc.tags = this.rootDoc.tags || [], this.rootDoc.tags.push(o2), this;
      }
      addExternalDocs(o2) {
        return this.rootDoc.externalDocs = o2, this;
      }
    };
    function c3(e3, o2) {
      if (!s2.SpecificationExtension.isValidExtension(o2))
        return e3[o2];
    }
    function i2(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    function a2(e3) {
      return !Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    var d4 = Object.freeze(Object.defineProperty({ __proto__: null, OpenApiBuilder: r2, Server: s2.Server, ServerVariable: s2.ServerVariable, addExtension: s2.addExtension, getExtension: s2.getExtension, getPath: c3, isReferenceObject: i2, isSchemaObject: a2 }, Symbol.toStringTag, { value: "Module" }));
    exports.OpenApiBuilder = r2;
    exports.getPath = c3;
    exports.isReferenceObject = i2;
    exports.isSchemaObject = a2;
    exports.oas30 = d4;
  }
});

// node_modules/openapi3-ts/dist/oas30.js
var require_oas30 = __commonJS({
  "node_modules/openapi3-ts/dist/oas30.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var e3 = require_oas30_zGY2VGOJ();
    var r2 = require_server_kRKy5879();
    init_browser();
    exports.OpenApiBuilder = e3.OpenApiBuilder;
    exports.getPath = e3.getPath;
    exports.isReferenceObject = e3.isReferenceObject;
    exports.isSchemaObject = e3.isSchemaObject;
    exports.Server = r2.Server;
    exports.ServerVariable = r2.ServerVariable;
    exports.addExtension = r2.addExtension;
    exports.getExtension = r2.getExtension;
  }
});

// node_modules/openapi3-ts/dist/oas31-2ULMvMLl.js
var require_oas31_2ULMvMLl = __commonJS({
  "node_modules/openapi3-ts/dist/oas31-2ULMvMLl.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var a2 = (init_browser(), __toCommonJS(browser_exports));
    var r2 = require_server_kRKy5879();
    function p4(e3) {
      const o2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
      if (e3) {
        for (const t2 in e3)
          if (t2 !== "default") {
            const s2 = Object.getOwnPropertyDescriptor(e3, t2);
            Object.defineProperty(o2, t2, s2.get ? s2 : { enumerable: true, get: () => e3[t2] });
          }
      }
      return o2.default = e3, Object.freeze(o2);
    }
    var m3 = p4(a2);
    var n2 = class {
      static create(o2) {
        return new n2(o2);
      }
      constructor(o2) {
        this.rootDoc = o2 || { openapi: "3.1.0", info: { title: "app", version: "version" }, paths: {}, components: { schemas: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, securitySchemes: {}, links: {}, callbacks: {} }, tags: [], servers: [] };
      }
      getSpec() {
        return this.rootDoc;
      }
      getSpecAsJson(o2, t2) {
        return JSON.stringify(this.rootDoc, o2, t2);
      }
      getSpecAsYaml() {
        return m3.stringify(this.rootDoc);
      }
      static isValidOpenApiVersion(o2) {
        o2 = o2 || "";
        const t2 = /(\d+)\.(\d+).(\d+)/.exec(o2);
        return !!(t2 && parseInt(t2[1], 10) >= 3);
      }
      addOpenApiVersion(o2) {
        if (!n2.isValidOpenApiVersion(o2))
          throw new Error("Invalid OpenApi version: " + o2 + ". Follow convention: 3.x.y");
        return this.rootDoc.openapi = o2, this;
      }
      addInfo(o2) {
        return this.rootDoc.info = o2, this;
      }
      addContact(o2) {
        return this.rootDoc.info.contact = o2, this;
      }
      addLicense(o2) {
        return this.rootDoc.info.license = o2, this;
      }
      addTitle(o2) {
        return this.rootDoc.info.title = o2, this;
      }
      addDescription(o2) {
        return this.rootDoc.info.description = o2, this;
      }
      addTermsOfService(o2) {
        return this.rootDoc.info.termsOfService = o2, this;
      }
      addVersion(o2) {
        return this.rootDoc.info.version = o2, this;
      }
      addPath(o2, t2) {
        return this.rootDoc.paths = this.rootDoc.paths || {}, this.rootDoc.paths[o2] = { ...this.rootDoc.paths[o2] || {}, ...t2 }, this;
      }
      addSchema(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.schemas = this.rootDoc.components.schemas || {}, this.rootDoc.components.schemas[o2] = t2, this;
      }
      addResponse(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.responses = this.rootDoc.components.responses || {}, this.rootDoc.components.responses[o2] = t2, this;
      }
      addParameter(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.parameters = this.rootDoc.components.parameters || {}, this.rootDoc.components.parameters[o2] = t2, this;
      }
      addExample(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.examples = this.rootDoc.components.examples || {}, this.rootDoc.components.examples[o2] = t2, this;
      }
      addRequestBody(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.requestBodies = this.rootDoc.components.requestBodies || {}, this.rootDoc.components.requestBodies[o2] = t2, this;
      }
      addHeader(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.headers = this.rootDoc.components.headers || {}, this.rootDoc.components.headers[o2] = t2, this;
      }
      addSecurityScheme(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.securitySchemes = this.rootDoc.components.securitySchemes || {}, this.rootDoc.components.securitySchemes[o2] = t2, this;
      }
      addLink(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.links = this.rootDoc.components.links || {}, this.rootDoc.components.links[o2] = t2, this;
      }
      addCallback(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.callbacks = this.rootDoc.components.callbacks || {}, this.rootDoc.components.callbacks[o2] = t2, this;
      }
      addServer(o2) {
        return this.rootDoc.servers = this.rootDoc.servers || [], this.rootDoc.servers.push(o2), this;
      }
      addTag(o2) {
        return this.rootDoc.tags = this.rootDoc.tags || [], this.rootDoc.tags.push(o2), this;
      }
      addExternalDocs(o2) {
        return this.rootDoc.externalDocs = o2, this;
      }
      addWebhook(o2, t2) {
        var s2;
        return (s2 = this.rootDoc).webhooks ?? (s2.webhooks = {}), this.rootDoc.webhooks[o2] = t2, this;
      }
    };
    function c3(e3, o2) {
      if (!r2.SpecificationExtension.isValidExtension(o2))
        return e3 ? e3[o2] : void 0;
    }
    function i2(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    function h2(e3) {
      return !Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    var d4 = Object.freeze(Object.defineProperty({ __proto__: null, OpenApiBuilder: n2, Server: r2.Server, ServerVariable: r2.ServerVariable, addExtension: r2.addExtension, getExtension: r2.getExtension, getPath: c3, isReferenceObject: i2, isSchemaObject: h2 }, Symbol.toStringTag, { value: "Module" }));
    exports.OpenApiBuilder = n2;
    exports.getPath = c3;
    exports.isReferenceObject = i2;
    exports.isSchemaObject = h2;
    exports.oas31 = d4;
  }
});

// node_modules/openapi3-ts/dist/oas31.js
var require_oas31 = __commonJS({
  "node_modules/openapi3-ts/dist/oas31.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var e3 = require_oas31_2ULMvMLl();
    var r2 = require_server_kRKy5879();
    init_browser();
    exports.OpenApiBuilder = e3.OpenApiBuilder;
    exports.getPath = e3.getPath;
    exports.isReferenceObject = e3.isReferenceObject;
    exports.isSchemaObject = e3.isSchemaObject;
    exports.Server = r2.Server;
    exports.ServerVariable = r2.ServerVariable;
    exports.addExtension = r2.addExtension;
    exports.getExtension = r2.getExtension;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/errors.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownZodTypeError = exports.MissingParameterDataError = exports.ConflictError = exports.ZodToOpenAPIError = void 0;
    var ZodToOpenAPIError = class {
      constructor(message2) {
        this.message = message2;
      }
    };
    exports.ZodToOpenAPIError = ZodToOpenAPIError;
    var ConflictError = class extends ZodToOpenAPIError {
      constructor(message2, data) {
        super(message2);
        this.data = data;
      }
    };
    exports.ConflictError = ConflictError;
    var MissingParameterDataError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
        this.data = data;
      }
    };
    exports.MissingParameterDataError = MissingParameterDataError;
    var UnknownZodTypeError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
        this.data = data;
      }
    };
    exports.UnknownZodTypeError = UnknownZodTypeError;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/enum-info.js
var require_enum_info = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/enum-info.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumInfo = void 0;
    function enumInfo(enumObject) {
      const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
      const values = keysExceptReverseMappings.map((key) => enumObject[key]);
      const numericCount = values.filter((_) => typeof _ === "number").length;
      const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
      return { values, type };
    }
    exports.enumInfo = enumInfo;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js
var require_openapi_generator = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __rest = exports && exports.__rest || function(s2, e3) {
      var t2 = {};
      for (var p4 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p4) && e3.indexOf(p4) < 0)
          t2[p4] = s2[p4];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s2); i2 < p4.length; i2++) {
          if (e3.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p4[i2]))
            t2[p4[i2]] = s2[p4[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAPIGenerator = void 0;
    var errors_1 = require_errors();
    var enum_info_1 = require_enum_info();
    var lodash_1 = require_lodash();
    var zod_is_type_1 = require_zod_is_type();
    var OpenAPIGenerator = class {
      constructor(definitions, versionSpecifics) {
        this.definitions = definitions;
        this.versionSpecifics = versionSpecifics;
        this.schemaRefs = {};
        this.paramRefs = {};
        this.pathRefs = {};
        this.rawComponents = [];
        this.sortDefinitions();
      }
      generateDocumentData() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents(),
          paths: this.pathRefs
        };
      }
      generateComponents() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents()
        };
      }
      buildComponents() {
        var _a90, _b;
        const rawComponents = {};
        this.rawComponents.forEach(({ componentType, name, component }) => {
          var _a91;
          (_a91 = rawComponents[componentType]) !== null && _a91 !== void 0 ? _a91 : rawComponents[componentType] = {};
          rawComponents[componentType][name] = component;
        });
        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a90 = rawComponents.schemas) !== null && _a90 !== void 0 ? _a90 : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {}), this.paramRefs) });
      }
      sortDefinitions() {
        const generationOrder = [
          "schema",
          "parameter",
          "component",
          "route"
        ];
        this.definitions.sort((left, right) => {
          if (!("type" in left)) {
            if (!("type" in right)) {
              return 0;
            }
            return -1;
          }
          if (!("type" in right)) {
            return 1;
          }
          const leftIndex = generationOrder.findIndex((type) => type === left.type);
          const rightIndex = generationOrder.findIndex((type) => type === right.type);
          return leftIndex - rightIndex;
        });
      }
      generateSingle(definition) {
        if (!("type" in definition)) {
          this.generateSchema(definition);
          return;
        }
        switch (definition.type) {
          case "parameter":
            this.generateParameterDefinition(definition.schema);
            return;
          case "schema":
            this.generateSchema(definition.schema);
            return;
          case "route":
            this.generateSingleRoute(definition.route);
            return;
          case "component":
            this.rawComponents.push(definition);
            return;
        }
      }
      generateParameterDefinition(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateParameter(zodSchema);
        if (refId) {
          this.paramRefs[refId] = result;
        }
        return result;
      }
      getParameterRef(schemaMetadata, external) {
        var _a90, _b, _c, _d, _e2;
        const parameterMetadata = (_a90 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.param;
        const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId] : void 0;
        if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
          return void 0;
        }
        if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
          throw new errors_1.ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
            key: "in",
            values: (0, lodash_1.compact)([
              existingRef.in,
              external === null || external === void 0 ? void 0 : external.in,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
            ])
          });
        }
        if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
          throw new errors_1.ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: (0, lodash_1.compact)([
              existingRef.name,
              external === null || external === void 0 ? void 0 : external.name,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
            ])
          });
        }
        return {
          $ref: `#/components/parameters/${(_e2 = schemaMetadata._internal) === null || _e2 === void 0 ? void 0 : _e2.refId}`
        };
      }
      generateInlineParameters(zodSchema, location) {
        var _a90;
        const metadata = this.getMetadata(zodSchema);
        const parameterMetadata = (_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.param;
        const referencedSchema = this.getParameterRef(metadata, { in: location });
        if (referencedSchema) {
          return [referencedSchema];
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodObject")) {
          const propTypes = zodSchema._def.shape();
          const parameters = Object.entries(propTypes).map(([key, schema4]) => {
            var _a91, _b;
            const innerMetadata = this.getMetadata(schema4);
            const referencedSchema2 = this.getParameterRef(innerMetadata, {
              in: location,
              name: key
            });
            if (referencedSchema2) {
              return referencedSchema2;
            }
            const innerParameterMetadata = (_a91 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a91 === void 0 ? void 0 : _a91.param;
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
              throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                key: "name",
                values: [key, innerParameterMetadata.name]
              });
            }
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
              throw new errors_1.ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {
                key: "in",
                values: [location, innerParameterMetadata.in]
              });
            }
            return this.generateParameter(schema4.openapi({ param: { name: key, in: location } }));
          });
          return parameters;
        }
        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
          throw new errors_1.ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
            key: "in",
            values: [location, parameterMetadata.in]
          });
        }
        return [
          this.generateParameter(zodSchema.openapi({ param: { in: location } }))
        ];
      }
      generateSimpleParameter(zodSchema) {
        var _a90;
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = (_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.param;
        const required = !this.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
        const schema4 = this.generateSchemaWithRef(zodSchema);
        return Object.assign({
          schema: schema4,
          required
        }, paramMetadata ? this.buildParameterMetadata(paramMetadata) : {});
      }
      generateParameter(zodSchema) {
        var _a90;
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = (_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.param;
        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
        if (!paramName) {
          throw new errors_1.MissingParameterDataError({ missingField: "name" });
        }
        if (!paramLocation) {
          throw new errors_1.MissingParameterDataError({
            missingField: "in",
            paramName
          });
        }
        const baseParameter = this.generateSimpleParameter(zodSchema);
        return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
      }
      generateSchemaWithMetadata(zodSchema) {
        var _a90;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = this.getMetadata(zodSchema);
        const defaultValue = this.getDefaultValue(zodSchema);
        const result = ((_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.type) ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata) ? this.applySchemaMetadata(result, metadata.metadata) : (0, lodash_1.omitBy)(result, lodash_1.isNil);
      }
      /**
       * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
       */
      generateSimpleSchema(zodSchema) {
        var _a90;
        const metadata = this.getMetadata(zodSchema);
        const refId = this.getRefId(zodSchema);
        if (!refId || !this.schemaRefs[refId]) {
          return this.generateSchemaWithMetadata(zodSchema);
        }
        const schemaRef = this.schemaRefs[refId];
        const referenceObject = {
          $ref: this.generateSchemaRef(refId)
        };
        const newMetadata = (0, lodash_1.omitBy)(this.buildSchemaMetadata((_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a90 !== void 0 ? _a90 : {}), (value, key) => value === void 0 || (0, lodash_1.objectEquals)(value, schemaRef[key]));
        if (newMetadata.type) {
          return {
            allOf: [referenceObject, newMetadata]
          };
        }
        const newSchemaMetadata = (0, lodash_1.omitBy)(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === void 0 || (0, lodash_1.objectEquals)(value, schemaRef[key]));
        const appliedMetadata = this.applySchemaMetadata(newSchemaMetadata, newMetadata);
        if (Object.keys(appliedMetadata).length > 0) {
          return {
            allOf: [referenceObject, appliedMetadata]
          };
        }
        return referenceObject;
      }
      /**
       * Generates a whole OpenApi schema and saves it into
       * schemaRefs if a `refId` is provided.
       */
      generateSchema(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateSimpleSchema(zodSchema);
        if (refId && this.schemaRefs[refId] === void 0) {
          this.schemaRefs[refId] = result;
        }
        return result;
      }
      /**
       * Same as `generateSchema` but if the new schema is added into the
       * referenced schemas, it would return a ReferenceObject and not the
       * whole result.
       *
       * Should be used for nested objects, arrays, etc.
       */
      generateSchemaWithRef(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateSimpleSchema(zodSchema);
        if (refId && this.schemaRefs[refId] === void 0) {
          this.schemaRefs[refId] = result;
          return { $ref: this.generateSchemaRef(refId) };
        }
        return result;
      }
      generateSchemaRef(refId) {
        return `#/components/schemas/${refId}`;
      }
      getRequestBody(requestBody) {
        if (!requestBody) {
          return;
        }
        const { content } = requestBody, rest = __rest(requestBody, ["content"]);
        const requestBodyContent = this.getBodyContent(content);
        return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
      }
      getParameters(request) {
        if (!request) {
          return [];
        }
        const { query, params, headers, cookies } = request;
        const queryParameters = this.enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
        const pathParameters = this.enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
        const cookieParameters = this.enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
        const headerParameters = this.enhanceMissingParametersError(() => headers ? (0, zod_is_type_1.isZodType)(headers, "ZodObject") ? this.generateInlineParameters(headers, "header") : headers.flatMap((header) => this.generateInlineParameters(header, "header")) : [], { location: "header" });
        return [
          ...pathParameters,
          ...queryParameters,
          ...headerParameters,
          ...cookieParameters
        ];
      }
      generatePath(route) {
        const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
        const generatedResponses = (0, lodash_1.mapValues)(responses, (response) => {
          return this.getResponse(response);
        });
        const parameters = this.enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
        const routeDoc = {
          [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
            parameters: [...pathItemConfig.parameters || [], ...parameters]
          } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
        };
        return routeDoc;
      }
      generateSingleRoute(route) {
        const routeDoc = this.generatePath(route);
        this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
        return routeDoc;
      }
      getResponse(_a90) {
        var { content, headers } = _a90, rest = __rest(_a90, ["content", "headers"]);
        const responseContent = content ? { content: this.getBodyContent(content) } : {};
        if (!headers) {
          return Object.assign(Object.assign({}, rest), responseContent);
        }
        const responseHeaders = (0, zod_is_type_1.isZodType)(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
          // This is input data so it is okay to cast in the common generator
          // since this is the user's responsibility to keep it correct
          headers
        );
        return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
      }
      getResponseHeaders(headers) {
        const schemaShape = headers._def.shape();
        const responseHeaders = (0, lodash_1.mapValues)(schemaShape, (_) => this.generateSimpleParameter(_));
        return responseHeaders;
      }
      getBodyContent(content) {
        return (0, lodash_1.mapValues)(content, (config) => {
          if (!(0, zod_is_type_1.isAnyZodType)(config.schema)) {
            return config;
          }
          const { schema: configSchema } = config, rest = __rest(config, ["schema"]);
          const schema4 = this.generateSchemaWithRef(configSchema);
          return Object.assign({ schema: schema4 }, rest);
        });
      }
      getZodStringCheck(zodString, kind) {
        return zodString._def.checks.find((check) => {
          return check.kind === kind;
        });
      }
      /**
       * Attempts to map Zod strings to known formats
       * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
       */
      mapStringFormat(zodString) {
        if (zodString.isUUID) {
          return "uuid";
        }
        if (zodString.isEmail) {
          return "email";
        }
        if (zodString.isURL) {
          return "uri";
        }
        if (zodString.isDatetime) {
          return "date-time";
        }
        return void 0;
      }
      mapDiscriminator(zodObjects, discriminator) {
        if (zodObjects.some((obj) => this.getRefId(obj) === void 0)) {
          return void 0;
        }
        const mapping = {};
        zodObjects.forEach((obj) => {
          var _a90;
          const refId = this.getRefId(obj);
          const value = (_a90 = obj.shape) === null || _a90 === void 0 ? void 0 : _a90[discriminator];
          if ((0, zod_is_type_1.isZodType)(value, "ZodEnum")) {
            value._def.values.forEach((enumValue) => {
              mapping[enumValue] = this.generateSchemaRef(refId);
            });
            return;
          }
          const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
          if (typeof literalValue !== "string") {
            throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
          }
          mapping[literalValue] = this.generateSchemaRef(refId);
        });
        return {
          propertyName: discriminator,
          mapping
        };
      }
      mapNullableOfArray(objects, isNullable) {
        return this.versionSpecifics.mapNullableOfArray(objects, isNullable);
      }
      mapNullableType(type, isNullable) {
        return this.versionSpecifics.mapNullableType(type, isNullable);
      }
      getNumberChecks(checks) {
        return this.versionSpecifics.getNumberChecks(checks);
      }
      constructReferencedOpenAPISchema(zodSchema) {
        var _a90;
        const metadata = this.getMetadata(zodSchema);
        const innerSchema = this.unwrapChained(zodSchema);
        const defaultValue = this.getDefaultValue(zodSchema);
        const isNullableSchema = zodSchema.isNullable();
        if ((_a90 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.type) {
          return this.mapNullableType(metadata.metadata.type, isNullableSchema);
        }
        return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
      }
      toOpenAPISchema(zodSchema, isNullable, defaultValue) {
        var _a90, _b, _c, _d, _e2;
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNull")) {
          return this.versionSpecifics.nullType;
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodString")) {
          const regexCheck = this.getZodStringCheck(zodSchema, "regex");
          const length = (_a90 = this.getZodStringCheck(zodSchema, "length")) === null || _a90 === void 0 ? void 0 : _a90.value;
          const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : void 0 : void 0;
          const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : void 0 : void 0;
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), {
            // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
            minLength: length !== null && length !== void 0 ? length : maxLength,
            maxLength: length !== null && length !== void 0 ? length : minLength,
            format: this.mapStringFormat(zodSchema),
            pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source,
            default: defaultValue
          });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNumber")) {
          return Object.assign(Object.assign(Object.assign({}, this.mapNullableType(zodSchema.isInt ? "integer" : "number", isNullable)), this.getNumberChecks(zodSchema._def.checks)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodBoolean")) {
          return Object.assign(Object.assign({}, this.mapNullableType("boolean", isNullable)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          const innerSchema = zodSchema._def.schema;
          return this.generateSchema(innerSchema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodLiteral")) {
          return Object.assign(Object.assign({}, this.mapNullableType(typeof zodSchema._def.value, isNullable)), { enum: [zodSchema._def.value], default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEnum")) {
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), { enum: zodSchema._def.values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNativeEnum")) {
          const { type, values } = (0, enum_info_1.enumInfo)(zodSchema._def.values);
          if (type === "mixed") {
            throw new errors_1.ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
          }
          return Object.assign(Object.assign({}, this.mapNullableType(type === "numeric" ? "integer" : "string", isNullable)), { enum: values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodObject")) {
          return this.toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodArray")) {
          const itemType = zodSchema._def.type;
          return Object.assign(Object.assign({}, this.mapNullableType("array", isNullable)), { items: this.generateSchemaWithRef(itemType), minItems: (_d = zodSchema._def.minLength) === null || _d === void 0 ? void 0 : _d.value, maxItems: (_e2 = zodSchema._def.maxLength) === null || _e2 === void 0 ? void 0 : _e2.value, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodTuple")) {
          const { items } = zodSchema._def;
          const tupleLength = items.length;
          const schemas2 = items.map((schema4) => this.generateSchemaWithRef(schema4));
          const uniqueSchemas = (0, lodash_1.uniq)(schemas2);
          if (uniqueSchemas.length === 1) {
            return {
              type: "array",
              items: uniqueSchemas[0],
              minItems: tupleLength,
              maxItems: tupleLength
            };
          }
          return Object.assign(Object.assign({}, this.mapNullableType("array", isNullable)), { items: {
            anyOf: uniqueSchemas
          }, minItems: tupleLength, maxItems: tupleLength });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodUnion")) {
          const options = this.flattenUnionTypes(zodSchema);
          const schemas2 = options.map((schema4) => {
            const optionToGenerate = this.unwrapNullable(schema4);
            return this.generateSchemaWithRef(optionToGenerate);
          });
          return {
            anyOf: this.mapNullableOfArray(schemas2, isNullable),
            default: defaultValue
          };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDiscriminatedUnion")) {
          const options = [...zodSchema.options.values()];
          const optionSchema = options.map((schema4) => this.generateSchemaWithRef(schema4));
          if (isNullable) {
            return {
              oneOf: this.mapNullableOfArray(optionSchema, isNullable),
              default: defaultValue
            };
          }
          return {
            oneOf: optionSchema,
            discriminator: this.mapDiscriminator(options, zodSchema.discriminator),
            default: defaultValue
          };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodIntersection")) {
          const subtypes = this.flattenIntersectionTypes(zodSchema);
          const allOfSchema = {
            allOf: subtypes.map((schema4) => this.generateSchemaWithRef(schema4))
          };
          if (isNullable) {
            return {
              anyOf: this.mapNullableOfArray([allOfSchema], isNullable),
              default: defaultValue
            };
          }
          return Object.assign(Object.assign({}, allOfSchema), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodRecord")) {
          const propertiesType = zodSchema._def.valueType;
          return Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { additionalProperties: this.generateSchemaWithRef(propertiesType), default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodUnknown") || (0, zod_is_type_1.isZodType)(zodSchema, "ZodAny")) {
          return this.mapNullableType(void 0, isNullable);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDate")) {
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodPipeline")) {
          return this.toOpenAPISchema(zodSchema._def.in, isNullable, defaultValue);
        }
        const refId = this.getRefId(zodSchema);
        throw new errors_1.UnknownZodTypeError({
          currentSchema: zodSchema._def,
          schemaName: refId
        });
      }
      isOptionalSchema(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          return this.isOptionalSchema(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDefault")) {
          return this.isOptionalSchema(zodSchema._def.innerType);
        }
        return zodSchema.isOptional();
      }
      getDefaultValue(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodOptional") || (0, zod_is_type_1.isZodType)(zodSchema, "ZodNullable")) {
          return this.getDefaultValue(zodSchema.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          return this.getDefaultValue(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDefault")) {
          return zodSchema._def.defaultValue();
        }
        return void 0;
      }
      requiredKeysOf(objectSchema) {
        return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !this.isOptionalSchema(type)).map(([key, _type]) => key);
      }
      toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue) {
        var _a90;
        const extendedFrom = (_a90 = this.getInternalMetadata(zodSchema)) === null || _a90 === void 0 ? void 0 : _a90.extendedFrom;
        const required = this.requiredKeysOf(zodSchema);
        const properties = (0, lodash_1.mapValues)(zodSchema._def.shape(), (_) => this.generateSchemaWithRef(_));
        if (!extendedFrom) {
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { default: defaultValue, properties }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema));
        }
        const parent = extendedFrom.schema;
        this.generateSchema(parent);
        const keysRequiredByParent = this.requiredKeysOf(parent);
        const propsOfParent = (0, lodash_1.mapValues)(parent === null || parent === void 0 ? void 0 : parent._def.shape(), (_) => this.generateSchemaWithRef(_));
        const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
          return !(0, lodash_1.objectEquals)(propsOfParent[key], type);
        }));
        const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
        const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema));
        return {
          allOf: [
            { $ref: `#/components/schemas/${extendedFrom.refId}` },
            objectData
          ]
        };
      }
      generateAdditionalProperties(zodSchema) {
        const unknownKeysOption = zodSchema._def.unknownKeys;
        const catchallSchema = zodSchema._def.catchall;
        if ((0, zod_is_type_1.isZodType)(catchallSchema, "ZodNever")) {
          if (unknownKeysOption === "strict") {
            return { additionalProperties: false };
          }
          return {};
        }
        return { additionalProperties: this.generateSchemaWithRef(catchallSchema) };
      }
      flattenUnionTypes(schema4) {
        if (!(0, zod_is_type_1.isZodType)(schema4, "ZodUnion")) {
          return [schema4];
        }
        const options = schema4._def.options;
        return options.flatMap((option) => this.flattenUnionTypes(option));
      }
      flattenIntersectionTypes(schema4) {
        if (!(0, zod_is_type_1.isZodType)(schema4, "ZodIntersection")) {
          return [schema4];
        }
        const leftSubTypes = this.flattenIntersectionTypes(schema4._def.left);
        const rightSubTypes = this.flattenIntersectionTypes(schema4._def.right);
        return [...leftSubTypes, ...rightSubTypes];
      }
      unwrapNullable(schema4) {
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodNullable")) {
          return this.unwrapNullable(schema4.unwrap());
        }
        return schema4;
      }
      unwrapChained(schema4) {
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodOptional") || (0, zod_is_type_1.isZodType)(schema4, "ZodNullable") || (0, zod_is_type_1.isZodType)(schema4, "ZodBranded")) {
          return this.unwrapChained(schema4.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodDefault")) {
          return this.unwrapChained(schema4._def.innerType);
        }
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodEffects")) {
          return this.unwrapChained(schema4._def.schema);
        }
        return schema4;
      }
      /**
       * A method that omits all custom keys added to the regular OpenAPI
       * metadata properties
       */
      buildSchemaMetadata(metadata) {
        return (0, lodash_1.omitBy)((0, lodash_1.omit)(metadata, ["param"]), lodash_1.isNil);
      }
      buildParameterMetadata(metadata) {
        return (0, lodash_1.omitBy)(metadata, lodash_1.isNil);
      }
      getMetadata(zodSchema) {
        var _a90;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        const zodDescription = (_a90 = zodSchema.description) !== null && _a90 !== void 0 ? _a90 : innerSchema.description;
        return {
          _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
          metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
        };
      }
      getInternalMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
      }
      getRefId(zodSchema) {
        var _a90;
        return (_a90 = this.getInternalMetadata(zodSchema)) === null || _a90 === void 0 ? void 0 : _a90.refId;
      }
      applySchemaMetadata(initialData, metadata) {
        return (0, lodash_1.omitBy)(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), lodash_1.isNil);
      }
      enhanceMissingParametersError(action, paramsToAdd) {
        try {
          return action();
        } catch (error) {
          if (error instanceof errors_1.MissingParameterDataError) {
            throw new errors_1.MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
          }
          throw error;
        }
      }
    };
    exports.OpenAPIGenerator = OpenAPIGenerator;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/specifics.js
var require_specifics = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/specifics.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV30Specifics = void 0;
    var OpenApiGeneratorV30Specifics = class {
      get nullType() {
        return { nullable: true };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check) => {
          switch (check.kind) {
            case "min":
              return check.inclusive ? { minimum: check.value } : { minimum: check.value, exclusiveMinimum: true };
            case "max":
              return check.inclusive ? { maximum: check.value } : { maximum: check.value, exclusiveMaximum: true };
            default:
              return {};
          }
        }));
      }
    };
    exports.OpenApiGeneratorV30Specifics = OpenApiGeneratorV30Specifics;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/openapi-generator.js
var require_openapi_generator2 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/openapi-generator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV3 = void 0;
    var openapi_generator_1 = require_openapi_generator();
    var specifics_1 = require_specifics();
    var OpenApiGeneratorV3 = class {
      constructor(definitions) {
        const specifics = new specifics_1.OpenApiGeneratorV30Specifics();
        this.generator = new openapi_generator_1.OpenAPIGenerator(definitions, specifics);
      }
      generateDocument(config) {
        const baseData = this.generator.generateDocumentData();
        return Object.assign(Object.assign({}, config), baseData);
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
    };
    exports.OpenApiGeneratorV3 = OpenApiGeneratorV3;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/specifics.js
var require_specifics2 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/specifics.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31Specifics = void 0;
    var OpenApiGeneratorV31Specifics = class {
      get nullType() {
        return { type: "null" };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        if (!type) {
          return {};
        }
        if (isNullable) {
          return {
            type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
          };
        }
        return {
          type
        };
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check) => {
          switch (check.kind) {
            case "min":
              return check.inclusive ? { minimum: check.value } : { exclusiveMinimum: check.value };
            case "max":
              return check.inclusive ? { maximum: check.value } : { exclusiveMaximum: check.value };
            default:
              return {};
          }
        }));
      }
    };
    exports.OpenApiGeneratorV31Specifics = OpenApiGeneratorV31Specifics;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/openapi-generator.js
var require_openapi_generator3 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/openapi-generator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31 = void 0;
    var openapi_generator_1 = require_openapi_generator();
    var specifics_1 = require_specifics2();
    function isWebhookDefinition(definition) {
      return "type" in definition && definition.type === "webhook";
    }
    var OpenApiGeneratorV31 = class {
      constructor(definitions) {
        this.definitions = definitions;
        this.webhookRefs = {};
        const specifics = new specifics_1.OpenApiGeneratorV31Specifics();
        this.generator = new openapi_generator_1.OpenAPIGenerator(this.definitions, specifics);
      }
      generateDocument(config) {
        const baseDocument = this.generator.generateDocumentData();
        this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
        return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
      generateSingleWebhook(route) {
        const routeDoc = this.generator.generatePath(route);
        this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
        return routeDoc;
      }
    };
    exports.OpenApiGeneratorV31 = OpenApiGeneratorV31;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/index.js
var require_dist = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc2 || ("get" in desc2 ? !m3.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31 = exports.OpenApiGeneratorV3 = exports.OpenAPIV31 = exports.OpenAPIV3 = exports.OpenAPIRegistry = exports.extendZodWithOpenApi = void 0;
    var zod_extensions_1 = require_zod_extensions();
    Object.defineProperty(exports, "extendZodWithOpenApi", { enumerable: true, get: function() {
      return zod_extensions_1.extendZodWithOpenApi;
    } });
    __exportStar(require_openapi_metadata(), exports);
    var openapi_registry_1 = require_openapi_registry();
    Object.defineProperty(exports, "OpenAPIRegistry", { enumerable: true, get: function() {
      return openapi_registry_1.OpenAPIRegistry;
    } });
    exports.OpenAPIV3 = __importStar(require_oas30());
    exports.OpenAPIV31 = __importStar(require_oas31());
    var openapi_generator_1 = require_openapi_generator2();
    Object.defineProperty(exports, "OpenApiGeneratorV3", { enumerable: true, get: function() {
      return openapi_generator_1.OpenApiGeneratorV3;
    } });
    var openapi_generator_2 = require_openapi_generator3();
    Object.defineProperty(exports, "OpenApiGeneratorV31", { enumerable: true, get: function() {
      return openapi_generator_2.OpenApiGeneratorV31;
    } });
  }
});

// node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index2, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key = sourceKeys[index2];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string2, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string2;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject2;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    function formatError(exception, compact) {
      var where = "", message2 = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message2;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message2 + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var common = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string2, max) {
      return common.repeat(" ", max - string2.length) + string2;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i2, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i2 = 1; i2 <= options.linesBefore; i2++) {
        if (foundLineNo - i2 < 0)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i2],
          lineEnds[foundLineNo - i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i2 = 1; i2 <= options.linesAfter; i2++) {
        if (foundLineNo + i2 >= lineEnds.length)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i2],
          lineEnds[foundLineNo + i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map2) {
      var result = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema4, name) {
      var result = [];
      schema4[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index2, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema3(definition) {
      return this.extend(definition);
    }
    Schema3.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema3.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module.exports = Schema3;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Schema3 = require_schema();
    module.exports = new Schema3({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull2(object) {
      return object === null;
    }
    module.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var common = require_common();
    var Type = require_type();
    function isHexCode(c3) {
      return 48 <= c3 && c3 <= 57 || 65 <= c3 && c3 <= 70 || 97 <= c3 && c3 <= 102;
    }
    function isOctCode(c3) {
      return 48 <= c3 && c3 <= 55;
    }
    function isDecCode(c3) {
      return 48 <= c3 && c3 <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index2 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index2];
      if (ch === "-" || ch === "+") {
        ch = data[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max)
          return true;
        ch = data[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map2.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map2[bits >> 18 & 63];
          result += map2[bits >> 12 & 63];
          result += map2[bits >> 6 & 63];
          result += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      } else if (tail === 2) {
        result += map2[bits >> 10 & 63];
        result += map2[bits >> 4 & 63];
        result += map2[bits << 2 & 63];
        result += map2[64];
      } else if (tail === 1) {
        result += map2[bits >> 2 & 63];
        result += map2[bits << 4 & 63];
        result += map2[64];
        result += map2[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        keys = Object.keys(pair);
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c3) {
      return c3 === 10 || c3 === 13;
    }
    function is_WHITE_SPACE(c3) {
      return c3 === 9 || c3 === 32;
    }
    function is_WS_OR_EOL(c3) {
      return c3 === 9 || c3 === 32 || c3 === 10 || c3 === 13;
    }
    function is_FLOW_INDICATOR(c3) {
      return c3 === 44 || c3 === 91 || c3 === 93 || c3 === 123 || c3 === 125;
    }
    function fromHexCode(c3) {
      var lc2;
      if (48 <= c3 && c3 <= 57) {
        return c3 - 48;
      }
      lc2 = c3 | 32;
      if (97 <= lc2 && lc2 <= 102) {
        return lc2 - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c3) {
      if (c3 === 120) {
        return 2;
      }
      if (c3 === 117) {
        return 4;
      }
      if (c3 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c3) {
      if (48 <= c3 && c3 <= 57) {
        return c3 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c3) {
      return c3 === 48 ? "\0" : c3 === 97 ? "\x07" : c3 === 98 ? "\b" : c3 === 116 ? "	" : c3 === 9 ? "	" : c3 === 110 ? "\n" : c3 === 118 ? "\v" : c3 === 102 ? "\f" : c3 === 114 ? "\r" : c3 === 101 ? "\x1B" : c3 === 32 ? " " : c3 === 34 ? '"' : c3 === 47 ? "/" : c3 === 92 ? "\\" : c3 === 78 ? "\x85" : c3 === 95 ? "\xA0" : c3 === 76 ? "\u2028" : c3 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c3) {
      if (c3 <= 65535) {
        return String.fromCharCode(c3);
      }
      return String.fromCharCode(
        (c3 - 65536 >> 10) + 55296,
        (c3 - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
      simpleEscapeMap[i2] = simpleEscapeSequence(i2);
    }
    var i2;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message2) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message2, mark);
    }
    function throwError(state, message2) {
      throw generateError(state, message2);
    }
    function throwWarning(state, message2) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message2));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index2, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair2, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair2 = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair2 = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode2(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair2 = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode2(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair2) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode2(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode2(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode2(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode2(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode2(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema4, map2) {
      var result, keys, index2, length, tag, style, type;
      if (map2 === null)
        return {};
      result = {};
      keys = Object.keys(map2);
      for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
        tag = keys[index2];
        style = String(map2[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema4.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string2, handle, length;
      string2 = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string2.length) + string2;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string2, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
      while (position < length) {
        next = string2.indexOf("\n", position);
        if (next === -1) {
          line = string2.slice(position);
          position = length;
        } else {
          line = string2.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c3) {
      return c3 === CHAR_SPACE || c3 === CHAR_TAB;
    }
    function isPrintable(c3) {
      return 32 <= c3 && c3 <= 126 || 161 <= c3 && c3 <= 55295 && c3 !== 8232 && c3 !== 8233 || 57344 <= c3 && c3 <= 65533 && c3 !== CHAR_BOM || 65536 <= c3 && c3 <= 1114111;
    }
    function isNsCharOrWhitespace(c3) {
      return isPrintable(c3) && c3 !== CHAR_BOM && c3 !== CHAR_CARRIAGE_RETURN && c3 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c3, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c3);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c3);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET) && c3 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c3 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c3) {
      return isPrintable(c3) && c3 !== CHAR_BOM && !isWhitespace(c3) && c3 !== CHAR_MINUS && c3 !== CHAR_QUESTION && c3 !== CHAR_COLON && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET && c3 !== CHAR_SHARP && c3 !== CHAR_AMPERSAND && c3 !== CHAR_ASTERISK && c3 !== CHAR_EXCLAMATION && c3 !== CHAR_VERTICAL_LINE && c3 !== CHAR_EQUALS && c3 !== CHAR_GREATER_THAN && c3 !== CHAR_SINGLE_QUOTE && c3 !== CHAR_DOUBLE_QUOTE && c3 !== CHAR_PERCENT && c3 !== CHAR_COMMERCIAL_AT && c3 !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c3) {
      return !isWhitespace(c3) && c3 !== CHAR_COLON;
    }
    function codePointAt(string2, pos) {
      var first = string2.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
        second = string2.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string2) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string2);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i2;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string2, i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string2, i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string2)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string2)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string2, level, iskey, inblock) {
      state.dump = function() {
        if (string2.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string3) {
          return testImplicitResolving(state, string3);
        }
        switch (chooseScalarStyle(
          string2,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string2;
          case STYLE_SINGLE:
            return "'" + string2.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string2, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string2, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
      var clip = string2[string2.length - 1] === "\n";
      var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string2) {
      return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
    }
    function foldString(string2, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string2.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string2.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string2.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string2)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string2) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string2, i2);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string2[i2];
          if (char >= 65536)
            result += string2[i2 + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    module.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to2) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to2 + " instead, which is now safe by default.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core();
    module.exports.DEFAULT_SCHEMA = require_default();
    module.exports.load = loader.load;
    module.exports.loadAll = loader.loadAll;
    module.exports.dump = dumper.dump;
    module.exports.YAMLException = require_exception();
    module.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module.exports.safeLoad = renamed("safeLoad", "load");
    module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type2 = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b3) {
      var arr = [];
      for (var i2 = 0; i2 < a2.length; i2 += 1) {
        arr[i2] = a2[i2];
      }
      for (var j2 = 0; j2 < b3.length; j2 += 1) {
        arr[j2 + a2.length] = b3[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i2 = offset || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
        arr[j2] = arrLike[i2];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str += arr[i2];
        if (i2 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type2();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e3) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
      return x2.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e3) {
        errorProto = getProto(getProto(e3));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last = $strSlice(string2, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc2 = $gOPD(value, part);
            isOwn = !!desc2;
            if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
              value = desc2.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e3) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type2();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc2 = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc2 ? desc2.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc2 ? desc2.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc2 ? desc2.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e3) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type2();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc2 = gOPD(fn, "length");
        if (desc2 && !desc2.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc2 && !desc2.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type2();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_modules_watch_stub();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    init_modules_watch_stub();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O3) {
      return O3.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int3 = num < 0 ? -$floor(-num) : $floor(num);
        if (int3 !== num) {
          var intStr = String(int3);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i2 = 0; i2 < attrs.length; i2++) {
          s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap2(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys2 = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys2.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys2, indent) + "}";
        }
        return tag + "{ " + $join.call(ys2, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m3 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i2 = 0, l3 = xs.length; i2 < l3; i2++) {
        if (xs[i2] === x2) {
          return i2;
        }
      }
      return -1;
    }
    function isMap2(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s2) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e3) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e3) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m3) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e3) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e3) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c3) {
      var n2 = c3.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i2 = 0; i2 < xs.length; i2++) {
        if (indexOf(xs[i2], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i2 = 0; i2 < obj.length; i2++) {
          xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type2();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o2;
      var channel2 = {
        assert: function(key) {
          if (!channel2.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o2) {
              return listGet($o2, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o2) {
              return listHas($o2, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o2) {
              $o2 = { key: {}, next: null };
            }
            listSet($o2, key, value);
          }
        }
      };
      return channel2;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i2 = 0; i2 < 256; ++i2) {
        array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j2 = 0; j2 < obj.length; ++j2) {
            if (typeof obj[j2] !== "undefined") {
              compacted.push(obj[j2]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i2 = 0; i2 < source.length; ++i2) {
        if (typeof source[i2] !== "undefined") {
          obj[i2] = source[i2];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i2) {
          if (has.call(target, i2)) {
            var targetItem = target[i2];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i2] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i2] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e3) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string2 = str;
      if (typeof str === "symbol") {
        string2 = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string2 = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i2 = 0; i2 < string2.length; ++i2) {
        var c3 = string2.charCodeAt(i2);
        if (c3 === 45 || c3 === 46 || c3 === 95 || c3 === 126 || c3 >= 48 && c3 <= 57 || c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 122 || format === formats.RFC1738 && (c3 === 40 || c3 === 41)) {
          out += string2.charAt(i2);
          continue;
        }
        if (c3 < 128) {
          out = out + hexTable[c3];
          continue;
        }
        if (c3 < 2048) {
          out = out + (hexTable[192 | c3 >> 6] + hexTable[128 | c3 & 63]);
          continue;
        }
        if (c3 < 55296 || c3 >= 57344) {
          out = out + (hexTable[224 | c3 >> 12] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63]);
          continue;
        }
        i2 += 1;
        c3 = 65536 + ((c3 & 1023) << 10 | string2.charCodeAt(i2) & 1023);
        out += hexTable[240 | c3 >> 18] + hexTable[128 | c3 >> 12 & 63] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i2 = 0; i2 < queue.length; ++i2) {
        var item = queue[i2];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j2 = 0; j2 < keys.length; ++j2) {
          var key = keys[j2];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a2, b3) {
      return [].concat(a2, b3);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i2 = 0; i2 < val.length; i2 += 1) {
          mapped.push(fn(val[i2]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v3) {
      return typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || typeof v3 === "symbol" || typeof v3 === "bigint";
    };
    var sentinel = {};
    var stringify5 = function stringify6(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j2 = 0; j2 < objKeys.length; ++j2) {
        var key = objKeys[j2];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify6(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i2 = 0; i2 < objKeys.length; ++i2) {
        var key = objKeys[i2];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify5(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i2;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (parts[i2].indexOf("utf8=") === 0) {
            if (parts[i2] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i2] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i2;
            i2 = parts.length;
          }
        }
      }
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (i2 === skipIndex) {
          continue;
        }
        var part = parts[i2];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i2 = chain.length - 1; i2 >= 0; --i2) {
        var obj;
        var root = chain[i2];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i2 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
        i2 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i2 = 0; i2 < keys.length; ++i2) {
        var key = keys[i2];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var stringify5 = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify: stringify5
    };
  }
});

// ../node_modules/rusha/dist/rusha.js
var require_rusha = __commonJS({
  "../node_modules/rusha/dist/rusha.js"(exports, module) {
    init_modules_watch_stub();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Rusha"] = factory();
      else
        root["Rusha"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 3);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var RushaCore = __webpack_require__(5);
            var _require = __webpack_require__(1), toHex = _require.toHex, ceilHeapSize = _require.ceilHeapSize;
            var conv = __webpack_require__(6);
            var padlen = function(len) {
              for (len += 9; len % 64 > 0; len += 1) {
              }
              return len;
            };
            var padZeroes = function(bin, len) {
              var h8 = new Uint8Array(bin.buffer);
              var om = len % 4, align = len - om;
              switch (om) {
                case 0:
                  h8[align + 3] = 0;
                case 1:
                  h8[align + 2] = 0;
                case 2:
                  h8[align + 1] = 0;
                case 3:
                  h8[align + 0] = 0;
              }
              for (var i2 = (len >> 2) + 1; i2 < bin.length; i2++) {
                bin[i2] = 0;
              }
            };
            var padData = function(bin, chunkLen, msgLen) {
              bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
              bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen / (1 << 29) | 0;
              bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
            };
            var getRawDigest = function(heap, padMaxChunkLen) {
              var io2 = new Int32Array(heap, padMaxChunkLen + 320, 5);
              var out = new Int32Array(5);
              var arr = new DataView(out.buffer);
              arr.setInt32(0, io2[0], false);
              arr.setInt32(4, io2[1], false);
              arr.setInt32(8, io2[2], false);
              arr.setInt32(12, io2[3], false);
              arr.setInt32(16, io2[4], false);
              return out;
            };
            var Rusha = function() {
              function Rusha2(chunkSize) {
                _classCallCheck(this, Rusha2);
                chunkSize = chunkSize || 64 * 1024;
                if (chunkSize % 64 > 0) {
                  throw new Error("Chunk size must be a multiple of 128 bit");
                }
                this._offset = 0;
                this._maxChunkLen = chunkSize;
                this._padMaxChunkLen = padlen(chunkSize);
                this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
                this._h32 = new Int32Array(this._heap);
                this._h8 = new Int8Array(this._heap);
                this._core = new RushaCore({ Int32Array }, {}, this._heap);
              }
              Rusha2.prototype._initState = function _initState(heap, padMsgLen) {
                this._offset = 0;
                var io2 = new Int32Array(heap, padMsgLen + 320, 5);
                io2[0] = 1732584193;
                io2[1] = -271733879;
                io2[2] = -1732584194;
                io2[3] = 271733878;
                io2[4] = -1009589776;
              };
              Rusha2.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
                var padChunkLen = padlen(chunkLen);
                var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
                padZeroes(view, chunkLen);
                padData(view, chunkLen, msgLen);
                return padChunkLen;
              };
              Rusha2.prototype._write = function _write(data, chunkOffset, chunkLen, off) {
                conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);
              };
              Rusha2.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
                var padChunkLen = chunkLen;
                this._write(data, chunkOffset, chunkLen);
                if (finalize) {
                  padChunkLen = this._padChunk(chunkLen, msgLen);
                }
                this._core.hash(padChunkLen, this._padMaxChunkLen);
              };
              Rusha2.prototype.rawDigest = function rawDigest(str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                this._initState(this._heap, this._padMaxChunkLen);
                var chunkOffset = 0, chunkLen = this._maxChunkLen;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                  this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(this._heap, this._padMaxChunkLen);
              };
              Rusha2.prototype.digest = function digest(str) {
                return toHex(this.rawDigest(str).buffer);
              };
              Rusha2.prototype.digestFromString = function digestFromString(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromBuffer = function digestFromBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.resetState = function resetState() {
                this._initState(this._heap, this._padMaxChunkLen);
                return this;
              };
              Rusha2.prototype.append = function append(chunk) {
                var chunkOffset = 0;
                var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
                var turnOffset = this._offset % this._maxChunkLen;
                var inputLen = void 0;
                this._offset += chunkLen;
                while (chunkOffset < chunkLen) {
                  inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);
                  this._write(chunk, chunkOffset, inputLen, turnOffset);
                  turnOffset += inputLen;
                  chunkOffset += inputLen;
                  if (turnOffset === this._maxChunkLen) {
                    this._core.hash(this._maxChunkLen, this._padMaxChunkLen);
                    turnOffset = 0;
                  }
                }
                return this;
              };
              Rusha2.prototype.getState = function getState() {
                var turnOffset = this._offset % this._maxChunkLen;
                var heap = void 0;
                if (!turnOffset) {
                  var io2 = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  heap = io2.buffer.slice(io2.byteOffset, io2.byteOffset + io2.byteLength);
                } else {
                  heap = this._heap.slice(0);
                }
                return {
                  offset: this._offset,
                  heap
                };
              };
              Rusha2.prototype.setState = function setState(state) {
                this._offset = state.offset;
                if (state.heap.byteLength === 20) {
                  var io2 = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  io2.set(new Int32Array(state.heap));
                } else {
                  this._h32.set(new Int32Array(state.heap));
                }
                return this;
              };
              Rusha2.prototype.rawEnd = function rawEnd() {
                var msgLen = this._offset;
                var chunkLen = msgLen % this._maxChunkLen;
                var padChunkLen = this._padChunk(chunkLen, msgLen);
                this._core.hash(padChunkLen, this._padMaxChunkLen);
                var result = getRawDigest(this._heap, this._padMaxChunkLen);
                this._initState(this._heap, this._padMaxChunkLen);
                return result;
              };
              Rusha2.prototype.end = function end() {
                return toHex(this.rawEnd().buffer);
              };
              return Rusha2;
            }();
            module2.exports = Rusha;
            module2.exports._core = RushaCore;
          },
          /* 1 */
          /***/
          function(module2, exports2) {
            var precomputedHex = new Array(256);
            for (var i2 = 0; i2 < 256; i2++) {
              precomputedHex[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
            }
            module2.exports.toHex = function(arrayBuffer) {
              var binarray = new Uint8Array(arrayBuffer);
              var res = new Array(arrayBuffer.byteLength);
              for (var _i2 = 0; _i2 < res.length; _i2++) {
                res[_i2] = precomputedHex[binarray[_i2]];
              }
              return res.join("");
            };
            module2.exports.ceilHeapSize = function(v3) {
              var p4 = 0;
              if (v3 <= 65536)
                return 65536;
              if (v3 < 16777216) {
                for (p4 = 1; p4 < v3; p4 = p4 << 1) {
                }
              } else {
                for (p4 = 16777216; p4 < v3; p4 += 16777216) {
                }
              }
              return p4;
            };
            module2.exports.isDedicatedWorkerScope = function(self2) {
              var isRunningInWorker = "WorkerGlobalScope" in self2 && self2 instanceof self2.WorkerGlobalScope;
              var isRunningInSharedWorker = "SharedWorkerGlobalScope" in self2 && self2 instanceof self2.SharedWorkerGlobalScope;
              var isRunningInServiceWorker = "ServiceWorkerGlobalScope" in self2 && self2 instanceof self2.ServiceWorkerGlobalScope;
              return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
            };
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = function() {
              var Rusha = __webpack_require__(0);
              var hashData = function(hasher, data, cb) {
                try {
                  return cb(null, hasher.digest(data));
                } catch (e3) {
                  return cb(e3);
                }
              };
              var hashFile = function(hasher, readTotal, blockSize, file, cb) {
                var reader = new self.FileReader();
                reader.onloadend = function onloadend() {
                  if (reader.error) {
                    return cb(reader.error);
                  }
                  var buffer = reader.result;
                  readTotal += reader.result.byteLength;
                  try {
                    hasher.append(buffer);
                  } catch (e3) {
                    cb(e3);
                    return;
                  }
                  if (readTotal < file.size) {
                    hashFile(hasher, readTotal, blockSize, file, cb);
                  } else {
                    cb(null, hasher.end());
                  }
                };
                reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
              };
              var workerBehaviourEnabled = true;
              self.onmessage = function(event) {
                if (!workerBehaviourEnabled) {
                  return;
                }
                var data = event.data.data, file = event.data.file, id = event.data.id;
                if (typeof id === "undefined")
                  return;
                if (!file && !data)
                  return;
                var blockSize = event.data.blockSize || 4 * 1024 * 1024;
                var hasher = new Rusha(blockSize);
                hasher.resetState();
                var done = function(err, hash) {
                  if (!err) {
                    self.postMessage({ id, hash });
                  } else {
                    self.postMessage({ id, error: err.name });
                  }
                };
                if (data)
                  hashData(hasher, data, done);
                if (file)
                  hashFile(hasher, 0, blockSize, file, done);
              };
              return function() {
                workerBehaviourEnabled = false;
              };
            };
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var work = __webpack_require__(4);
            var Rusha = __webpack_require__(0);
            var createHash2 = __webpack_require__(7);
            var runWorker = __webpack_require__(2);
            var _require = __webpack_require__(1), isDedicatedWorkerScope = _require.isDedicatedWorkerScope;
            var isRunningInDedicatedWorker = typeof self !== "undefined" && isDedicatedWorkerScope(self);
            Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function() {
            };
            Rusha.createWorker = function() {
              var worker2 = work(
                /*require.resolve*/
                2
              );
              var terminate = worker2.terminate;
              worker2.terminate = function() {
                URL.revokeObjectURL(worker2.objectURL);
                terminate.call(worker2);
              };
              return worker2;
            };
            Rusha.createHash = createHash2;
            module2.exports = Rusha;
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function webpackBootstrapFunc(modules) {
              var installedModules = {};
              function __webpack_require__2(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module3 = installedModules[moduleId] = {
                  /******/
                  i: moduleId,
                  /******/
                  l: false,
                  /******/
                  exports: {}
                  /******/
                };
                modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                module3.l = true;
                return module3.exports;
              }
              __webpack_require__2.m = modules;
              __webpack_require__2.c = installedModules;
              __webpack_require__2.i = function(value) {
                return value;
              };
              __webpack_require__2.d = function(exports3, name, getter) {
                if (!__webpack_require__2.o(exports3, name)) {
                  Object.defineProperty(exports3, name, {
                    /******/
                    configurable: false,
                    /******/
                    enumerable: true,
                    /******/
                    get: getter
                    /******/
                  });
                }
              };
              __webpack_require__2.r = function(exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
              };
              __webpack_require__2.n = function(module3) {
                var getter = module3 && module3.__esModule ? (
                  /******/
                  function getDefault() {
                    return module3["default"];
                  }
                ) : (
                  /******/
                  function getModuleExports() {
                    return module3;
                  }
                );
                __webpack_require__2.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __webpack_require__2.p = "/";
              __webpack_require__2.oe = function(err) {
                console.error(err);
                throw err;
              };
              var f3 = __webpack_require__2(__webpack_require__2.s = ENTRY_MODULE);
              return f3.default || f3;
            }
            var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
            var dependencyRegExp = "\\((/\\*.*?\\*/)?s?.*?(" + moduleNameReqExp + ").*?\\)";
            function quoteRegExp(str) {
              return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
            }
            function getModuleDependencies(sources, module3, queueName) {
              var retval = {};
              retval[queueName] = [];
              var fnString = module3.toString();
              var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
              if (!wrapperSignature)
                return retval;
              var webpackRequireName = wrapperSignature[1];
              var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
              var match;
              while (match = re.exec(fnString)) {
                if (match[3] === "dll-reference")
                  continue;
                retval[queueName].push(match[3]);
              }
              re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
              while (match = re.exec(fnString)) {
                if (!sources[match[2]]) {
                  retval[queueName].push(match[1]);
                  sources[match[2]] = __webpack_require__(match[1]).m;
                }
                retval[match[2]] = retval[match[2]] || [];
                retval[match[2]].push(match[4]);
              }
              return retval;
            }
            function hasValuesInQueues(queues) {
              var keys = Object.keys(queues);
              return keys.reduce(function(hasValues, key) {
                return hasValues || queues[key].length > 0;
              }, false);
            }
            function getRequiredModules(sources, moduleId) {
              var modulesQueue = {
                main: [moduleId]
              };
              var requiredModules = {
                main: []
              };
              var seenModules = {
                main: {}
              };
              while (hasValuesInQueues(modulesQueue)) {
                var queues = Object.keys(modulesQueue);
                for (var i2 = 0; i2 < queues.length; i2++) {
                  var queueName = queues[i2];
                  var queue = modulesQueue[queueName];
                  var moduleToCheck = queue.pop();
                  seenModules[queueName] = seenModules[queueName] || {};
                  if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                    continue;
                  seenModules[queueName][moduleToCheck] = true;
                  requiredModules[queueName] = requiredModules[queueName] || [];
                  requiredModules[queueName].push(moduleToCheck);
                  var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                  var newModulesKeys = Object.keys(newModules);
                  for (var j2 = 0; j2 < newModulesKeys.length; j2++) {
                    modulesQueue[newModulesKeys[j2]] = modulesQueue[newModulesKeys[j2]] || [];
                    modulesQueue[newModulesKeys[j2]] = modulesQueue[newModulesKeys[j2]].concat(newModules[newModulesKeys[j2]]);
                  }
                }
              }
              return requiredModules;
            }
            module2.exports = function(moduleId, options) {
              options = options || {};
              var sources = {
                main: __webpack_require__.m
              };
              var requiredModules = options.all ? { main: Object.keys(sources) } : getRequiredModules(sources, moduleId);
              var src = "";
              Object.keys(requiredModules).filter(function(m3) {
                return m3 !== "main";
              }).forEach(function(module3) {
                var entryModule = 0;
                while (requiredModules[module3][entryModule]) {
                  entryModule++;
                }
                requiredModules[module3].push(entryModule);
                sources[module3][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                src = src + "var " + module3 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module3].map(function(id) {
                  return "" + JSON.stringify(id) + ": " + sources[module3][id].toString();
                }).join(",") + "});\n";
              });
              src = src + "(" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id) {
                return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
              }).join(",") + "})(self);";
              var blob = new window.Blob([src], { type: "text/javascript" });
              if (options.bare) {
                return blob;
              }
              var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
              var workerUrl = URL2.createObjectURL(blob);
              var worker2 = new window.Worker(workerUrl);
              worker2.objectURL = workerUrl;
              return worker2;
            };
          },
          /* 5 */
          /***/
          function(module2, exports2) {
            module2.exports = function RushaCore(stdlib$840, foreign$841, heap$842) {
              ;
              var H$843 = new stdlib$840.Int32Array(heap$842);
              function hash$844(k$845, x$846) {
                k$845 = k$845 | 0;
                x$846 = x$846 | 0;
                var i$847 = 0, j$848 = 0, y0$849 = 0, z0$850 = 0, y1$851 = 0, z1$852 = 0, y2$853 = 0, z2$854 = 0, y3$855 = 0, z3$856 = 0, y4$857 = 0, z4$858 = 0, t0$859 = 0, t1$860 = 0;
                y0$849 = H$843[x$846 + 320 >> 2] | 0;
                y1$851 = H$843[x$846 + 324 >> 2] | 0;
                y2$853 = H$843[x$846 + 328 >> 2] | 0;
                y3$855 = H$843[x$846 + 332 >> 2] | 0;
                y4$857 = H$843[x$846 + 336 >> 2] | 0;
                for (i$847 = 0; (i$847 | 0) < (k$845 | 0); i$847 = i$847 + 64 | 0) {
                  z0$850 = y0$849;
                  z1$852 = y1$851;
                  z2$854 = y2$853;
                  z3$856 = y3$855;
                  z4$858 = y4$857;
                  for (j$848 = 0; (j$848 | 0) < 64; j$848 = j$848 + 4 | 0) {
                    t1$860 = H$843[i$847 + j$848 >> 2] | 0;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[k$845 + j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 64 | 0; (j$848 | 0) < (k$845 + 80 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 80 | 0; (j$848 | 0) < (k$845 + 160 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1859775393 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 160 | 0; (j$848 | 0) < (k$845 + 240 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | y1$851 & y3$855 | y2$853 & y3$855) | 0) + ((t1$860 + y4$857 | 0) - 1894007588 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 240 | 0; (j$848 | 0) < (k$845 + 320 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) - 899497514 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  y0$849 = y0$849 + z0$850 | 0;
                  y1$851 = y1$851 + z1$852 | 0;
                  y2$853 = y2$853 + z2$854 | 0;
                  y3$855 = y3$855 + z3$856 | 0;
                  y4$857 = y4$857 + z4$858 | 0;
                }
                H$843[x$846 + 320 >> 2] = y0$849;
                H$843[x$846 + 324 >> 2] = y1$851;
                H$843[x$846 + 328 >> 2] = y2$853;
                H$843[x$846 + 332 >> 2] = y3$855;
                H$843[x$846 + 336 >> 2] = y4$857;
              }
              return { hash: hash$844 };
            };
          },
          /* 6 */
          /***/
          function(module2, exports2) {
            var _this = this;
            var reader = void 0;
            if (typeof self !== "undefined" && typeof self.FileReaderSync !== "undefined") {
              reader = new self.FileReaderSync();
            }
            var convStr = function(str, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j2 = len - lm;
              switch (om) {
                case 0:
                  H8[off] = str.charCodeAt(start + 3);
                case 1:
                  H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
                case 2:
                  H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
                case 3:
                  H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j2; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2] = str.charCodeAt(start + i2) << 24 | str.charCodeAt(start + i2 + 1) << 16 | str.charCodeAt(start + i2 + 2) << 8 | str.charCodeAt(start + i2 + 3);
              }
              switch (lm) {
                case 3:
                  H8[off + j2 + 1 | 0] = str.charCodeAt(start + j2 + 2);
                case 2:
                  H8[off + j2 + 2 | 0] = str.charCodeAt(start + j2 + 1);
                case 1:
                  H8[off + j2 + 3 | 0] = str.charCodeAt(start + j2);
              }
            };
            var convBuf = function(buf, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j2 = len - lm;
              switch (om) {
                case 0:
                  H8[off] = buf[start + 3];
                case 1:
                  H8[off + 1 - (om << 1) | 0] = buf[start + 2];
                case 2:
                  H8[off + 2 - (om << 1) | 0] = buf[start + 1];
                case 3:
                  H8[off + 3 - (om << 1) | 0] = buf[start];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j2; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2 | 0] = buf[start + i2] << 24 | buf[start + i2 + 1] << 16 | buf[start + i2 + 2] << 8 | buf[start + i2 + 3];
              }
              switch (lm) {
                case 3:
                  H8[off + j2 + 1 | 0] = buf[start + j2 + 2];
                case 2:
                  H8[off + j2 + 2 | 0] = buf[start + j2 + 1];
                case 1:
                  H8[off + j2 + 3 | 0] = buf[start + j2];
              }
            };
            var convBlob = function(blob, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j2 = len - lm;
              var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
              switch (om) {
                case 0:
                  H8[off] = buf[3];
                case 1:
                  H8[off + 1 - (om << 1) | 0] = buf[2];
                case 2:
                  H8[off + 2 - (om << 1) | 0] = buf[1];
                case 3:
                  H8[off + 3 - (om << 1) | 0] = buf[0];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j2; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2 | 0] = buf[i2] << 24 | buf[i2 + 1] << 16 | buf[i2 + 2] << 8 | buf[i2 + 3];
              }
              switch (lm) {
                case 3:
                  H8[off + j2 + 1 | 0] = buf[j2 + 2];
                case 2:
                  H8[off + j2 + 2 | 0] = buf[j2 + 1];
                case 1:
                  H8[off + j2 + 3 | 0] = buf[j2];
              }
            };
            module2.exports = function(data, H8, H32, start, len, off) {
              if (typeof data === "string") {
                return convStr(data, H8, H32, start, len, off);
              }
              if (data instanceof Array) {
                return convBuf(data, H8, H32, start, len, off);
              }
              if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {
                return convBuf(data, H8, H32, start, len, off);
              }
              if (data instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data), H8, H32, start, len, off);
              }
              if (data.buffer instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);
              }
              if (data instanceof Blob) {
                return convBlob(data, H8, H32, start, len, off);
              }
              throw new Error("Unsupported data type.");
            };
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Rusha = __webpack_require__(0);
            var _require = __webpack_require__(1), toHex = _require.toHex;
            var Hash = function() {
              function Hash2() {
                _classCallCheck(this, Hash2);
                this._rusha = new Rusha();
                this._rusha.resetState();
              }
              Hash2.prototype.update = function update(data) {
                this._rusha.append(data);
                return this;
              };
              Hash2.prototype.digest = function digest(encoding) {
                var digest2 = this._rusha.rawEnd().buffer;
                if (!encoding) {
                  return digest2;
                }
                if (encoding === "hex") {
                  return toHex(digest2);
                }
                throw new Error("unsupported digest encoding");
              };
              _createClass(Hash2, [{
                key: "state",
                get: function() {
                  return this._rusha.getState();
                },
                set: function(state) {
                  this._rusha.setState(state);
                }
              }]);
              return Hash2;
            }();
            module2.exports = function() {
              return new Hash();
            };
          }
          /******/
        ])
      );
    });
  }
});

// ../node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "../node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject2 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject2(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l3;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i2 = 0, l3 = obj.length; i2 < l3; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i2 = keys.length;
      let _key;
      while (i2-- > 0) {
        _key = keys[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l3 = arguments.length; i2 < l3; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue);
      }
      return result;
    }
    var extend = (a2, b3, thisArg, { allOwnKeys } = {}) => {
      forEach(b3, (val, key) => {
        if (thisArg && isFunction(val)) {
          a2[key] = bind(val, thisArg);
        } else {
          a2[key] = val;
        }
      }, { allOwnKeys });
      return a2;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m3, p1, p22) {
          return p1.toUpperCase() + p22;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit3 = (source, i2) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit3(value, i2 + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit3(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject2,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message2, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i2) {
        token = removeBrackets(token);
        return !dots && i2 ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index2) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i2;
      const len = keys.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name = path[index2++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index2);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e3) {
          if (e3.name !== "SyntaxError") {
            throw e3;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e3) {
            if (strictJSONParsing) {
              if (e3.name === "SyntaxError") {
                throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e3;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader2(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader2(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader2(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader2(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader2(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i2 = keys.length;
        let deleted = false;
        while (i2--) {
          const key = keys[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader2(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message2, config, request) {
      AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test("Cloudflare-Workers");
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e3) => {
        const loaded = e3.loaded;
        const total = e3.lengthComputable ? e3.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e3
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e3) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i2 = 0; i2 < length; i2++) {
          nameOrAdapter = adapters2[i2];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i2] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s2,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b3, caseless) {
        if (!utils$1.isUndefined(b3)) {
          return getMergedValue(a2, b3, caseless);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2, caseless);
        }
      }
      function valueFromConfig2(a2, b3) {
        if (!utils$1.isUndefined(b3)) {
          return getMergedValue(void 0, b3);
        }
      }
      function defaultToConfig2(a2, b3) {
        if (!utils$1.isUndefined(b3)) {
          return getMergedValue(void 0, b3);
        } else if (!utils$1.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b3, prop) {
        if (prop in config2) {
          return getMergedValue(a2, b3);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b3) => mergeDeepProperties(headersToObject(a2), headersToObject(b3), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.6.8";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version3, message2) {
      function formatMessage(opt, desc2) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc2 + (message2 ? ". " + message2 : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version3 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version3 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema4, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i2 = keys.length;
      while (i2-- > 0) {
        const opt = keys[i2];
        const validator2 = schema4[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i2 = token._listeners.length;
          while (i2-- > 0) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message2, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message2, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c3) {
          cancel = c3;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "node_modules/bcryptjs/dist/bcrypt.js"(exports, module) {
    init_modules_watch_stub();
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports, function() {
      "use strict";
      var bcrypt3 = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module !== "undefined" && module && module["exports"])
          try {
            return __require("crypto")["randomBytes"](len);
          } catch (e3) {
          }
        try {
          var a2;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a2 = new Uint32Array(len));
          return Array.prototype.slice.call(a2);
        } catch (e3) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e3) {
      }
      randomFallback = null;
      bcrypt3.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt3.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt3.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick(function() {
            try {
              callback2(null, bcrypt3.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt3.hashSync = function(s2, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt3.genSaltSync(salt);
        if (typeof s2 !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s2 + ", " + typeof salt);
        return _hash2(s2, salt);
      };
      bcrypt3.hash = function(s2, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s2 === "string" && typeof salt === "number")
            bcrypt3.genSalt(salt, function(err, salt2) {
              _hash2(s2, salt2, callback2, progressCallback);
            });
          else if (typeof s2 === "string" && typeof salt === "string")
            _hash2(s2, salt, callback2, progressCallback);
          else
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s2 + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i2 = 0, k2 = known.length; i2 < k2; ++i2) {
          if (known.charCodeAt(i2) === unknown.charCodeAt(i2))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt3.compareSync = function(s2, hash) {
        if (typeof s2 !== "string" || typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof s2 + ", " + typeof hash);
        if (hash.length !== 60)
          return false;
        return safeStringCompare(bcrypt3.hashSync(s2, hash.substr(0, hash.length - 31)), hash);
      };
      bcrypt3.compare = function(s2, hash, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s2 !== "string" || typeof hash !== "string") {
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s2 + ", " + typeof hash)));
            return;
          }
          if (hash.length !== 60) {
            nextTick(callback2.bind(this, null, false));
            return;
          }
          bcrypt3.hash(s2, hash.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt3.getRounds = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        return parseInt(hash.split("$")[2], 10);
      };
      bcrypt3.getSalt = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        if (hash.length !== 60)
          throw Error("Illegal hash length: " + hash.length + " != 60");
        return hash.substring(0, 29);
      };
      var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i2 = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i2 >= str.length)
            return null;
          return str.charCodeAt(i2++);
        }, function(b3) {
          out.push(b3);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b3, len) {
        var off = 0, rs2 = [], c1, c22;
        if (len <= 0 || len > b3.length)
          throw Error("Illegal len: " + len);
        while (off < len) {
          c1 = b3[off++] & 255;
          rs2.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c22 = b3[off++] & 255;
          c1 |= c22 >> 4 & 15;
          rs2.push(BASE64_CODE[c1 & 63]);
          c1 = (c22 & 15) << 2;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c22 = b3[off++] & 255;
          c1 |= c22 >> 6 & 3;
          rs2.push(BASE64_CODE[c1 & 63]);
          rs2.push(BASE64_CODE[c22 & 63]);
        }
        return rs2.join("");
      }
      function base64_decode(s2, len) {
        var off = 0, slen = s2.length, olen = 0, rs2 = [], c1, c22, c3, c4, o2, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off < slen - 1 && olen < len) {
          code = s2.charCodeAt(off++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s2.charCodeAt(off++);
          c22 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c22 == -1)
            break;
          o2 = c1 << 2 >>> 0;
          o2 |= (c22 & 48) >> 4;
          rs2.push(stringFromCharCode(o2));
          if (++olen >= len || off >= slen)
            break;
          code = s2.charCodeAt(off++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o2 = (c22 & 15) << 4 >>> 0;
          o2 |= (c3 & 60) >> 2;
          rs2.push(stringFromCharCode(o2));
          if (++olen >= len || off >= slen)
            break;
          code = s2.charCodeAt(off++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o2 = (c3 & 3) << 6 >>> 0;
          o2 |= c4;
          rs2.push(stringFromCharCode(o2));
          ++olen;
        }
        var res = [];
        for (off = 0; off < olen; off++)
          res.push(rs2[off].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp < 128)
              dst(cp & 127);
            else if (cp < 2048)
              dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
            else if (cp < 65536)
              dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            else
              dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            cp = null;
          }
        };
        utfx2.decodeUTF8 = function(src, dst) {
          var a2, b3, c3, d4, fail = function(b4) {
            b4 = b4.slice(0, b4.indexOf(null));
            var err = Error(b4.toString());
            err.name = "TruncatedError";
            err["bytes"] = b4;
            throw err;
          };
          while ((a2 = src()) !== null) {
            if ((a2 & 128) === 0)
              dst(a2);
            else if ((a2 & 224) === 192)
              (b3 = src()) === null && fail([a2, b3]), dst((a2 & 31) << 6 | b3 & 63);
            else if ((a2 & 240) === 224)
              ((b3 = src()) === null || (c3 = src()) === null) && fail([a2, b3, c3]), dst((a2 & 15) << 12 | (b3 & 63) << 6 | c3 & 63);
            else if ((a2 & 248) === 240)
              ((b3 = src()) === null || (c3 = src()) === null || (d4 = src()) === null) && fail([a2, b3, c3, d4]), dst((a2 & 7) << 18 | (b3 & 63) << 12 | (c3 & 63) << 6 | d4 & 63);
            else
              throw RangeError("Illegal starting byte: " + a2);
          }
        };
        utfx2.UTF16toUTF8 = function(src, dst) {
          var c1, c22 = null;
          while (true) {
            if ((c1 = c22 !== null ? c22 : src()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c22 = src()) !== null) {
                if (c22 >= 56320 && c22 <= 57343) {
                  dst((c1 - 55296) * 1024 + c22 - 56320 + 65536);
                  c22 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c22 !== null)
            dst(c22);
        };
        utfx2.UTF8toUTF16 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp <= 65535)
              dst(cp);
            else
              cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
            cp = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src, dst) {
          utfx2.UTF16toUTF8(src, function(cp) {
            utfx2.encodeUTF8(cp, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src, dst) {
          utfx2.decodeUTF8(src, function(cp) {
            utfx2.UTF8toUTF16(cp, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp) {
          return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src) {
          var cp, l3 = 0;
          while ((cp = src()) !== null)
            l3 += utfx2.calculateCodePoint(cp);
          return l3;
        };
        utfx2.calculateUTF16asUTF8 = function(src) {
          var n2 = 0, l3 = 0;
          utfx2.UTF16toUTF8(src, function(cp) {
            ++n2;
            l3 += utfx2.calculateCodePoint(cp);
          });
          return [n2, l3];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +/* @__PURE__ */ new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr2, off, P2, S3) {
        var n2, l3 = lr2[off], r2 = lr2[off + 1];
        l3 ^= P2[0];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[1];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[2];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[3];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[4];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[5];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[6];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[7];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[8];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[9];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[10];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[11];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[12];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[13];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[14];
        n2 = S3[l3 >>> 24];
        n2 += S3[256 | l3 >> 16 & 255];
        n2 ^= S3[512 | l3 >> 8 & 255];
        n2 += S3[768 | l3 & 255];
        r2 ^= n2 ^ P2[15];
        n2 = S3[r2 >>> 24];
        n2 += S3[256 | r2 >> 16 & 255];
        n2 ^= S3[512 | r2 >> 8 & 255];
        n2 += S3[768 | r2 & 255];
        l3 ^= n2 ^ P2[16];
        lr2[off] = r2 ^ P2[BLOWFISH_NUM_ROUNDS + 1];
        lr2[off + 1] = l3;
        return lr2;
      }
      function _streamtoword(data, offp) {
        for (var i2 = 0, word = 0; i2 < 4; ++i2)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P2, S3) {
        var offset = 0, lr2 = [0, 0], plen = P2.length, slen = S3.length, sw;
        for (var i2 = 0; i2 < plen; i2++)
          sw = _streamtoword(key, offset), offset = sw.offp, P2[i2] = P2[i2] ^ sw.key;
        for (i2 = 0; i2 < plen; i2 += 2)
          lr2 = _encipher(lr2, 0, P2, S3), P2[i2] = lr2[0], P2[i2 + 1] = lr2[1];
        for (i2 = 0; i2 < slen; i2 += 2)
          lr2 = _encipher(lr2, 0, P2, S3), S3[i2] = lr2[0], S3[i2 + 1] = lr2[1];
      }
      function _ekskey(data, key, P2, S3) {
        var offp = 0, lr2 = [0, 0], plen = P2.length, slen = S3.length, sw;
        for (var i2 = 0; i2 < plen; i2++)
          sw = _streamtoword(key, offp), offp = sw.offp, P2[i2] = P2[i2] ^ sw.key;
        offp = 0;
        for (i2 = 0; i2 < plen; i2 += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr2[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr2[1] ^= sw.key, lr2 = _encipher(lr2, 0, P2, S3), P2[i2] = lr2[0], P2[i2 + 1] = lr2[1];
        for (i2 = 0; i2 < slen; i2 += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr2[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr2[1] ^= sw.key, lr2 = _encipher(lr2, 0, P2, S3), S3[i2] = lr2[0], S3[i2 + 1] = lr2[1];
      }
      function _crypt(b3, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P2, S3, i2 = 0, j2;
        if (Int32Array) {
          P2 = new Int32Array(P_ORIG);
          S3 = new Int32Array(S_ORIG);
        } else {
          P2 = P_ORIG.slice();
          S3 = S_ORIG.slice();
        }
        _ekskey(salt, b3, P2, S3);
        function next() {
          if (progressCallback)
            progressCallback(i2 / rounds);
          if (i2 < rounds) {
            var start = Date.now();
            for (; i2 < rounds; ) {
              i2 = i2 + 1;
              _key(b3, P2, S3);
              _key(salt, P2, S3);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i2 = 0; i2 < 64; i2++)
              for (j2 = 0; j2 < clen >> 1; j2++)
                _encipher(cdata, j2 << 1, P2, S3);
            var ret = [];
            for (i2 = 0; i2 < clen; i2++)
              ret.push((cdata[i2] >> 24 & 255) >>> 0), ret.push((cdata[i2] >> 16 & 255) >>> 0), ret.push((cdata[i2] >> 8 & 255) >>> 0), ret.push((cdata[i2] & 255) >>> 0);
            if (callback) {
              callback(null, ret);
              return;
            } else
              return ret;
          }
          if (callback)
            nextTick(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash2(s2, salt, callback, progressCallback) {
        var err;
        if (typeof s2 !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s2 += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s2), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes));
          }, progressCallback);
        }
      }
      bcrypt3.encodeBase64 = base64_encode;
      bcrypt3.decodeBase64 = base64_decode;
      return bcrypt3;
    });
  }
});

// src/index.ts
init_modules_watch_stub();

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
init_modules_watch_stub();

// node_modules/@cloudflare/itty-router-openapi/node_modules/itty-router/index.mjs
init_modules_watch_stub();
var e = ({ base: e3 = "", routes: t2 = [] } = {}) => ({ __proto__: new Proxy({}, { get: (o2, s2, r2, n2) => (o3, ...a2) => t2.push([s2.toUpperCase(), RegExp(`^${(n2 = (e3 + o3).replace(/\/+(\/|$)/g, "$1")).replace(/(\/?\.?):(\w+)\+/g, "($1(?<$2>*))").replace(/(\/?\.?):(\w+)/g, "($1(?<$2>[^$1/]+?))").replace(/\./g, "\\.").replace(/(\/?)\*/g, "($1.*)?")}/*$`), a2, n2]) && r2 }), routes: t2, async handle(e4, ...o2) {
  let s2, r2, n2 = new URL(e4.url), a2 = e4.query = { __proto__: null };
  for (let [e5, t3] of n2.searchParams)
    a2[e5] = a2[e5] ? [].concat(a2[e5], t3) : t3;
  for (let [a3, c3, l3, i2] of t2)
    if ((a3 === e4.method || "ALL" === a3) && (r2 = n2.pathname.match(c3))) {
      e4.params = r2.groups || {}, e4.route = i2;
      for (let t3 of l3)
        if (null != (s2 = await t3(e4.proxy ?? e4, ...o2)))
          return s2;
    }
} });
var o = (e3 = "text/plain; charset=utf-8", t2) => (o2, { headers: s2 = {}, ...r2 } = {}) => void 0 === o2 || "Response" === o2?.constructor.name ? o2 : new Response(t2 ? t2(o2) : o2, { headers: { "content-type": e3, ...s2 }, ...r2 });
var s = o("application/json; charset=utf-8", JSON.stringify);
var c = o("text/plain; charset=utf-8", String);
var l = o("text/html");
var i = o("image/jpeg");
var p = o("image/png");
var d = o("image/webp");

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
var import_zod_to_openapi = __toESM(require_dist(), 1);

// node_modules/zod/lib/index.mjs
init_modules_watch_stub();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a90;
    const ctx = {
      common: {
        issues: [],
        async: (_a90 = params === null || params === void 0 ? void 0 : params.async) !== null && _a90 !== void 0 ? _a90 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a90) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a90;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a90 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a90 !== void 0 ? _a90 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a90;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a90 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a90 !== void 0 ? _a90 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a90;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a90 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a90 !== void 0 ? _a90 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodArray.create = (schema4, params) => {
  return new ZodArray({
    type: schema4,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema4) {
  if (schema4 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema4.shape) {
      const fieldSchema = schema4.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema4._def,
      shape: () => newShape
    });
  } else if (schema4 instanceof ZodArray) {
    return new ZodArray({
      ...schema4._def,
      type: deepPartialify(schema4.element)
    });
  } else if (schema4 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodTuple) {
    return ZodTuple.create(schema4.items.map((item) => deepPartialify(item)));
  } else {
    return schema4;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a90, _b, _c, _d;
          const defaultError = (_c = (_b = (_a90 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a90, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema4) {
    return this.augment({ [key]: schema4 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b3) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b3);
  if (a2 === b3) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b3[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b3) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema4 = this._def.items[itemIndex] || this._def.rest;
      if (!schema4)
        return null;
      return schema4._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas2, params) => {
  if (!Array.isArray(schemas2)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas2,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e3) => {
          error.addIssue(makeArgsIssue(args, e3));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e3) => {
          error.addIssue(makeReturnsIssue(result, e3));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema4, params) => {
  return new ZodPromise({
    type: schema4,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema4, effect, params) => {
  return new ZodEffects({
    schema: schema4,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema4, params) => {
  return new ZodEffects({
    schema: schema4,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b3) {
    return new ZodPipeline({
      in: a2,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a90, _b;
      if (!check(data)) {
        const p4 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a90 = p4.fatal) !== null && _a90 !== void 0 ? _a90 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p4 === "string" ? { message: p4 } : p4;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
function c2(A) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="SwaggerIU"/>
    <title>SwaggerUI</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui.css"/>
    <link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlMb//2ux//9or///ZKz//wlv5f8JcOf/CnXv/why7/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2vi/wZo3/9ytf//b7P//2uw//+BvP//DHbp/w568P8Md+//CnXv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApv4/8HbOH/lMf//3W3//9ytf//brL//w946v8SfvH/EHzw/w558P8AAAAAAAAAAAAAAAAAAAAAAAAAABF56f8Ndef/C3Dj/whs4f98u///eLn//3W3//+Evv//FoPx/xSA8f8SfvD/EHvw/wAAAAAAAAAAAAAAAA1EeF0WgOz/EXrp/w515v8LceT/lsn//3+9//97u///eLj//xaB7f8YhfL/FoLx/xSA8f8JP/deAAAAAAAAAAAgjfH/HIjw/xeB7P8Te+n/AAAAAAAAAACGwf//gr///369//+Iwf//HIny/xqH8v8YhfL/FYLx/wAAAAAnlfPlJJLy/yGO8v8cifD/GILt/wAAAAAAAAAAmMz//4nD//+Fwf//gb///xyJ8P8ejPP/HIny/xmH8v8XhPLnK5r0/yiW8/8lk/P/IpDy/wAAAAAAAAAAAAAAAAAAAACPx///jMX//4jD//+MxP//IpD0/yCO8/8di/P/G4ny/y6e9f8sm/T/KZj0/yaV8/8AAAAAAAAAAAAAAAAAAAAAlsz//5LJ//+Px///lMn//yaV9P8kkvT/IZD0/x+O8/8yo/blMKD1/y2d9f8qmfT/KJbz/wAAAAAAAAAAqdb//53Q//+Zzv//lsv//yiY8/8qmvX/KJf1/yWV9P8jkvTQAAAAADSl9v8xofX/Lp71/yyb9P8AAAAAAAAAAKfW//+k1P//oNL//6rW//8wofb/Lp72/yuc9f8pmfX/AAAAAAAAAAAcVHtcNab2/zKj9v8voPX/LZz0/7vh//+u2///qtj//6fW//8wofT/NKX3/zKj9/8voPb/F8/6XgAAAAAAAAAAAAAAADmr9/82qPf/M6T2/zCg9f+44f//td///7Hd//++4v//Oqz4/ziq+P81p/f/M6X3/wAAAAAAAAAAAAAAAAAAAAAAAAAAOqz4/zep9//M6///v+X//7vj//+44f//OKn1/z6x+f88rvn/Oaz4/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6x+f8qmfP/yOv//8bq///C5///z+z//0O3+v9Ctfr/QLP5/z2x+f8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0u///8jr///I6///yOv//zmq9f9Dt/r/Q7f6/0O3+v8AAAAAAAAAAAAAAAAAAAAA8A8AAOAHAADgBwAAwAMAAMADAACGAQAABgAAAA8AAAAPAAAABgAAAIYBAADAAwAAwAMAAOAHAADgBwAA8A8AAA==" />
</head>
<body>
<div id="swagger-ui"></div>
<script src="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui-bundle.js" crossorigin><\/script>
<script src="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui-standalone-preset.js" crossorigin><\/script>
<script>
    window.onload = () => {
        window.ui = SwaggerUIBundle({
            url: '${A = A.replace(/\/+(\/|$)/g, "$1")}',
            dom_id: '#swagger-ui',
            deepLinking: true,
            presets: [
                SwaggerUIBundle.presets.apis
            ]
        });
    };
<\/script>
</body>
</html>`;
}
function u(A) {
  return `<!DOCTYPE html>
    <html>
    <head>
    <title>ReDocUI</title>
    <!-- needed for adaptive design -->
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlMb//2ux//9or///ZKz//wlv5f8JcOf/CnXv/why7/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2vi/wZo3/9ytf//b7P//2uw//+BvP//DHbp/w568P8Md+//CnXv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApv4/8HbOH/lMf//3W3//9ytf//brL//w946v8SfvH/EHzw/w558P8AAAAAAAAAAAAAAAAAAAAAAAAAABF56f8Ndef/C3Dj/whs4f98u///eLn//3W3//+Evv//FoPx/xSA8f8SfvD/EHvw/wAAAAAAAAAAAAAAAA1EeF0WgOz/EXrp/w515v8LceT/lsn//3+9//97u///eLj//xaB7f8YhfL/FoLx/xSA8f8JP/deAAAAAAAAAAAgjfH/HIjw/xeB7P8Te+n/AAAAAAAAAACGwf//gr///369//+Iwf//HIny/xqH8v8YhfL/FYLx/wAAAAAnlfPlJJLy/yGO8v8cifD/GILt/wAAAAAAAAAAmMz//4nD//+Fwf//gb///xyJ8P8ejPP/HIny/xmH8v8XhPLnK5r0/yiW8/8lk/P/IpDy/wAAAAAAAAAAAAAAAAAAAACPx///jMX//4jD//+MxP//IpD0/yCO8/8di/P/G4ny/y6e9f8sm/T/KZj0/yaV8/8AAAAAAAAAAAAAAAAAAAAAlsz//5LJ//+Px///lMn//yaV9P8kkvT/IZD0/x+O8/8yo/blMKD1/y2d9f8qmfT/KJbz/wAAAAAAAAAAqdb//53Q//+Zzv//lsv//yiY8/8qmvX/KJf1/yWV9P8jkvTQAAAAADSl9v8xofX/Lp71/yyb9P8AAAAAAAAAAKfW//+k1P//oNL//6rW//8wofb/Lp72/yuc9f8pmfX/AAAAAAAAAAAcVHtcNab2/zKj9v8voPX/LZz0/7vh//+u2///qtj//6fW//8wofT/NKX3/zKj9/8voPb/F8/6XgAAAAAAAAAAAAAAADmr9/82qPf/M6T2/zCg9f+44f//td///7Hd//++4v//Oqz4/ziq+P81p/f/M6X3/wAAAAAAAAAAAAAAAAAAAAAAAAAAOqz4/zep9//M6///v+X//7vj//+44f//OKn1/z6x+f88rvn/Oaz4/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6x+f8qmfP/yOv//8bq///C5///z+z//0O3+v9Ctfr/QLP5/z2x+f8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0u///8jr///I6///yOv//zmq9f9Dt/r/Q7f6/0O3+v8AAAAAAAAAAAAAAAAAAAAA8A8AAOAHAADgBwAAwAMAAMADAACGAQAABgAAAA8AAAAPAAAABgAAAIYBAADAAwAAwAMAAOAHAADgBwAA8A8AAA==" />

    <!--
    ReDoc doesn't change outer page styles
    -->
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
    </head>
    <body>
    <redoc spec-url="${A = A.replace(/\/+(\/|$)/g, "$1")}"></redoc>
    <script src="https://unpkg.com/redoc@2.0.0-rc.58/bundles/redoc.standalone.js"> <\/script>
    </body>
    </html>`;
}
var p2;
var l2;
var f;
!function(A) {
  A.V1 = "v1";
}(p2 || (p2 = {})), function(A) {
  A.NONE = "none", A.OAUTH = "oauth", A.SERVICE_HTTP = "service_http", A.USER_HTTP = "user_http";
}(l2 || (l2 = {})), function(A) {
  A.OPENAPI = "openapi";
}(f || (f = {}));
var d2 = class extends import_zod_to_openapi.OpenAPIRegistry {
  _definitions = [];
  merge(A) {
    for (const e3 of A._definitions)
      this._definitions.push({ ...e3 });
  }
};
var m = require_js_yaml();
function h(e3) {
  const n2 = new d2(), o2 = () => {
    let A = import_zod_to_openapi.OpenApiGeneratorV31;
    "3" === e3?.openapiVersion && (A = import_zod_to_openapi.OpenApiGeneratorV3);
    return new A(n2.definitions).generateDocument({ openapi: "3" === e3?.openapiVersion ? "3.0.3" : "3.1.0", info: { version: e3?.schema?.info?.version || "1.0.0", title: e3?.schema?.info?.title || "OpenAPI", ...e3?.schema?.info }, ...e3?.schema });
  }, a2 = (e3?.baseRouter || e)({ base: e3?.base, routes: e3?.routes }), i2 = new Proxy(a2, { get: (A, t2, r2, i3) => "original" === t2 ? a2 : "schema" === t2 ? o2() : "registry" === t2 ? n2 : (o3, ...a3) => {
    if ("handle" !== t2) {
      if (1 === a3.length && a3[0].registry) {
        const A2 = a3[0];
        n2.merge(A2.registry);
      } else if ("all" !== t2) {
        const A2 = ((e3?.base || "") + o3).replaceAll(/\/+(\/|$)/g, "$1").replaceAll(/:(\w+)/g, "{$1}");
        let r3, i4;
        for (const A3 of a3)
          if (A3.name && (i4 = `${t2.toString()}_${A3.name}`), A3.getSchemaZod) {
            r3 = A3.getSchemaZod();
            break;
          }
        if (void 0 === i4 && (i4 = `${t2.toString()}_${o3.replaceAll("/", "_")}`), void 0 === r3) {
          r3 = { operationId: i4, responses: { 200: { description: "Object with user data." } } };
          const A3 = ((e3?.base || "") + o3).match(/:(\w+)/g);
          A3 && (r3.request = { params: z.object(A3.reduce((A4, e4) => Object.assign(A4, { [e4.replace(":", "")]: z.string() }), {})) });
        } else if (!r3.operationId) {
          if (false === e3?.generateOperationIds && !r3.operationId)
            throw new Error(`Route ${o3} don't have operationId set!`);
          r3.operationId = i4;
        }
        n2.registerPath({ ...r3, method: t2.toString(), path: A2 });
      }
    }
    return Reflect.get(A, t2, r2)(o3, ...a3.map((A2) => A2.handle ? A2.handle : A2.isRoute ? (...e4) => new A2({}).execute(...e4) : A2));
  } });
  return null !== e3?.docs_url && null !== e3?.openapi_url && a2.get(e3?.docs_url || "/docs", () => new Response(c2((e3?.base || "") + (e3?.openapi_url || "/openapi.json")), { headers: { "content-type": "text/html; charset=UTF-8" }, status: 200 })), null !== e3?.redoc_url && null !== e3?.openapi_url && a2.get(e3?.redoc_url || "/redocs", () => new Response(u((e3?.base || "") + (e3?.openapi_url || "/openapi.json")), { headers: { "content-type": "text/html; charset=UTF-8" }, status: 200 })), null !== e3?.openapi_url && (a2.get(e3?.openapi_url || "/openapi.json", () => new Response(JSON.stringify(o2()), { headers: { "content-type": "application/json;charset=UTF-8" }, status: 200 })), a2.get((e3?.openapi_url || "/openapi.json").replace(".json", ".yaml"), () => new Response(m.dump(o2()), { headers: { "content-type": "text/yaml;charset=UTF-8" }, status: 200 }))), e3?.aiPlugin && null !== e3?.openapi_url && a2.get("/.well-known/ai-plugin.json", (A) => {
    const t2 = { type: f.OPENAPI, has_user_authentication: false, url: e3?.openapi_url || "/openapi.json", ...e3?.aiPlugin?.api };
    return t2.url.startsWith("http") || (t2.url = `https://${A.headers.get("host")}${t2.url}`), new Response(JSON.stringify({ schema_version: p2.V1, auth: { type: l2.NONE }, ...e3?.aiPlugin, api: t2 }), { headers: { "content-type": "application/json;charset=UTF-8" }, status: 200 });
  }), i2;
}
function g(A) {
  return void 0 !== A._def;
}
function y(A, e3) {
  return "ZodArray" === A._def.typeName || "ZodArray" === A._def.innerType?._def.typeName || "ZodArray" === A._def.schema?._def.innerType?._def.typeName;
}
function w(A, e3) {
  if (e3 = e3 || {}, null === A)
    return new q({ required: false, ...e3 });
  if (g(A))
    return e3 ? v(A, e3) : A;
  if (true === A.generator)
    return new A(e3);
  if (A === String)
    return new q(e3);
  if ("string" == typeof A)
    return new q({ example: A });
  if (A === Number)
    return new j(e3);
  if ("number" == typeof A)
    return new j({ example: A });
  if (A === Boolean)
    return new S(e3);
  if ("boolean" == typeof A)
    return new S({ example: A });
  if (A === Date)
    return new O(e3);
  if (Array.isArray(A)) {
    if (0 === A.length)
      throw new Error("Arr must have a type");
    return new b(A[0], e3);
  }
  if ("object" == typeof A)
    return new P(A, e3);
  throw new Error(`${A} not implemented`);
}
function v(A, e3) {
  return false === (e3 = e3 || {}).required && (A = A.optional()), e3.description && (A = A.describe(e3.description)), e3.default && (A = A.default(e3.default)), e3.example && (A = A.openapi({ example: e3.example })), e3.format && (A = A.openapi({ format: e3.format })), A;
}
void 0 === z.string().openapi && (0, import_zod_to_openapi.extendZodWithOpenApi)(z);
var b = class {
  constructor(A, e3) {
    return v(w(A).array(), e3);
  }
};
__publicField(b, "generator", true);
var P = class {
  constructor(A, e3) {
    const t2 = {};
    for (const [e4, r2] of Object.entries(A))
      t2[e4] = w(r2);
    return v(z.object(t2), e3);
  }
};
__publicField(P, "generator", true);
var j = class {
  constructor(A) {
    return v(z.number().or(z.string()).pipe(z.coerce.number()), A).openapi({ type: "number" });
  }
};
__publicField(j, "generator", true);
var q = class {
  constructor(A) {
    return v(z.string(), A);
  }
};
__publicField(q, "generator", true);
var O = class {
  constructor(A) {
    return v(z.string().datetime({ message: "Must be in the following format: YYYY-mm-ddTHH:MM:ssZ" }), A);
  }
};
__publicField(O, "generator", true);
var S = class {
  constructor(A) {
    return v(z.coerce.string().toLowerCase().pipe(z.enum(["true", "false"]).transform((A2) => "true" === A2)), A).openapi({ type: "boolean" });
  }
};
__publicField(S, "generator", true);
function M(A, e3 = {}) {
  return { name: e3.name, location: "query", type: w(A, e3) };
}
function Z(A, e3) {
  const { searchParams: t2 } = new URL(A.url);
  if (0 === t2.size)
    return null;
  const r2 = {};
  for (let [A2, n2] of t2.entries())
    "" === n2 && (n2 = null), void 0 === r2[A2] ? r2[A2] = n2 : Array.isArray(r2[A2]) ? r2[A2].push(n2) : r2[A2] = [r2[A2], n2], e3 && e3.shape[A2] && (y(e3.shape[A2]) && !Array.isArray(r2[A2]) ? r2[A2] = [r2[A2]] : y(e3.shape[A2]));
  return r2;
}
function X(A, e3) {
  return new Response(JSON.stringify(A), { headers: { "content-type": "application/json;charset=UTF-8" }, status: e3?.status ? e3.status : 200, ...e3 });
}
var K = class {
  handle(A, ...e3) {
    throw new Error("Method not implemented.");
  }
  params;
  constructor(A) {
    this.params = A;
  }
  static getSchema() {
    return this.schema;
  }
  schema() {
    return this.__proto__.constructor.schema;
  }
  getSchema() {
    return this.__proto__.constructor.getSchema();
  }
  getSchemaZod() {
    return this.__proto__.constructor.getSchemaZod();
  }
  static getSchemaZod() {
    const A = { ...this.getSchema() };
    let e3 = {}, t2 = A.requestBody;
    const r2 = {}, n2 = {};
    t2 && t2.$customRequestBody ? n2.requestBody = t2.content : t2 && (g(t2) || (t2 = w(t2)), t2 = { content: { "application/json": { schema: t2 } } }, e3.body = t2), A.responses || (A.responses = { 200: { description: "Successfull response", schema: {} } });
    for (const [e4, t3] of Object.entries(A.responses)) {
      let A2 = t3.schema || {};
      g(A2) || (A2 = w(A2));
      const n3 = t3.contentType || "application/json";
      r2[e4] = { description: t3.description, content: { [n3]: { schema: A2 } } };
    }
    if (A.parameters) {
      let t3 = A.parameters;
      const r3 = {};
      Array.isArray(t3) && (t3 = t3.reduce((A2, e4) => Object.assign(A2, { [e4.name]: e4 }), {}));
      for (const [A2, e4] of Object.entries(t3))
        r3[e4.location] || (r3[e4.location] = {}), r3[e4.location][A2] = e4.type;
      for (const [A2, e4] of Object.entries(r3))
        r3[A2] = z.object(e4);
      e3 = { ...e3, ...r3 };
    }
    return delete A.requestBody, delete A.parameters, delete A.responses, { ...A, request: { ...e3 }, responses: r2, ...n2 };
  }
  handleValidationError(A) {
    return X({ errors: A, success: false, result: {} }, { status: 400 });
  }
  async execute(...A) {
    const { data: e3, errors: t2 } = await this.validateRequest(A[0]);
    if (t2)
      return this.handleValidationError(t2);
    A.push(e3);
    const r2 = await this.handle(...A);
    return r2 instanceof Response || "object" != typeof r2 ? r2 : X(r2);
  }
  extractQueryParameters(A, e3) {
    return Z(A, e3);
  }
  async validateRequest(A) {
    const e3 = this.__proto__.constructor.getSchemaZod(), t2 = {}, r2 = {};
    e3.request?.params && (r2.params = e3.request?.params, t2.params = A.params), e3.request?.query && (r2.query = e3.request?.query, t2.query = {}), e3.request?.headers && (r2.headers = e3.request?.headers, t2.headers = {});
    const n2 = this.extractQueryParameters(A, e3.request?.query);
    if (n2 && (t2.query = n2), e3.request?.headers) {
      t2.headers = {};
      for (const r3 of Object.keys(e3.request?.headers.shape))
        t2.headers[r3] = A.headers.get(r3);
    }
    if ("get" !== A.method.toLowerCase() && e3.request?.body && e3.request?.body.content["application/json"] && e3.request?.body.content["application/json"].schema) {
      r2.body = e3.request.body.content["application/json"].schema;
      try {
        t2.body = await A.json();
      } catch (A2) {
        t2.body = {};
      }
    }
    let o2 = z.object(r2);
    void 0 !== this.params?.raiseUnknownParameters && true !== this.params?.raiseUnknownParameters || (o2 = o2.strict());
    const a2 = o2.safeParse(t2);
    return { data: a2.success ? a2.data : void 0, errors: a2.success ? void 0 : a2.error.issues };
  }
};
__publicField(K, "isRoute", true);
__publicField(K, "schema");

// src/endpoints/zendeskEvents.ts
init_modules_watch_stub();

// lib/drizzle.ts
init_modules_watch_stub();

// ../node_modules/drizzle-orm/neon-http/driver.js
init_modules_watch_stub();

// ../node_modules/@neondatabase/serverless/index.mjs
init_modules_watch_stub();
var Xs = Object.create;
var Ie = Object.defineProperty;
var eo = Object.getOwnPropertyDescriptor;
var to = Object.getOwnPropertyNames;
var ro = Object.getPrototypeOf;
var no = Object.prototype.hasOwnProperty;
var io = (r2, e3, t2) => e3 in r2 ? Ie(r2, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e3] = t2;
var a = (r2, e3) => Ie(r2, "name", { value: e3, configurable: true });
var K2 = (r2, e3) => () => (r2 && (e3 = r2(r2 = 0)), e3);
var I = (r2, e3) => () => (e3 || r2((e3 = { exports: {} }).exports, e3), e3.exports);
var X2 = (r2, e3) => {
  for (var t2 in e3)
    Ie(r2, t2, { get: e3[t2], enumerable: true });
};
var _n = (r2, e3, t2, n2) => {
  if (e3 && typeof e3 == "object" || typeof e3 == "function")
    for (let i2 of to(e3))
      !no.call(r2, i2) && i2 !== t2 && Ie(r2, i2, { get: () => e3[i2], enumerable: !(n2 = eo(e3, i2)) || n2.enumerable });
  return r2;
};
var We = (r2, e3, t2) => (t2 = r2 != null ? Xs(ro(r2)) : {}, _n(e3 || !r2 || !r2.__esModule ? Ie(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var k = (r2) => _n(Ie({}, "__esModule", { value: true }), r2);
var T = (r2, e3, t2) => (io(r2, typeof e3 != "symbol" ? e3 + "" : e3, t2), t2);
var In = I((it) => {
  "use strict";
  p3();
  it.byteLength = oo;
  it.toByteArray = uo;
  it.fromByteArray = lo;
  var oe = [], ee = [], so = typeof Uint8Array < "u" ? Uint8Array : Array, It = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Ee = 0, An = It.length; Ee < An; ++Ee)
    oe[Ee] = It[Ee], ee[It.charCodeAt(Ee)] = Ee;
  var Ee, An;
  ee[45] = 62;
  ee[95] = 63;
  function Cn(r2) {
    var e3 = r2.length;
    if (e3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t2 = r2.indexOf("=");
    t2 === -1 && (t2 = e3);
    var n2 = t2 === e3 ? 0 : 4 - t2 % 4;
    return [t2, n2];
  }
  a(
    Cn,
    "getLens"
  );
  function oo(r2) {
    var e3 = Cn(r2), t2 = e3[0], n2 = e3[1];
    return (t2 + n2) * 3 / 4 - n2;
  }
  a(oo, "byteLength");
  function ao(r2, e3, t2) {
    return (e3 + t2) * 3 / 4 - t2;
  }
  a(ao, "_byteLength");
  function uo(r2) {
    var e3, t2 = Cn(r2), n2 = t2[0], i2 = t2[1], s2 = new so(ao(r2, n2, i2)), o2 = 0, u2 = i2 > 0 ? n2 - 4 : n2, c3;
    for (c3 = 0; c3 < u2; c3 += 4)
      e3 = ee[r2.charCodeAt(c3)] << 18 | ee[r2.charCodeAt(c3 + 1)] << 12 | ee[r2.charCodeAt(c3 + 2)] << 6 | ee[r2.charCodeAt(c3 + 3)], s2[o2++] = e3 >> 16 & 255, s2[o2++] = e3 >> 8 & 255, s2[o2++] = e3 & 255;
    return i2 === 2 && (e3 = ee[r2.charCodeAt(c3)] << 2 | ee[r2.charCodeAt(c3 + 1)] >> 4, s2[o2++] = e3 & 255), i2 === 1 && (e3 = ee[r2.charCodeAt(
      c3
    )] << 10 | ee[r2.charCodeAt(c3 + 1)] << 4 | ee[r2.charCodeAt(c3 + 2)] >> 2, s2[o2++] = e3 >> 8 & 255, s2[o2++] = e3 & 255), s2;
  }
  a(uo, "toByteArray");
  function co(r2) {
    return oe[r2 >> 18 & 63] + oe[r2 >> 12 & 63] + oe[r2 >> 6 & 63] + oe[r2 & 63];
  }
  a(co, "tripletToBase64");
  function ho(r2, e3, t2) {
    for (var n2, i2 = [], s2 = e3; s2 < t2; s2 += 3)
      n2 = (r2[s2] << 16 & 16711680) + (r2[s2 + 1] << 8 & 65280) + (r2[s2 + 2] & 255), i2.push(co(n2));
    return i2.join(
      ""
    );
  }
  a(ho, "encodeChunk");
  function lo(r2) {
    for (var e3, t2 = r2.length, n2 = t2 % 3, i2 = [], s2 = 16383, o2 = 0, u2 = t2 - n2; o2 < u2; o2 += s2)
      i2.push(ho(r2, o2, o2 + s2 > u2 ? u2 : o2 + s2));
    return n2 === 1 ? (e3 = r2[t2 - 1], i2.push(oe[e3 >> 2] + oe[e3 << 4 & 63] + "==")) : n2 === 2 && (e3 = (r2[t2 - 2] << 8) + r2[t2 - 1], i2.push(oe[e3 >> 10] + oe[e3 >> 4 & 63] + oe[e3 << 2 & 63] + "=")), i2.join("");
  }
  a(lo, "fromByteArray");
});
var Tn = I((Tt) => {
  p3();
  Tt.read = function(r2, e3, t2, n2, i2) {
    var s2, o2, u2 = i2 * 8 - n2 - 1, c3 = (1 << u2) - 1, h2 = c3 >> 1, l3 = -7, y2 = t2 ? i2 - 1 : 0, E = t2 ? -1 : 1, _ = r2[e3 + y2];
    for (y2 += E, s2 = _ & (1 << -l3) - 1, _ >>= -l3, l3 += u2; l3 > 0; s2 = s2 * 256 + r2[e3 + y2], y2 += E, l3 -= 8)
      ;
    for (o2 = s2 & (1 << -l3) - 1, s2 >>= -l3, l3 += n2; l3 > 0; o2 = o2 * 256 + r2[e3 + y2], y2 += E, l3 -= 8)
      ;
    if (s2 === 0)
      s2 = 1 - h2;
    else {
      if (s2 === c3)
        return o2 ? NaN : (_ ? -1 : 1) * (1 / 0);
      o2 = o2 + Math.pow(2, n2), s2 = s2 - h2;
    }
    return (_ ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
  };
  Tt.write = function(r2, e3, t2, n2, i2, s2) {
    var o2, u2, c3, h2 = s2 * 8 - i2 - 1, l3 = (1 << h2) - 1, y2 = l3 >> 1, E = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, _ = n2 ? 0 : s2 - 1, P2 = n2 ? 1 : -1, N = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
    for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (u2 = isNaN(e3) ? 1 : 0, o2 = l3) : (o2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (c3 = Math.pow(2, -o2)) < 1 && (o2--, c3 *= 2), o2 + y2 >= 1 ? e3 += E / c3 : e3 += E * Math.pow(2, 1 - y2), e3 * c3 >= 2 && (o2++, c3 /= 2), o2 + y2 >= l3 ? (u2 = 0, o2 = l3) : o2 + y2 >= 1 ? (u2 = (e3 * c3 - 1) * Math.pow(
      2,
      i2
    ), o2 = o2 + y2) : (u2 = e3 * Math.pow(2, y2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; r2[t2 + _] = u2 & 255, _ += P2, u2 /= 256, i2 -= 8)
      ;
    for (o2 = o2 << i2 | u2, h2 += i2; h2 > 0; r2[t2 + _] = o2 & 255, _ += P2, o2 /= 256, h2 -= 8)
      ;
    r2[t2 + _ - P2] |= N * 128;
  };
});
var Gn = I((Le) => {
  "use strict";
  p3();
  var Pt = In(), Pe = Tn(), Pn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Le.Buffer = f3;
  Le.SlowBuffer = wo;
  Le.INSPECT_MAX_BYTES = 50;
  var st = 2147483647;
  Le.kMaxLength = st;
  f3.TYPED_ARRAY_SUPPORT = fo();
  !f3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function fo() {
    try {
      let r2 = new Uint8Array(1), e3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(r2, e3), r2.foo() === 42;
    } catch {
      return false;
    }
  }
  a(fo, "typedArraySupport");
  Object.defineProperty(
    f3.prototype,
    "parent",
    { enumerable: true, get: function() {
      if (f3.isBuffer(this))
        return this.buffer;
    } }
  );
  Object.defineProperty(f3.prototype, "offset", { enumerable: true, get: function() {
    if (f3.isBuffer(
      this
    ))
      return this.byteOffset;
  } });
  function le(r2) {
    if (r2 > st)
      throw new RangeError('The value "' + r2 + '" is invalid for option "size"');
    let e3 = new Uint8Array(r2);
    return Object.setPrototypeOf(e3, f3.prototype), e3;
  }
  a(le, "createBuffer");
  function f3(r2, e3, t2) {
    if (typeof r2 == "number") {
      if (typeof e3 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Ft(r2);
    }
    return Fn(r2, e3, t2);
  }
  a(f3, "Buffer");
  f3.poolSize = 8192;
  function Fn(r2, e3, t2) {
    if (typeof r2 == "string")
      return yo(r2, e3);
    if (ArrayBuffer.isView(r2))
      return mo(r2);
    if (r2 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r2);
    if (ae(r2, ArrayBuffer) || r2 && ae(r2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ae(r2, SharedArrayBuffer) || r2 && ae(r2.buffer, SharedArrayBuffer)))
      return Lt(
        r2,
        e3,
        t2
      );
    if (typeof r2 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n2 = r2.valueOf && r2.valueOf();
    if (n2 != null && n2 !== r2)
      return f3.from(n2, e3, t2);
    let i2 = go(r2);
    if (i2)
      return i2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r2[Symbol.toPrimitive] == "function")
      return f3.from(r2[Symbol.toPrimitive](
        "string"
      ), e3, t2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r2);
  }
  a(
    Fn,
    "from"
  );
  f3.from = function(r2, e3, t2) {
    return Fn(r2, e3, t2);
  };
  Object.setPrototypeOf(
    f3.prototype,
    Uint8Array.prototype
  );
  Object.setPrototypeOf(f3, Uint8Array);
  function Mn(r2) {
    if (typeof r2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (r2 < 0)
      throw new RangeError(
        'The value "' + r2 + '" is invalid for option "size"'
      );
  }
  a(Mn, "assertSize");
  function po(r2, e3, t2) {
    return Mn(r2), r2 <= 0 ? le(r2) : e3 !== void 0 ? typeof t2 == "string" ? le(r2).fill(e3, t2) : le(r2).fill(
      e3
    ) : le(r2);
  }
  a(po, "alloc");
  f3.alloc = function(r2, e3, t2) {
    return po(r2, e3, t2);
  };
  function Ft(r2) {
    return Mn(r2), le(r2 < 0 ? 0 : Mt(r2) | 0);
  }
  a(Ft, "allocUnsafe");
  f3.allocUnsafe = function(r2) {
    return Ft(
      r2
    );
  };
  f3.allocUnsafeSlow = function(r2) {
    return Ft(r2);
  };
  function yo(r2, e3) {
    if ((typeof e3 != "string" || e3 === "") && (e3 = "utf8"), !f3.isEncoding(e3))
      throw new TypeError("Unknown encoding: " + e3);
    let t2 = Dn(r2, e3) | 0, n2 = le(t2), i2 = n2.write(r2, e3);
    return i2 !== t2 && (n2 = n2.slice(0, i2)), n2;
  }
  a(yo, "fromString");
  function Bt(r2) {
    let e3 = r2.length < 0 ? 0 : Mt(r2.length) | 0, t2 = le(e3);
    for (let n2 = 0; n2 < e3; n2 += 1)
      t2[n2] = r2[n2] & 255;
    return t2;
  }
  a(Bt, "fromArrayLike");
  function mo(r2) {
    if (ae(r2, Uint8Array)) {
      let e3 = new Uint8Array(r2);
      return Lt(e3.buffer, e3.byteOffset, e3.byteLength);
    }
    return Bt(
      r2
    );
  }
  a(mo, "fromArrayView");
  function Lt(r2, e3, t2) {
    if (e3 < 0 || r2.byteLength < e3)
      throw new RangeError(
        '"offset" is outside of buffer bounds'
      );
    if (r2.byteLength < e3 + (t2 || 0))
      throw new RangeError(
        '"length" is outside of buffer bounds'
      );
    let n2;
    return e3 === void 0 && t2 === void 0 ? n2 = new Uint8Array(
      r2
    ) : t2 === void 0 ? n2 = new Uint8Array(r2, e3) : n2 = new Uint8Array(r2, e3, t2), Object.setPrototypeOf(
      n2,
      f3.prototype
    ), n2;
  }
  a(Lt, "fromArrayBuffer");
  function go(r2) {
    if (f3.isBuffer(r2)) {
      let e3 = Mt(
        r2.length
      ) | 0, t2 = le(e3);
      return t2.length === 0 || r2.copy(t2, 0, 0, e3), t2;
    }
    if (r2.length !== void 0)
      return typeof r2.length != "number" || Ot(r2.length) ? le(0) : Bt(r2);
    if (r2.type === "Buffer" && Array.isArray(r2.data))
      return Bt(r2.data);
  }
  a(go, "fromObject");
  function Mt(r2) {
    if (r2 >= st)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + st.toString(16) + " bytes");
    return r2 | 0;
  }
  a(Mt, "checked");
  function wo(r2) {
    return +r2 != r2 && (r2 = 0), f3.alloc(+r2);
  }
  a(wo, "SlowBuffer");
  f3.isBuffer = a(function(e3) {
    return e3 != null && e3._isBuffer === true && e3 !== f3.prototype;
  }, "isBuffer");
  f3.compare = a(function(e3, t2) {
    if (ae(e3, Uint8Array) && (e3 = f3.from(e3, e3.offset, e3.byteLength)), ae(t2, Uint8Array) && (t2 = f3.from(t2, t2.offset, t2.byteLength)), !f3.isBuffer(e3) || !f3.isBuffer(t2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t2)
      return 0;
    let n2 = e3.length, i2 = t2.length;
    for (let s2 = 0, o2 = Math.min(n2, i2); s2 < o2; ++s2)
      if (e3[s2] !== t2[s2]) {
        n2 = e3[s2], i2 = t2[s2];
        break;
      }
    return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
  }, "compare");
  f3.isEncoding = a(function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  f3.concat = a(function(e3, t2) {
    if (!Array.isArray(e3))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e3.length === 0)
      return f3.alloc(0);
    let n2;
    if (t2 === void 0)
      for (t2 = 0, n2 = 0; n2 < e3.length; ++n2)
        t2 += e3[n2].length;
    let i2 = f3.allocUnsafe(t2), s2 = 0;
    for (n2 = 0; n2 < e3.length; ++n2) {
      let o2 = e3[n2];
      if (ae(o2, Uint8Array))
        s2 + o2.length > i2.length ? (f3.isBuffer(
          o2
        ) || (o2 = f3.from(o2)), o2.copy(i2, s2)) : Uint8Array.prototype.set.call(i2, o2, s2);
      else if (f3.isBuffer(
        o2
      ))
        o2.copy(i2, s2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      s2 += o2.length;
    }
    return i2;
  }, "concat");
  function Dn(r2, e3) {
    if (f3.isBuffer(r2))
      return r2.length;
    if (ArrayBuffer.isView(r2) || ae(r2, ArrayBuffer))
      return r2.byteLength;
    if (typeof r2 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r2);
    let t2 = r2.length, n2 = arguments.length > 2 && arguments[2] === true;
    if (!n2 && t2 === 0)
      return 0;
    let i2 = false;
    for (; ; )
      switch (e3) {
        case "ascii":
        case "latin1":
        case "binary":
          return t2;
        case "utf8":
        case "utf-8":
          return Rt(r2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t2 * 2;
        case "hex":
          return t2 >>> 1;
        case "base64":
          return Hn(r2).length;
        default:
          if (i2)
            return n2 ? -1 : Rt(r2).length;
          e3 = ("" + e3).toLowerCase(), i2 = true;
      }
  }
  a(Dn, "byteLength");
  f3.byteLength = Dn;
  function bo(r2, e3, t2) {
    let n2 = false;
    if ((e3 === void 0 || e3 < 0) && (e3 = 0), e3 > this.length || ((t2 === void 0 || t2 > this.length) && (t2 = this.length), t2 <= 0) || (t2 >>>= 0, e3 >>>= 0, t2 <= e3))
      return "";
    for (r2 || (r2 = "utf8"); ; )
      switch (r2) {
        case "hex":
          return Po(
            this,
            e3,
            t2
          );
        case "utf8":
        case "utf-8":
          return kn(this, e3, t2);
        case "ascii":
          return Io(
            this,
            e3,
            t2
          );
        case "latin1":
        case "binary":
          return To(this, e3, t2);
        case "base64":
          return Ao(
            this,
            e3,
            t2
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Bo(this, e3, t2);
        default:
          if (n2)
            throw new TypeError("Unknown encoding: " + r2);
          r2 = (r2 + "").toLowerCase(), n2 = true;
      }
  }
  a(
    bo,
    "slowToString"
  );
  f3.prototype._isBuffer = true;
  function ve(r2, e3, t2) {
    let n2 = r2[e3];
    r2[e3] = r2[t2], r2[t2] = n2;
  }
  a(ve, "swap");
  f3.prototype.swap16 = a(function() {
    let e3 = this.length;
    if (e3 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t2 = 0; t2 < e3; t2 += 2)
      ve(this, t2, t2 + 1);
    return this;
  }, "swap16");
  f3.prototype.swap32 = a(function() {
    let e3 = this.length;
    if (e3 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t2 = 0; t2 < e3; t2 += 4)
      ve(this, t2, t2 + 3), ve(this, t2 + 1, t2 + 2);
    return this;
  }, "swap32");
  f3.prototype.swap64 = a(function() {
    let e3 = this.length;
    if (e3 % 8 !== 0)
      throw new RangeError(
        "Buffer size must be a multiple of 64-bits"
      );
    for (let t2 = 0; t2 < e3; t2 += 8)
      ve(this, t2, t2 + 7), ve(this, t2 + 1, t2 + 6), ve(this, t2 + 2, t2 + 5), ve(this, t2 + 3, t2 + 4);
    return this;
  }, "swap64");
  f3.prototype.toString = a(function() {
    let e3 = this.length;
    return e3 === 0 ? "" : arguments.length === 0 ? kn(
      this,
      0,
      e3
    ) : bo.apply(this, arguments);
  }, "toString");
  f3.prototype.toLocaleString = f3.prototype.toString;
  f3.prototype.equals = a(function(e3) {
    if (!f3.isBuffer(e3))
      throw new TypeError(
        "Argument must be a Buffer"
      );
    return this === e3 ? true : f3.compare(this, e3) === 0;
  }, "equals");
  f3.prototype.inspect = a(function() {
    let e3 = "", t2 = Le.INSPECT_MAX_BYTES;
    return e3 = this.toString(
      "hex",
      0,
      t2
    ).replace(/(.{2})/g, "$1 ").trim(), this.length > t2 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, "inspect");
  Pn && (f3.prototype[Pn] = f3.prototype.inspect);
  f3.prototype.compare = a(function(e3, t2, n2, i2, s2) {
    if (ae(e3, Uint8Array) && (e3 = f3.from(e3, e3.offset, e3.byteLength)), !f3.isBuffer(e3))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e3 ? e3.length : 0), i2 === void 0 && (i2 = 0), s2 === void 0 && (s2 = this.length), t2 < 0 || n2 > e3.length || i2 < 0 || s2 > this.length)
      throw new RangeError("out of range index");
    if (i2 >= s2 && t2 >= n2)
      return 0;
    if (i2 >= s2)
      return -1;
    if (t2 >= n2)
      return 1;
    if (t2 >>>= 0, n2 >>>= 0, i2 >>>= 0, s2 >>>= 0, this === e3)
      return 0;
    let o2 = s2 - i2, u2 = n2 - t2, c3 = Math.min(o2, u2), h2 = this.slice(i2, s2), l3 = e3.slice(t2, n2);
    for (let y2 = 0; y2 < c3; ++y2)
      if (h2[y2] !== l3[y2]) {
        o2 = h2[y2], u2 = l3[y2];
        break;
      }
    return o2 < u2 ? -1 : u2 < o2 ? 1 : 0;
  }, "compare");
  function On(r2, e3, t2, n2, i2) {
    if (r2.length === 0)
      return -1;
    if (typeof t2 == "string" ? (n2 = t2, t2 = 0) : t2 > 2147483647 ? t2 = 2147483647 : t2 < -2147483648 && (t2 = -2147483648), t2 = +t2, Ot(t2) && (t2 = i2 ? 0 : r2.length - 1), t2 < 0 && (t2 = r2.length + t2), t2 >= r2.length) {
      if (i2)
        return -1;
      t2 = r2.length - 1;
    } else if (t2 < 0)
      if (i2)
        t2 = 0;
      else
        return -1;
    if (typeof e3 == "string" && (e3 = f3.from(e3, n2)), f3.isBuffer(e3))
      return e3.length === 0 ? -1 : Bn(r2, e3, t2, n2, i2);
    if (typeof e3 == "number")
      return e3 = e3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(r2, e3, t2) : Uint8Array.prototype.lastIndexOf.call(r2, e3, t2) : Bn(
        r2,
        [e3],
        t2,
        n2,
        i2
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  a(On, "bidirectionalIndexOf");
  function Bn(r2, e3, t2, n2, i2) {
    let s2 = 1, o2 = r2.length, u2 = e3.length;
    if (n2 !== void 0 && (n2 = String(n2).toLowerCase(), n2 === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
      if (r2.length < 2 || e3.length < 2)
        return -1;
      s2 = 2, o2 /= 2, u2 /= 2, t2 /= 2;
    }
    function c3(l3, y2) {
      return s2 === 1 ? l3[y2] : l3.readUInt16BE(y2 * s2);
    }
    a(c3, "read");
    let h2;
    if (i2) {
      let l3 = -1;
      for (h2 = t2; h2 < o2; h2++)
        if (c3(r2, h2) === c3(e3, l3 === -1 ? 0 : h2 - l3)) {
          if (l3 === -1 && (l3 = h2), h2 - l3 + 1 === u2)
            return l3 * s2;
        } else
          l3 !== -1 && (h2 -= h2 - l3), l3 = -1;
    } else
      for (t2 + u2 > o2 && (t2 = o2 - u2), h2 = t2; h2 >= 0; h2--) {
        let l3 = true;
        for (let y2 = 0; y2 < u2; y2++)
          if (c3(r2, h2 + y2) !== c3(e3, y2)) {
            l3 = false;
            break;
          }
        if (l3)
          return h2;
      }
    return -1;
  }
  a(Bn, "arrayIndexOf");
  f3.prototype.includes = a(function(e3, t2, n2) {
    return this.indexOf(e3, t2, n2) !== -1;
  }, "includes");
  f3.prototype.indexOf = a(function(e3, t2, n2) {
    return On(this, e3, t2, n2, true);
  }, "indexOf");
  f3.prototype.lastIndexOf = a(function(e3, t2, n2) {
    return On(this, e3, t2, n2, false);
  }, "lastIndexOf");
  function So(r2, e3, t2, n2) {
    t2 = Number(t2) || 0;
    let i2 = r2.length - t2;
    n2 ? (n2 = Number(n2), n2 > i2 && (n2 = i2)) : n2 = i2;
    let s2 = e3.length;
    n2 > s2 / 2 && (n2 = s2 / 2);
    let o2;
    for (o2 = 0; o2 < n2; ++o2) {
      let u2 = parseInt(e3.substr(o2 * 2, 2), 16);
      if (Ot(u2))
        return o2;
      r2[t2 + o2] = u2;
    }
    return o2;
  }
  a(So, "hexWrite");
  function xo(r2, e3, t2, n2) {
    return ot(Rt(
      e3,
      r2.length - t2
    ), r2, t2, n2);
  }
  a(xo, "utf8Write");
  function Eo(r2, e3, t2, n2) {
    return ot(Mo(e3), r2, t2, n2);
  }
  a(Eo, "asciiWrite");
  function vo(r2, e3, t2, n2) {
    return ot(Hn(e3), r2, t2, n2);
  }
  a(vo, "base64Write");
  function _o(r2, e3, t2, n2) {
    return ot(Do(e3, r2.length - t2), r2, t2, n2);
  }
  a(_o, "ucs2Write");
  f3.prototype.write = a(function(e3, t2, n2, i2) {
    if (t2 === void 0)
      i2 = "utf8", n2 = this.length, t2 = 0;
    else if (n2 === void 0 && typeof t2 == "string")
      i2 = t2, n2 = this.length, t2 = 0;
    else if (isFinite(t2))
      t2 = t2 >>> 0, isFinite(n2) ? (n2 = n2 >>> 0, i2 === void 0 && (i2 = "utf8")) : (i2 = n2, n2 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s2 = this.length - t2;
    if ((n2 === void 0 || n2 > s2) && (n2 = s2), e3.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError(
        "Attempt to write outside buffer bounds"
      );
    i2 || (i2 = "utf8");
    let o2 = false;
    for (; ; )
      switch (i2) {
        case "hex":
          return So(this, e3, t2, n2);
        case "utf8":
        case "utf-8":
          return xo(this, e3, t2, n2);
        case "ascii":
        case "latin1":
        case "binary":
          return Eo(this, e3, t2, n2);
        case "base64":
          return vo(
            this,
            e3,
            t2,
            n2
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _o(this, e3, t2, n2);
        default:
          if (o2)
            throw new TypeError("Unknown encoding: " + i2);
          i2 = ("" + i2).toLowerCase(), o2 = true;
      }
  }, "write");
  f3.prototype.toJSON = a(function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  }, "toJSON");
  function Ao(r2, e3, t2) {
    return e3 === 0 && t2 === r2.length ? Pt.fromByteArray(r2) : Pt.fromByteArray(r2.slice(e3, t2));
  }
  a(Ao, "base64Slice");
  function kn(r2, e3, t2) {
    t2 = Math.min(r2.length, t2);
    let n2 = [], i2 = e3;
    for (; i2 < t2; ) {
      let s2 = r2[i2], o2 = null, u2 = s2 > 239 ? 4 : s2 > 223 ? 3 : s2 > 191 ? 2 : 1;
      if (i2 + u2 <= t2) {
        let c3, h2, l3, y2;
        switch (u2) {
          case 1:
            s2 < 128 && (o2 = s2);
            break;
          case 2:
            c3 = r2[i2 + 1], (c3 & 192) === 128 && (y2 = (s2 & 31) << 6 | c3 & 63, y2 > 127 && (o2 = y2));
            break;
          case 3:
            c3 = r2[i2 + 1], h2 = r2[i2 + 2], (c3 & 192) === 128 && (h2 & 192) === 128 && (y2 = (s2 & 15) << 12 | (c3 & 63) << 6 | h2 & 63, y2 > 2047 && (y2 < 55296 || y2 > 57343) && (o2 = y2));
            break;
          case 4:
            c3 = r2[i2 + 1], h2 = r2[i2 + 2], l3 = r2[i2 + 3], (c3 & 192) === 128 && (h2 & 192) === 128 && (l3 & 192) === 128 && (y2 = (s2 & 15) << 18 | (c3 & 63) << 12 | (h2 & 63) << 6 | l3 & 63, y2 > 65535 && y2 < 1114112 && (o2 = y2));
        }
      }
      o2 === null ? (o2 = 65533, u2 = 1) : o2 > 65535 && (o2 -= 65536, n2.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | o2 & 1023), n2.push(o2), i2 += u2;
    }
    return Co(n2);
  }
  a(kn, "utf8Slice");
  var Ln = 4096;
  function Co(r2) {
    let e3 = r2.length;
    if (e3 <= Ln)
      return String.fromCharCode.apply(String, r2);
    let t2 = "", n2 = 0;
    for (; n2 < e3; )
      t2 += String.fromCharCode.apply(String, r2.slice(n2, n2 += Ln));
    return t2;
  }
  a(Co, "decodeCodePointsArray");
  function Io(r2, e3, t2) {
    let n2 = "";
    t2 = Math.min(r2.length, t2);
    for (let i2 = e3; i2 < t2; ++i2)
      n2 += String.fromCharCode(r2[i2] & 127);
    return n2;
  }
  a(Io, "asciiSlice");
  function To(r2, e3, t2) {
    let n2 = "";
    t2 = Math.min(r2.length, t2);
    for (let i2 = e3; i2 < t2; ++i2)
      n2 += String.fromCharCode(r2[i2]);
    return n2;
  }
  a(To, "latin1Slice");
  function Po(r2, e3, t2) {
    let n2 = r2.length;
    (!e3 || e3 < 0) && (e3 = 0), (!t2 || t2 < 0 || t2 > n2) && (t2 = n2);
    let i2 = "";
    for (let s2 = e3; s2 < t2; ++s2)
      i2 += Oo[r2[s2]];
    return i2;
  }
  a(Po, "hexSlice");
  function Bo(r2, e3, t2) {
    let n2 = r2.slice(e3, t2), i2 = "";
    for (let s2 = 0; s2 < n2.length - 1; s2 += 2)
      i2 += String.fromCharCode(n2[s2] + n2[s2 + 1] * 256);
    return i2;
  }
  a(Bo, "utf16leSlice");
  f3.prototype.slice = a(function(e3, t2) {
    let n2 = this.length;
    e3 = ~~e3, t2 = t2 === void 0 ? n2 : ~~t2, e3 < 0 ? (e3 += n2, e3 < 0 && (e3 = 0)) : e3 > n2 && (e3 = n2), t2 < 0 ? (t2 += n2, t2 < 0 && (t2 = 0)) : t2 > n2 && (t2 = n2), t2 < e3 && (t2 = e3);
    let i2 = this.subarray(
      e3,
      t2
    );
    return Object.setPrototypeOf(i2, f3.prototype), i2;
  }, "slice");
  function U(r2, e3, t2) {
    if (r2 % 1 !== 0 || r2 < 0)
      throw new RangeError("offset is not uint");
    if (r2 + e3 > t2)
      throw new RangeError(
        "Trying to access beyond buffer length"
      );
  }
  a(U, "checkOffset");
  f3.prototype.readUintLE = f3.prototype.readUIntLE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3], s2 = 1, o2 = 0;
    for (; ++o2 < t2 && (s2 *= 256); )
      i2 += this[e3 + o2] * s2;
    return i2;
  }, "readUIntLE");
  f3.prototype.readUintBE = f3.prototype.readUIntBE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3 + --t2], s2 = 1;
    for (; t2 > 0 && (s2 *= 256); )
      i2 += this[e3 + --t2] * s2;
    return i2;
  }, "readUIntBE");
  f3.prototype.readUint8 = f3.prototype.readUInt8 = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 1, this.length), this[e3];
  }, "readUInt8");
  f3.prototype.readUint16LE = f3.prototype.readUInt16LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, "readUInt16LE");
  f3.prototype.readUint16BE = f3.prototype.readUInt16BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, "readUInt16BE");
  f3.prototype.readUint32LE = f3.prototype.readUInt32LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + this[e3 + 3] * 16777216;
  }, "readUInt32LE");
  f3.prototype.readUint32BE = f3.prototype.readUInt32BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] * 16777216 + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, "readUInt32BE");
  f3.prototype.readBigUInt64LE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = t2 + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 24, s2 = this[++e3] + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + n2 * 2 ** 24;
    return BigInt(i2) + (BigInt(s2) << BigInt(32));
  }, "readBigUInt64LE"));
  f3.prototype.readBigUInt64BE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = t2 * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + this[++e3], s2 = this[++e3] * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + n2;
    return (BigInt(
      i2
    ) << BigInt(32)) + BigInt(s2);
  }, "readBigUInt64BE"));
  f3.prototype.readIntLE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3], s2 = 1, o2 = 0;
    for (; ++o2 < t2 && (s2 *= 256); )
      i2 += this[e3 + o2] * s2;
    return s2 *= 128, i2 >= s2 && (i2 -= Math.pow(2, 8 * t2)), i2;
  }, "readIntLE");
  f3.prototype.readIntBE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = t2, s2 = 1, o2 = this[e3 + --i2];
    for (; i2 > 0 && (s2 *= 256); )
      o2 += this[e3 + --i2] * s2;
    return s2 *= 128, o2 >= s2 && (o2 -= Math.pow(2, 8 * t2)), o2;
  }, "readIntBE");
  f3.prototype.readInt8 = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 1, this.length), this[e3] & 128 ? (255 - this[e3] + 1) * -1 : this[e3];
  }, "readInt8");
  f3.prototype.readInt16LE = a(function(e3, t2) {
    e3 = e3 >>> 0, t2 || U(e3, 2, this.length);
    let n2 = this[e3] | this[e3 + 1] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  }, "readInt16LE");
  f3.prototype.readInt16BE = a(
    function(e3, t2) {
      e3 = e3 >>> 0, t2 || U(e3, 2, this.length);
      let n2 = this[e3 + 1] | this[e3] << 8;
      return n2 & 32768 ? n2 | 4294901760 : n2;
    },
    "readInt16BE"
  );
  f3.prototype.readInt32LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, "readInt32LE");
  f3.prototype.readInt32BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, "readInt32BE");
  f3.prototype.readBigInt64LE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(
      e3,
      this.length - 8
    );
    let i2 = this[e3 + 4] + this[e3 + 5] * 2 ** 8 + this[e3 + 6] * 2 ** 16 + (n2 << 24);
    return (BigInt(
      i2
    ) << BigInt(32)) + BigInt(t2 + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 24);
  }, "readBigInt64LE"));
  f3.prototype.readBigInt64BE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = (t2 << 24) + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + this[++e3];
    return (BigInt(i2) << BigInt(32)) + BigInt(
      this[++e3] * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + n2
    );
  }, "readBigInt64BE"));
  f3.prototype.readFloatLE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), Pe.read(
      this,
      e3,
      true,
      23,
      4
    );
  }, "readFloatLE");
  f3.prototype.readFloatBE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), Pe.read(this, e3, false, 23, 4);
  }, "readFloatBE");
  f3.prototype.readDoubleLE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 8, this.length), Pe.read(this, e3, true, 52, 8);
  }, "readDoubleLE");
  f3.prototype.readDoubleBE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 8, this.length), Pe.read(this, e3, false, 52, 8);
  }, "readDoubleBE");
  function z2(r2, e3, t2, n2, i2, s2) {
    if (!f3.isBuffer(
      r2
    ))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e3 > i2 || e3 < s2)
      throw new RangeError('"value" argument is out of bounds');
    if (t2 + n2 > r2.length)
      throw new RangeError(
        "Index out of range"
      );
  }
  a(z2, "checkInt");
  f3.prototype.writeUintLE = f3.prototype.writeUIntLE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      z2(
        this,
        e3,
        t2,
        n2,
        u2,
        0
      );
    }
    let s2 = 1, o2 = 0;
    for (this[t2] = e3 & 255; ++o2 < n2 && (s2 *= 256); )
      this[t2 + o2] = e3 / s2 & 255;
    return t2 + n2;
  }, "writeUIntLE");
  f3.prototype.writeUintBE = f3.prototype.writeUIntBE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      z2(this, e3, t2, n2, u2, 0);
    }
    let s2 = n2 - 1, o2 = 1;
    for (this[t2 + s2] = e3 & 255; --s2 >= 0 && (o2 *= 256); )
      this[t2 + s2] = e3 / o2 & 255;
    return t2 + n2;
  }, "writeUIntBE");
  f3.prototype.writeUint8 = f3.prototype.writeUInt8 = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 1, 255, 0), this[t2] = e3 & 255, t2 + 1;
  }, "writeUInt8");
  f3.prototype.writeUint16LE = f3.prototype.writeUInt16LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      2,
      65535,
      0
    ), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, t2 + 2;
  }, "writeUInt16LE");
  f3.prototype.writeUint16BE = f3.prototype.writeUInt16BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      2,
      65535,
      0
    ), this[t2] = e3 >>> 8, this[t2 + 1] = e3 & 255, t2 + 2;
  }, "writeUInt16BE");
  f3.prototype.writeUint32LE = f3.prototype.writeUInt32LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      4,
      4294967295,
      0
    ), this[t2 + 3] = e3 >>> 24, this[t2 + 2] = e3 >>> 16, this[t2 + 1] = e3 >>> 8, this[t2] = e3 & 255, t2 + 4;
  }, "writeUInt32LE");
  f3.prototype.writeUint32BE = f3.prototype.writeUInt32BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 4294967295, 0), this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = e3 & 255, t2 + 4;
  }, "writeUInt32BE");
  function Un(r2, e3, t2, n2, i2) {
    jn(
      e3,
      n2,
      i2,
      r2,
      t2,
      7
    );
    let s2 = Number(e3 & BigInt(4294967295));
    r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2;
    let o2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
    return r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, t2;
  }
  a(Un, "wrtBigUInt64LE");
  function qn(r2, e3, t2, n2, i2) {
    jn(e3, n2, i2, r2, t2, 7);
    let s2 = Number(e3 & BigInt(4294967295));
    r2[t2 + 7] = s2, s2 = s2 >> 8, r2[t2 + 6] = s2, s2 = s2 >> 8, r2[t2 + 5] = s2, s2 = s2 >> 8, r2[t2 + 4] = s2;
    let o2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
    return r2[t2 + 3] = o2, o2 = o2 >> 8, r2[t2 + 2] = o2, o2 = o2 >> 8, r2[t2 + 1] = o2, o2 = o2 >> 8, r2[t2] = o2, t2 + 8;
  }
  a(qn, "wrtBigUInt64BE");
  f3.prototype.writeBigUInt64LE = me(a(function(e3, t2 = 0) {
    return Un(this, e3, t2, BigInt(0), BigInt(
      "0xffffffffffffffff"
    ));
  }, "writeBigUInt64LE"));
  f3.prototype.writeBigUInt64BE = me(a(function(e3, t2 = 0) {
    return qn(this, e3, t2, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64BE"));
  f3.prototype.writeIntLE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, !i2) {
      let c3 = Math.pow(
        2,
        8 * n2 - 1
      );
      z2(this, e3, t2, n2, c3 - 1, -c3);
    }
    let s2 = 0, o2 = 1, u2 = 0;
    for (this[t2] = e3 & 255; ++s2 < n2 && (o2 *= 256); )
      e3 < 0 && u2 === 0 && this[t2 + s2 - 1] !== 0 && (u2 = 1), this[t2 + s2] = (e3 / o2 >> 0) - u2 & 255;
    return t2 + n2;
  }, "writeIntLE");
  f3.prototype.writeIntBE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, !i2) {
      let c3 = Math.pow(
        2,
        8 * n2 - 1
      );
      z2(this, e3, t2, n2, c3 - 1, -c3);
    }
    let s2 = n2 - 1, o2 = 1, u2 = 0;
    for (this[t2 + s2] = e3 & 255; --s2 >= 0 && (o2 *= 256); )
      e3 < 0 && u2 === 0 && this[t2 + s2 + 1] !== 0 && (u2 = 1), this[t2 + s2] = (e3 / o2 >> 0) - u2 & 255;
    return t2 + n2;
  }, "writeIntBE");
  f3.prototype.writeInt8 = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      1,
      127,
      -128
    ), e3 < 0 && (e3 = 255 + e3 + 1), this[t2] = e3 & 255, t2 + 1;
  }, "writeInt8");
  f3.prototype.writeInt16LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 2, 32767, -32768), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, t2 + 2;
  }, "writeInt16LE");
  f3.prototype.writeInt16BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 2, 32767, -32768), this[t2] = e3 >>> 8, this[t2 + 1] = e3 & 255, t2 + 2;
  }, "writeInt16BE");
  f3.prototype.writeInt32LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 2147483647, -2147483648), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, this[t2 + 2] = e3 >>> 16, this[t2 + 3] = e3 >>> 24, t2 + 4;
  }, "writeInt32LE");
  f3.prototype.writeInt32BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = e3 & 255, t2 + 4;
  }, "writeInt32BE");
  f3.prototype.writeBigInt64LE = me(a(function(e3, t2 = 0) {
    return Un(this, e3, t2, -BigInt(
      "0x8000000000000000"
    ), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  f3.prototype.writeBigInt64BE = me(a(function(e3, t2 = 0) {
    return qn(this, e3, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64BE"));
  function Nn(r2, e3, t2, n2, i2, s2) {
    if (t2 + n2 > r2.length)
      throw new RangeError("Index out of range");
    if (t2 < 0)
      throw new RangeError(
        "Index out of range"
      );
  }
  a(Nn, "checkIEEE754");
  function Qn(r2, e3, t2, n2, i2) {
    return e3 = +e3, t2 = t2 >>> 0, i2 || Nn(r2, e3, t2, 4, 34028234663852886e22, -34028234663852886e22), Pe.write(
      r2,
      e3,
      t2,
      n2,
      23,
      4
    ), t2 + 4;
  }
  a(Qn, "writeFloat");
  f3.prototype.writeFloatLE = a(function(e3, t2, n2) {
    return Qn(
      this,
      e3,
      t2,
      true,
      n2
    );
  }, "writeFloatLE");
  f3.prototype.writeFloatBE = a(function(e3, t2, n2) {
    return Qn(
      this,
      e3,
      t2,
      false,
      n2
    );
  }, "writeFloatBE");
  function Wn(r2, e3, t2, n2, i2) {
    return e3 = +e3, t2 = t2 >>> 0, i2 || Nn(
      r2,
      e3,
      t2,
      8,
      17976931348623157e292,
      -17976931348623157e292
    ), Pe.write(r2, e3, t2, n2, 52, 8), t2 + 8;
  }
  a(Wn, "writeDouble");
  f3.prototype.writeDoubleLE = a(function(e3, t2, n2) {
    return Wn(
      this,
      e3,
      t2,
      true,
      n2
    );
  }, "writeDoubleLE");
  f3.prototype.writeDoubleBE = a(function(e3, t2, n2) {
    return Wn(
      this,
      e3,
      t2,
      false,
      n2
    );
  }, "writeDoubleBE");
  f3.prototype.copy = a(function(e3, t2, n2, i2) {
    if (!f3.isBuffer(
      e3
    ))
      throw new TypeError("argument should be a Buffer");
    if (n2 || (n2 = 0), !i2 && i2 !== 0 && (i2 = this.length), t2 >= e3.length && (t2 = e3.length), t2 || (t2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2 || e3.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length)
      throw new RangeError("Index out of range");
    if (i2 < 0)
      throw new RangeError(
        "sourceEnd out of bounds"
      );
    i2 > this.length && (i2 = this.length), e3.length - t2 < i2 - n2 && (i2 = e3.length - t2 + n2);
    let s2 = i2 - n2;
    return this === e3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t2, n2, i2) : Uint8Array.prototype.set.call(e3, this.subarray(n2, i2), t2), s2;
  }, "copy");
  f3.prototype.fill = a(function(e3, t2, n2, i2) {
    if (typeof e3 == "string") {
      if (typeof t2 == "string" ? (i2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (i2 = n2, n2 = this.length), i2 !== void 0 && typeof i2 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i2 == "string" && !f3.isEncoding(i2))
        throw new TypeError("Unknown encoding: " + i2);
      if (e3.length === 1) {
        let o2 = e3.charCodeAt(0);
        (i2 === "utf8" && o2 < 128 || i2 === "latin1") && (e3 = o2);
      }
    } else
      typeof e3 == "number" ? e3 = e3 & 255 : typeof e3 == "boolean" && (e3 = Number(e3));
    if (t2 < 0 || this.length < t2 || this.length < n2)
      throw new RangeError("Out of range index");
    if (n2 <= t2)
      return this;
    t2 = t2 >>> 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e3 || (e3 = 0);
    let s2;
    if (typeof e3 == "number")
      for (s2 = t2; s2 < n2; ++s2)
        this[s2] = e3;
    else {
      let o2 = f3.isBuffer(e3) ? e3 : f3.from(e3, i2), u2 = o2.length;
      if (u2 === 0)
        throw new TypeError(
          'The value "' + e3 + '" is invalid for argument "value"'
        );
      for (s2 = 0; s2 < n2 - t2; ++s2)
        this[s2 + t2] = o2[s2 % u2];
    }
    return this;
  }, "fill");
  var Te = {};
  function Dt(r2, e3, t2) {
    var n2;
    Te[r2] = (n2 = class extends t2 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: e3.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${r2}]`, this.stack, delete this.name;
      }
      get code() {
        return r2;
      }
      set code(s2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: s2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${r2}]: ${this.message}`;
      }
    }, a(n2, "NodeError"), n2);
  }
  a(Dt, "E");
  Dt("ERR_BUFFER_OUT_OF_BOUNDS", function(r2) {
    return r2 ? `${r2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Dt("ERR_INVALID_ARG_TYPE", function(r2, e3) {
    return `The "${r2}" argument must be of type number. Received type ${typeof e3}`;
  }, TypeError);
  Dt("ERR_OUT_OF_RANGE", function(r2, e3, t2) {
    let n2 = `The value of "${r2}" is out of range.`, i2 = t2;
    return Number.isInteger(t2) && Math.abs(t2) > 2 ** 32 ? i2 = Rn(String(t2)) : typeof t2 == "bigint" && (i2 = String(t2), (t2 > BigInt(2) ** BigInt(32) || t2 < -(BigInt(2) ** BigInt(32))) && (i2 = Rn(i2)), i2 += "n"), n2 += ` It must be ${e3}. Received ${i2}`, n2;
  }, RangeError);
  function Rn(r2) {
    let e3 = "", t2 = r2.length, n2 = r2[0] === "-" ? 1 : 0;
    for (; t2 >= n2 + 4; t2 -= 3)
      e3 = `_${r2.slice(t2 - 3, t2)}${e3}`;
    return `${r2.slice(
      0,
      t2
    )}${e3}`;
  }
  a(Rn, "addNumericalSeparator");
  function Lo(r2, e3, t2) {
    Be(e3, "offset"), (r2[e3] === void 0 || r2[e3 + t2] === void 0) && je(e3, r2.length - (t2 + 1));
  }
  a(Lo, "checkBounds");
  function jn(r2, e3, t2, n2, i2, s2) {
    if (r2 > t2 || r2 < e3) {
      let o2 = typeof e3 == "bigint" ? "n" : "", u2;
      throw s2 > 3 ? e3 === 0 || e3 === BigInt(0) ? u2 = `>= 0${o2} and < 2${o2} ** ${(s2 + 1) * 8}${o2}` : u2 = `>= -(2${o2} ** ${(s2 + 1) * 8 - 1}${o2}) and < 2 ** ${(s2 + 1) * 8 - 1}${o2}` : u2 = `>= ${e3}${o2} and <= ${t2}${o2}`, new Te.ERR_OUT_OF_RANGE(
        "value",
        u2,
        r2
      );
    }
    Lo(n2, i2, s2);
  }
  a(jn, "checkIntBI");
  function Be(r2, e3) {
    if (typeof r2 != "number")
      throw new Te.ERR_INVALID_ARG_TYPE(e3, "number", r2);
  }
  a(Be, "validateNumber");
  function je(r2, e3, t2) {
    throw Math.floor(r2) !== r2 ? (Be(r2, t2), new Te.ERR_OUT_OF_RANGE(
      t2 || "offset",
      "an integer",
      r2
    )) : e3 < 0 ? new Te.ERR_BUFFER_OUT_OF_BOUNDS() : new Te.ERR_OUT_OF_RANGE(t2 || "offset", `>= ${t2 ? 1 : 0} and <= ${e3}`, r2);
  }
  a(je, "boundsError");
  var Ro = /[^+/0-9A-Za-z-_]/g;
  function Fo(r2) {
    if (r2 = r2.split("=")[0], r2 = r2.trim().replace(Ro, ""), r2.length < 2)
      return "";
    for (; r2.length % 4 !== 0; )
      r2 = r2 + "=";
    return r2;
  }
  a(Fo, "base64clean");
  function Rt(r2, e3) {
    e3 = e3 || 1 / 0;
    let t2, n2 = r2.length, i2 = null, s2 = [];
    for (let o2 = 0; o2 < n2; ++o2) {
      if (t2 = r2.charCodeAt(o2), t2 > 55295 && t2 < 57344) {
        if (!i2) {
          if (t2 > 56319) {
            (e3 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          } else if (o2 + 1 === n2) {
            (e3 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          }
          i2 = t2;
          continue;
        }
        if (t2 < 56320) {
          (e3 -= 3) > -1 && s2.push(
            239,
            191,
            189
          ), i2 = t2;
          continue;
        }
        t2 = (i2 - 55296 << 10 | t2 - 56320) + 65536;
      } else
        i2 && (e3 -= 3) > -1 && s2.push(
          239,
          191,
          189
        );
      if (i2 = null, t2 < 128) {
        if ((e3 -= 1) < 0)
          break;
        s2.push(t2);
      } else if (t2 < 2048) {
        if ((e3 -= 2) < 0)
          break;
        s2.push(t2 >> 6 | 192, t2 & 63 | 128);
      } else if (t2 < 65536) {
        if ((e3 -= 3) < 0)
          break;
        s2.push(t2 >> 12 | 224, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else if (t2 < 1114112) {
        if ((e3 -= 4) < 0)
          break;
        s2.push(t2 >> 18 | 240, t2 >> 12 & 63 | 128, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return s2;
  }
  a(
    Rt,
    "utf8ToBytes"
  );
  function Mo(r2) {
    let e3 = [];
    for (let t2 = 0; t2 < r2.length; ++t2)
      e3.push(r2.charCodeAt(
        t2
      ) & 255);
    return e3;
  }
  a(Mo, "asciiToBytes");
  function Do(r2, e3) {
    let t2, n2, i2, s2 = [];
    for (let o2 = 0; o2 < r2.length && !((e3 -= 2) < 0); ++o2)
      t2 = r2.charCodeAt(o2), n2 = t2 >> 8, i2 = t2 % 256, s2.push(i2), s2.push(n2);
    return s2;
  }
  a(Do, "utf16leToBytes");
  function Hn(r2) {
    return Pt.toByteArray(Fo(r2));
  }
  a(Hn, "base64ToBytes");
  function ot(r2, e3, t2, n2) {
    let i2;
    for (i2 = 0; i2 < n2 && !(i2 + t2 >= e3.length || i2 >= r2.length); ++i2)
      e3[i2 + t2] = r2[i2];
    return i2;
  }
  a(ot, "blitBuffer");
  function ae(r2, e3) {
    return r2 instanceof e3 || r2 != null && r2.constructor != null && r2.constructor.name != null && r2.constructor.name === e3.name;
  }
  a(ae, "isInstance");
  function Ot(r2) {
    return r2 !== r2;
  }
  a(Ot, "numberIsNaN");
  var Oo = function() {
    let r2 = "0123456789abcdef", e3 = new Array(256);
    for (let t2 = 0; t2 < 16; ++t2) {
      let n2 = t2 * 16;
      for (let i2 = 0; i2 < 16; ++i2)
        e3[n2 + i2] = r2[t2] + r2[i2];
    }
    return e3;
  }();
  function me(r2) {
    return typeof BigInt > "u" ? ko : r2;
  }
  a(me, "defineBigIntMethod");
  function ko() {
    throw new Error("BigInt not supported");
  }
  a(ko, "BufferBigIntNotDefined");
});
var b2;
var S2;
var v2;
var w2;
var d3;
var m2;
var p3 = K2(() => {
  "use strict";
  b2 = globalThis, S2 = globalThis.setImmediate ?? ((r2) => setTimeout(
    r2,
    0
  )), v2 = globalThis.clearImmediate ?? ((r2) => clearTimeout(r2)), w2 = globalThis.crypto ?? {};
  w2.subtle ?? (w2.subtle = {});
  d3 = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : Gn().Buffer, m2 = globalThis.process ?? {};
  m2.env ?? (m2.env = {});
  try {
    m2.nextTick(() => {
    });
  } catch {
    let e3 = Promise.resolve();
    m2.nextTick = e3.then.bind(e3);
  }
});
var ge = I((Jc, kt) => {
  "use strict";
  p3();
  var Re = typeof Reflect == "object" ? Reflect : null, $n = Re && typeof Re.apply == "function" ? Re.apply : a(function(e3, t2, n2) {
    return Function.prototype.apply.call(e3, t2, n2);
  }, "ReflectApply"), at;
  Re && typeof Re.ownKeys == "function" ? at = Re.ownKeys : Object.getOwnPropertySymbols ? at = a(function(e3) {
    return Object.getOwnPropertyNames(
      e3
    ).concat(Object.getOwnPropertySymbols(e3));
  }, "ReflectOwnKeys") : at = a(function(e3) {
    return Object.getOwnPropertyNames(e3);
  }, "ReflectOwnKeys");
  function Uo(r2) {
    console && console.warn && console.warn(r2);
  }
  a(Uo, "ProcessEmitWarning");
  var Vn = Number.isNaN || a(function(e3) {
    return e3 !== e3;
  }, "NumberIsNaN");
  function B() {
    B.init.call(this);
  }
  a(B, "EventEmitter");
  kt.exports = B;
  kt.exports.once = Wo;
  B.EventEmitter = B;
  B.prototype._events = void 0;
  B.prototype._eventsCount = 0;
  B.prototype._maxListeners = void 0;
  var Kn = 10;
  function ut(r2) {
    if (typeof r2 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r2);
  }
  a(ut, "checkListener");
  Object.defineProperty(B, "defaultMaxListeners", { enumerable: true, get: function() {
    return Kn;
  }, set: function(r2) {
    if (typeof r2 != "number" || r2 < 0 || Vn(r2))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r2 + ".");
    Kn = r2;
  } });
  B.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  B.prototype.setMaxListeners = a(function(e3) {
    if (typeof e3 != "number" || e3 < 0 || Vn(
      e3
    ))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    return this._maxListeners = e3, this;
  }, "setMaxListeners");
  function zn(r2) {
    return r2._maxListeners === void 0 ? B.defaultMaxListeners : r2._maxListeners;
  }
  a(zn, "_getMaxListeners");
  B.prototype.getMaxListeners = a(
    function() {
      return zn(this);
    },
    "getMaxListeners"
  );
  B.prototype.emit = a(function(e3) {
    for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
      t2.push(arguments[n2]);
    var i2 = e3 === "error", s2 = this._events;
    if (s2 !== void 0)
      i2 = i2 && s2.error === void 0;
    else if (!i2)
      return false;
    if (i2) {
      var o2;
      if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error)
        throw o2;
      var u2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
      throw u2.context = o2, u2;
    }
    var c3 = s2[e3];
    if (c3 === void 0)
      return false;
    if (typeof c3 == "function")
      $n(c3, this, t2);
    else
      for (var h2 = c3.length, l3 = ei(c3, h2), n2 = 0; n2 < h2; ++n2)
        $n(l3[n2], this, t2);
    return true;
  }, "emit");
  function Yn(r2, e3, t2, n2) {
    var i2, s2, o2;
    if (ut(t2), s2 = r2._events, s2 === void 0 ? (s2 = r2._events = /* @__PURE__ */ Object.create(null), r2._eventsCount = 0) : (s2.newListener !== void 0 && (r2.emit("newListener", e3, t2.listener ? t2.listener : t2), s2 = r2._events), o2 = s2[e3]), o2 === void 0)
      o2 = s2[e3] = t2, ++r2._eventsCount;
    else if (typeof o2 == "function" ? o2 = s2[e3] = n2 ? [t2, o2] : [o2, t2] : n2 ? o2.unshift(t2) : o2.push(t2), i2 = zn(r2), i2 > 0 && o2.length > i2 && !o2.warned) {
      o2.warned = true;
      var u2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u2.name = "MaxListenersExceededWarning", u2.emitter = r2, u2.type = e3, u2.count = o2.length, Uo(u2);
    }
    return r2;
  }
  a(Yn, "_addListener");
  B.prototype.addListener = a(function(e3, t2) {
    return Yn(
      this,
      e3,
      t2,
      false
    );
  }, "addListener");
  B.prototype.on = B.prototype.addListener;
  B.prototype.prependListener = a(function(e3, t2) {
    return Yn(this, e3, t2, true);
  }, "prependListener");
  function qo() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  a(qo, "onceWrapper");
  function Zn(r2, e3, t2) {
    var n2 = {
      fired: false,
      wrapFn: void 0,
      target: r2,
      type: e3,
      listener: t2
    }, i2 = qo.bind(n2);
    return i2.listener = t2, n2.wrapFn = i2, i2;
  }
  a(Zn, "_onceWrap");
  B.prototype.once = a(function(e3, t2) {
    return ut(t2), this.on(e3, Zn(this, e3, t2)), this;
  }, "once");
  B.prototype.prependOnceListener = a(function(e3, t2) {
    return ut(t2), this.prependListener(e3, Zn(this, e3, t2)), this;
  }, "prependOnceListener");
  B.prototype.removeListener = a(function(e3, t2) {
    var n2, i2, s2, o2, u2;
    if (ut(t2), i2 = this._events, i2 === void 0)
      return this;
    if (n2 = i2[e3], n2 === void 0)
      return this;
    if (n2 === t2 || n2.listener === t2)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[e3], i2.removeListener && this.emit("removeListener", e3, n2.listener || t2));
    else if (typeof n2 != "function") {
      for (s2 = -1, o2 = n2.length - 1; o2 >= 0; o2--)
        if (n2[o2] === t2 || n2[o2].listener === t2) {
          u2 = n2[o2].listener, s2 = o2;
          break;
        }
      if (s2 < 0)
        return this;
      s2 === 0 ? n2.shift() : No(n2, s2), n2.length === 1 && (i2[e3] = n2[0]), i2.removeListener !== void 0 && this.emit(
        "removeListener",
        e3,
        u2 || t2
      );
    }
    return this;
  }, "removeListener");
  B.prototype.off = B.prototype.removeListener;
  B.prototype.removeAllListeners = a(function(e3) {
    var t2, n2, i2;
    if (n2 = this._events, n2 === void 0)
      return this;
    if (n2.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n2[e3] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e3]), this;
    if (arguments.length === 0) {
      var s2 = Object.keys(n2), o2;
      for (i2 = 0; i2 < s2.length; ++i2)
        o2 = s2[i2], o2 !== "removeListener" && this.removeAllListeners(o2);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t2 = n2[e3], typeof t2 == "function")
      this.removeListener(e3, t2);
    else if (t2 !== void 0)
      for (i2 = t2.length - 1; i2 >= 0; i2--)
        this.removeListener(e3, t2[i2]);
    return this;
  }, "removeAllListeners");
  function Jn(r2, e3, t2) {
    var n2 = r2._events;
    if (n2 === void 0)
      return [];
    var i2 = n2[e3];
    return i2 === void 0 ? [] : typeof i2 == "function" ? t2 ? [i2.listener || i2] : [i2] : t2 ? Qo(i2) : ei(i2, i2.length);
  }
  a(Jn, "_listeners");
  B.prototype.listeners = a(function(e3) {
    return Jn(this, e3, true);
  }, "listeners");
  B.prototype.rawListeners = a(function(e3) {
    return Jn(this, e3, false);
  }, "rawListeners");
  B.listenerCount = function(r2, e3) {
    return typeof r2.listenerCount == "function" ? r2.listenerCount(e3) : Xn.call(r2, e3);
  };
  B.prototype.listenerCount = Xn;
  function Xn(r2) {
    var e3 = this._events;
    if (e3 !== void 0) {
      var t2 = e3[r2];
      if (typeof t2 == "function")
        return 1;
      if (t2 !== void 0)
        return t2.length;
    }
    return 0;
  }
  a(Xn, "listenerCount");
  B.prototype.eventNames = a(function() {
    return this._eventsCount > 0 ? at(this._events) : [];
  }, "eventNames");
  function ei(r2, e3) {
    for (var t2 = new Array(e3), n2 = 0; n2 < e3; ++n2)
      t2[n2] = r2[n2];
    return t2;
  }
  a(ei, "arrayClone");
  function No(r2, e3) {
    for (; e3 + 1 < r2.length; e3++)
      r2[e3] = r2[e3 + 1];
    r2.pop();
  }
  a(No, "spliceOne");
  function Qo(r2) {
    for (var e3 = new Array(r2.length), t2 = 0; t2 < e3.length; ++t2)
      e3[t2] = r2[t2].listener || r2[t2];
    return e3;
  }
  a(Qo, "unwrapListeners");
  function Wo(r2, e3) {
    return new Promise(
      function(t2, n2) {
        function i2(o2) {
          r2.removeListener(e3, s2), n2(o2);
        }
        a(i2, "errorListener");
        function s2() {
          typeof r2.removeListener == "function" && r2.removeListener("error", i2), t2([].slice.call(
            arguments
          ));
        }
        a(s2, "resolver"), ti(r2, e3, s2, { once: true }), e3 !== "error" && jo(r2, i2, { once: true });
      }
    );
  }
  a(Wo, "once");
  function jo(r2, e3, t2) {
    typeof r2.on == "function" && ti(r2, "error", e3, t2);
  }
  a(
    jo,
    "addErrorHandlerIfEventEmitter"
  );
  function ti(r2, e3, t2, n2) {
    if (typeof r2.on == "function")
      n2.once ? r2.once(e3, t2) : r2.on(e3, t2);
    else if (typeof r2.addEventListener == "function")
      r2.addEventListener(
        e3,
        a(function i2(s2) {
          n2.once && r2.removeEventListener(e3, i2), t2(s2);
        }, "wrapListener")
      );
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r2);
  }
  a(ti, "eventTargetAgnosticAddListener");
});
var He = {};
X2(He, { default: () => Ho });
var Ho;
var Ge = K2(() => {
  "use strict";
  p3();
  Ho = {};
});
function $e(r2) {
  let e3 = 1779033703, t2 = 3144134277, n2 = 1013904242, i2 = 2773480762, s2 = 1359893119, o2 = 2600822924, u2 = 528734635, c3 = 1541459225, h2 = 0, l3 = 0, y2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], E = a(
    (A, g2) => A >>> g2 | A << 32 - g2,
    "rrot"
  ), _ = new Uint32Array(64), P2 = new Uint8Array(64), N = a(() => {
    for (let L = 0, G = 0; L < 16; L++, G += 4)
      _[L] = P2[G] << 24 | P2[G + 1] << 16 | P2[G + 2] << 8 | P2[G + 3];
    for (let L = 16; L < 64; L++) {
      let G = E(_[L - 15], 7) ^ E(_[L - 15], 18) ^ _[L - 15] >>> 3, ce = E(_[L - 2], 17) ^ E(_[L - 2], 19) ^ _[L - 2] >>> 10;
      _[L] = _[L - 16] + G + _[L - 7] + ce | 0;
    }
    let A = e3, g2 = t2, D = n2, H = i2, Q = s2, W = o2, ue = u2, de = c3;
    for (let L = 0; L < 64; L++) {
      let G = E(
        Q,
        6
      ) ^ E(Q, 11) ^ E(Q, 25), ce = Q & W ^ ~Q & ue, ye = de + G + ce + y2[L] + _[L] | 0, xe = E(A, 2) ^ E(A, 13) ^ E(A, 22), he = A & g2 ^ A & D ^ g2 & D, ie = xe + he | 0;
      de = ue, ue = W, W = Q, Q = H + ye | 0, H = D, D = g2, g2 = A, A = ye + ie | 0;
    }
    e3 = e3 + A | 0, t2 = t2 + g2 | 0, n2 = n2 + D | 0, i2 = i2 + H | 0, s2 = s2 + Q | 0, o2 = o2 + W | 0, u2 = u2 + ue | 0, c3 = c3 + de | 0, l3 = 0;
  }, "process"), J = a((A) => {
    typeof A == "string" && (A = new TextEncoder().encode(A));
    for (let g2 = 0; g2 < A.length; g2++)
      P2[l3++] = A[g2], l3 === 64 && N();
    h2 += A.length;
  }, "add"), pe = a(() => {
    if (P2[l3++] = 128, l3 == 64 && N(), l3 + 8 > 64) {
      for (; l3 < 64; )
        P2[l3++] = 0;
      N();
    }
    for (; l3 < 58; )
      P2[l3++] = 0;
    let A = h2 * 8;
    P2[l3++] = A / 1099511627776 & 255, P2[l3++] = A / 4294967296 & 255, P2[l3++] = A >>> 24, P2[l3++] = A >>> 16 & 255, P2[l3++] = A >>> 8 & 255, P2[l3++] = A & 255, N();
    let g2 = new Uint8Array(32);
    return g2[0] = e3 >>> 24, g2[1] = e3 >>> 16 & 255, g2[2] = e3 >>> 8 & 255, g2[3] = e3 & 255, g2[4] = t2 >>> 24, g2[5] = t2 >>> 16 & 255, g2[6] = t2 >>> 8 & 255, g2[7] = t2 & 255, g2[8] = n2 >>> 24, g2[9] = n2 >>> 16 & 255, g2[10] = n2 >>> 8 & 255, g2[11] = n2 & 255, g2[12] = i2 >>> 24, g2[13] = i2 >>> 16 & 255, g2[14] = i2 >>> 8 & 255, g2[15] = i2 & 255, g2[16] = s2 >>> 24, g2[17] = s2 >>> 16 & 255, g2[18] = s2 >>> 8 & 255, g2[19] = s2 & 255, g2[20] = o2 >>> 24, g2[21] = o2 >>> 16 & 255, g2[22] = o2 >>> 8 & 255, g2[23] = o2 & 255, g2[24] = u2 >>> 24, g2[25] = u2 >>> 16 & 255, g2[26] = u2 >>> 8 & 255, g2[27] = u2 & 255, g2[28] = c3 >>> 24, g2[29] = c3 >>> 16 & 255, g2[30] = c3 >>> 8 & 255, g2[31] = c3 & 255, g2;
  }, "digest");
  return r2 === void 0 ? { add: J, digest: pe } : (J(r2), pe());
}
var ri = K2(
  () => {
    "use strict";
    p3();
    a($e, "sha256");
  }
);
var O2;
var Ke;
var ni = K2(() => {
  "use strict";
  p3();
  O2 = class O3 {
    constructor() {
      T(
        this,
        "_dataLength",
        0
      );
      T(this, "_bufferLength", 0);
      T(this, "_state", new Int32Array(4));
      T(
        this,
        "_buffer",
        new ArrayBuffer(68)
      );
      T(this, "_buffer8");
      T(this, "_buffer32");
      this._buffer8 = new Uint8Array(
        this._buffer,
        0,
        68
      ), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashByteArray(e3, t2 = false) {
      return this.onePassHasher.start().appendByteArray(e3).end(t2);
    }
    static hashStr(e3, t2 = false) {
      return this.onePassHasher.start().appendStr(e3).end(t2);
    }
    static hashAsciiStr(e3, t2 = false) {
      return this.onePassHasher.start().appendAsciiStr(e3).end(t2);
    }
    static _hex(e3) {
      let t2 = O3.hexChars, n2 = O3.hexOut, i2, s2, o2, u2;
      for (u2 = 0; u2 < 4; u2 += 1)
        for (s2 = u2 * 8, i2 = e3[u2], o2 = 0; o2 < 8; o2 += 2)
          n2[s2 + 1 + o2] = t2.charAt(i2 & 15), i2 >>>= 4, n2[s2 + 0 + o2] = t2.charAt(i2 & 15), i2 >>>= 4;
      return n2.join("");
    }
    static _md5cycle(e3, t2) {
      let n2 = e3[0], i2 = e3[1], s2 = e3[2], o2 = e3[3];
      n2 += (i2 & s2 | ~i2 & o2) + t2[0] - 680876936 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[1] - 389564586 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[2] + 606105819 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[3] - 1044525330 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[4] - 176418897 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[5] + 1200080426 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[6] - 1473231341 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[7] - 45705983 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[8] + 1770035416 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[9] - 1958414417 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[10] - 42063 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[11] - 1990404162 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[12] + 1804603682 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[13] - 40341101 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[14] - 1502002290 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[15] + 1236535329 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[1] - 165796510 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[6] - 1069501632 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[11] + 643717713 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[0] - 373897302 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[5] - 701558691 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[10] + 38016083 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[15] - 660478335 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[4] - 405537848 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[9] + 568446438 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[14] - 1019803690 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[3] - 187363961 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[8] + 1163531501 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[13] - 1444681467 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[2] - 51403784 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[7] + 1735328473 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[12] - 1926607734 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[5] - 378558 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[8] - 2022574463 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[11] + 1839030562 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[14] - 35309556 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[1] - 1530992060 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[4] + 1272893353 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[7] - 155497632 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[10] - 1094730640 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[13] + 681279174 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[0] - 358537222 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[3] - 722521979 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[6] + 76029189 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[9] - 640364487 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[12] - 421815835 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[15] + 530742520 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[2] - 995338651 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[0] - 198630844 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[7] + 1126891415 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[14] - 1416354905 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[5] - 57434055 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[12] + 1700485571 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[3] - 1894986606 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[10] - 1051523 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[1] - 2054922799 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[8] + 1873313359 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[15] - 30611744 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[6] - 1560198380 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[13] + 1309151649 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[4] - 145523070 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[11] - 1120210379 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[2] + 718787259 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[9] - 343485551 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, e3[0] = n2 + e3[0] | 0, e3[1] = i2 + e3[1] | 0, e3[2] = s2 + e3[2] | 0, e3[3] = o2 + e3[3] | 0;
    }
    start() {
      return this._dataLength = 0, this._bufferLength = 0, this._state.set(O3.stateIdentity), this;
    }
    appendStr(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2;
      for (o2 = 0; o2 < e3.length; o2 += 1) {
        if (s2 = e3.charCodeAt(o2), s2 < 128)
          t2[i2++] = s2;
        else if (s2 < 2048)
          t2[i2++] = (s2 >>> 6) + 192, t2[i2++] = s2 & 63 | 128;
        else if (s2 < 55296 || s2 > 56319)
          t2[i2++] = (s2 >>> 12) + 224, t2[i2++] = s2 >>> 6 & 63 | 128, t2[i2++] = s2 & 63 | 128;
        else {
          if (s2 = (s2 - 55296) * 1024 + (e3.charCodeAt(++o2) - 56320) + 65536, s2 > 1114111)
            throw new Error("Unicode standard supports code points up to U+10FFFF");
          t2[i2++] = (s2 >>> 18) + 240, t2[i2++] = s2 >>> 12 & 63 | 128, t2[i2++] = s2 >>> 6 & 63 | 128, t2[i2++] = s2 & 63 | 128;
        }
        i2 >= 64 && (this._dataLength += 64, O3._md5cycle(this._state, n2), i2 -= 64, n2[0] = n2[16]);
      }
      return this._bufferLength = i2, this;
    }
    appendAsciiStr(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2 = 0;
      for (; ; ) {
        for (s2 = Math.min(e3.length - o2, 64 - i2); s2--; )
          t2[i2++] = e3.charCodeAt(o2++);
        if (i2 < 64)
          break;
        this._dataLength += 64, O3._md5cycle(
          this._state,
          n2
        ), i2 = 0;
      }
      return this._bufferLength = i2, this;
    }
    appendByteArray(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2 = 0;
      for (; ; ) {
        for (s2 = Math.min(e3.length - o2, 64 - i2); s2--; )
          t2[i2++] = e3[o2++];
        if (i2 < 64)
          break;
        this._dataLength += 64, O3._md5cycle(
          this._state,
          n2
        ), i2 = 0;
      }
      return this._bufferLength = i2, this;
    }
    getState() {
      let e3 = this._state;
      return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e3[0], e3[1], e3[2], e3[3]] };
    }
    setState(e3) {
      let t2 = e3.buffer, n2 = e3.state, i2 = this._state, s2;
      for (this._dataLength = e3.length, this._bufferLength = e3.buflen, i2[0] = n2[0], i2[1] = n2[1], i2[2] = n2[2], i2[3] = n2[3], s2 = 0; s2 < t2.length; s2 += 1)
        this._buffer8[s2] = t2.charCodeAt(s2);
    }
    end(e3 = false) {
      let t2 = this._bufferLength, n2 = this._buffer8, i2 = this._buffer32, s2 = (t2 >> 2) + 1;
      this._dataLength += t2;
      let o2 = this._dataLength * 8;
      if (n2[t2] = 128, n2[t2 + 1] = n2[t2 + 2] = n2[t2 + 3] = 0, i2.set(O3.buffer32Identity.subarray(s2), s2), t2 > 55 && (O3._md5cycle(this._state, i2), i2.set(O3.buffer32Identity)), o2 <= 4294967295)
        i2[14] = o2;
      else {
        let u2 = o2.toString(16).match(/(.*?)(.{0,8})$/);
        if (u2 === null)
          return;
        let c3 = parseInt(
          u2[2],
          16
        ), h2 = parseInt(u2[1], 16) || 0;
        i2[14] = c3, i2[15] = h2;
      }
      return O3._md5cycle(this._state, i2), e3 ? this._state : O3._hex(this._state);
    }
  };
  a(O2, "Md5"), T(O2, "stateIdentity", new Int32Array(
    [1732584193, -271733879, -1732584194, 271733878]
  )), T(O2, "buffer32Identity", new Int32Array(
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  )), T(O2, "hexChars", "0123456789abcdef"), T(O2, "hexOut", []), T(O2, "onePassHasher", new O2());
  Ke = O2;
});
var Ut = {};
X2(Ut, { createHash: () => $o, createHmac: () => Ko, randomBytes: () => Go });
function Go(r2) {
  return w2.getRandomValues(d3.alloc(r2));
}
function $o(r2) {
  if (r2 === "sha256")
    return { update: function(e3) {
      return { digest: function() {
        return d3.from($e(e3));
      } };
    } };
  if (r2 === "md5")
    return { update: function(e3) {
      return { digest: function() {
        return typeof e3 == "string" ? Ke.hashStr(e3) : Ke.hashByteArray(
          e3
        );
      } };
    } };
  throw new Error(`Hash type '${r2}' not supported`);
}
function Ko(r2, e3) {
  if (r2 !== "sha256")
    throw new Error(`Only sha256 is supported (requested: '${r2}')`);
  return {
    update: function(t2) {
      return { digest: function() {
        typeof e3 == "string" && (e3 = new TextEncoder().encode(e3)), typeof t2 == "string" && (t2 = new TextEncoder().encode(t2));
        let n2 = e3.length;
        if (n2 > 64)
          e3 = $e(e3);
        else if (n2 < 64) {
          let c3 = new Uint8Array(64);
          c3.set(e3), e3 = c3;
        }
        let i2 = new Uint8Array(
          64
        ), s2 = new Uint8Array(64);
        for (let c3 = 0; c3 < 64; c3++)
          i2[c3] = 54 ^ e3[c3], s2[c3] = 92 ^ e3[c3];
        let o2 = new Uint8Array(
          t2.length + 64
        );
        o2.set(i2, 0), o2.set(t2, 64);
        let u2 = new Uint8Array(96);
        return u2.set(s2, 0), u2.set($e(o2), 64), d3.from($e(u2));
      } };
    }
  };
}
var qt = K2(() => {
  "use strict";
  p3();
  ri();
  ni();
  a(Go, "randomBytes");
  a($o, "createHash");
  a(Ko, "createHmac");
});
var Qt = I((ii) => {
  "use strict";
  p3();
  ii.parse = function(r2, e3) {
    return new Nt(r2, e3).parse();
  };
  var ct = class ct2 {
    constructor(e3, t2) {
      this.source = e3, this.transform = t2 || Vo, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var e3 = this.source[this.position++];
      return e3 === "\\" ? { value: this.source[this.position++], escaped: true } : { value: e3, escaped: false };
    }
    record(e3) {
      this.recorded.push(e3);
    }
    newEntry(e3) {
      var t2;
      (this.recorded.length > 0 || e3) && (t2 = this.recorded.join(""), t2 === "NULL" && !e3 && (t2 = null), t2 !== null && (t2 = this.transform(t2)), this.entries.push(
        t2
      ), this.recorded = []);
    }
    consumeDimensions() {
      if (this.source[0] === "[")
        for (; !this.isEof(); ) {
          var e3 = this.nextCharacter();
          if (e3.value === "=")
            break;
        }
    }
    parse(e3) {
      var t2, n2, i2;
      for (this.consumeDimensions(); !this.isEof(); )
        if (t2 = this.nextCharacter(), t2.value === "{" && !i2)
          this.dimension++, this.dimension > 1 && (n2 = new ct2(this.source.substr(this.position - 1), this.transform), this.entries.push(
            n2.parse(true)
          ), this.position += n2.position - 2);
        else if (t2.value === "}" && !i2) {
          if (this.dimension--, !this.dimension && (this.newEntry(), e3))
            return this.entries;
        } else
          t2.value === '"' && !t2.escaped ? (i2 && this.newEntry(true), i2 = !i2) : t2.value === "," && !i2 ? this.newEntry() : this.record(
            t2.value
          );
      if (this.dimension !== 0)
        throw new Error("array dimension not balanced");
      return this.entries;
    }
  };
  a(ct, "ArrayParser");
  var Nt = ct;
  function Vo(r2) {
    return r2;
  }
  a(Vo, "identity");
});
var Wt = I((yh, si) => {
  p3();
  var zo = Qt();
  si.exports = { create: function(r2, e3) {
    return { parse: function() {
      return zo.parse(r2, e3);
    } };
  } };
});
var ui = I((gh, ai) => {
  "use strict";
  p3();
  var Yo = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, Zo = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, Jo = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, Xo = /^-?infinity$/;
  ai.exports = a(function(e3) {
    if (Xo.test(e3))
      return Number(e3.replace("i", "I"));
    var t2 = Yo.exec(e3);
    if (!t2)
      return ea(e3) || null;
    var n2 = !!t2[8], i2 = parseInt(t2[1], 10);
    n2 && (i2 = oi(i2));
    var s2 = parseInt(
      t2[2],
      10
    ) - 1, o2 = t2[3], u2 = parseInt(t2[4], 10), c3 = parseInt(t2[5], 10), h2 = parseInt(t2[6], 10), l3 = t2[7];
    l3 = l3 ? 1e3 * parseFloat(l3) : 0;
    var y2, E = ta(e3);
    return E != null ? (y2 = new Date(Date.UTC(
      i2,
      s2,
      o2,
      u2,
      c3,
      h2,
      l3
    )), jt(i2) && y2.setUTCFullYear(i2), E !== 0 && y2.setTime(y2.getTime() - E)) : (y2 = new Date(
      i2,
      s2,
      o2,
      u2,
      c3,
      h2,
      l3
    ), jt(i2) && y2.setFullYear(i2)), y2;
  }, "parseDate");
  function ea(r2) {
    var e3 = Zo.exec(r2);
    if (e3) {
      var t2 = parseInt(e3[1], 10), n2 = !!e3[4];
      n2 && (t2 = oi(t2));
      var i2 = parseInt(
        e3[2],
        10
      ) - 1, s2 = e3[3], o2 = new Date(t2, i2, s2);
      return jt(t2) && o2.setFullYear(t2), o2;
    }
  }
  a(ea, "getDate");
  function ta(r2) {
    if (r2.endsWith("+00"))
      return 0;
    var e3 = Jo.exec(r2.split(" ")[1]);
    if (e3) {
      var t2 = e3[1];
      if (t2 === "Z")
        return 0;
      var n2 = t2 === "-" ? -1 : 1, i2 = parseInt(e3[2], 10) * 3600 + parseInt(
        e3[3] || 0,
        10
      ) * 60 + parseInt(e3[4] || 0, 10);
      return i2 * n2 * 1e3;
    }
  }
  a(ta, "timeZoneOffset");
  function oi(r2) {
    return -(r2 - 1);
  }
  a(oi, "bcYearToNegativeYear");
  function jt(r2) {
    return r2 >= 0 && r2 < 100;
  }
  a(
    jt,
    "is0To99"
  );
});
var hi = I((Sh, ci) => {
  p3();
  ci.exports = na;
  var ra = Object.prototype.hasOwnProperty;
  function na(r2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var n2 in t2)
        ra.call(
          t2,
          n2
        ) && (r2[n2] = t2[n2]);
    }
    return r2;
  }
  a(na, "extend");
});
var pi = I((vh, fi) => {
  "use strict";
  p3();
  var ia = hi();
  fi.exports = Fe;
  function Fe(r2) {
    if (!(this instanceof Fe))
      return new Fe(r2);
    ia(this, ma(r2));
  }
  a(Fe, "PostgresInterval");
  var sa = ["seconds", "minutes", "hours", "days", "months", "years"];
  Fe.prototype.toPostgres = function() {
    var r2 = sa.filter(this.hasOwnProperty, this);
    return this.milliseconds && r2.indexOf("seconds") < 0 && r2.push("seconds"), r2.length === 0 ? "0" : r2.map(function(e3) {
      var t2 = this[e3] || 0;
      return e3 === "seconds" && this.milliseconds && (t2 = (t2 + this.milliseconds / 1e3).toFixed(6).replace(
        /\.?0+$/,
        ""
      )), t2 + " " + e3;
    }, this).join(" ");
  };
  var oa = { years: "Y", months: "M", days: "D", hours: "H", minutes: "M", seconds: "S" }, aa = ["years", "months", "days"], ua = ["hours", "minutes", "seconds"];
  Fe.prototype.toISOString = Fe.prototype.toISO = function() {
    var r2 = aa.map(t2, this).join(""), e3 = ua.map(t2, this).join("");
    return "P" + r2 + "T" + e3;
    function t2(n2) {
      var i2 = this[n2] || 0;
      return n2 === "seconds" && this.milliseconds && (i2 = (i2 + this.milliseconds / 1e3).toFixed(6).replace(
        /0+$/,
        ""
      )), i2 + oa[n2];
    }
  };
  var Ht = "([+-]?\\d+)", ca = Ht + "\\s+years?", ha = Ht + "\\s+mons?", la = Ht + "\\s+days?", fa = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", pa = new RegExp([
    ca,
    ha,
    la,
    fa
  ].map(function(r2) {
    return "(" + r2 + ")?";
  }).join("\\s*")), li = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  }, da = ["hours", "minutes", "seconds", "milliseconds"];
  function ya(r2) {
    var e3 = r2 + "000000".slice(r2.length);
    return parseInt(
      e3,
      10
    ) / 1e3;
  }
  a(ya, "parseMilliseconds");
  function ma(r2) {
    if (!r2)
      return {};
    var e3 = pa.exec(
      r2
    ), t2 = e3[8] === "-";
    return Object.keys(li).reduce(function(n2, i2) {
      var s2 = li[i2], o2 = e3[s2];
      return !o2 || (o2 = i2 === "milliseconds" ? ya(o2) : parseInt(o2, 10), !o2) || (t2 && ~da.indexOf(i2) && (o2 *= -1), n2[i2] = o2), n2;
    }, {});
  }
  a(ma, "parse");
});
var yi = I((Ch, di) => {
  "use strict";
  p3();
  di.exports = a(function(e3) {
    if (/^\\x/.test(e3))
      return new d3(
        e3.substr(2),
        "hex"
      );
    for (var t2 = "", n2 = 0; n2 < e3.length; )
      if (e3[n2] !== "\\")
        t2 += e3[n2], ++n2;
      else if (/[0-7]{3}/.test(e3.substr(n2 + 1, 3)))
        t2 += String.fromCharCode(parseInt(e3.substr(n2 + 1, 3), 8)), n2 += 4;
      else {
        for (var i2 = 1; n2 + i2 < e3.length && e3[n2 + i2] === "\\"; )
          i2++;
        for (var s2 = 0; s2 < Math.floor(i2 / 2); ++s2)
          t2 += "\\";
        n2 += Math.floor(i2 / 2) * 2;
      }
    return new d3(t2, "binary");
  }, "parseBytea");
});
var Ei = I((Ph, xi) => {
  p3();
  var Ve = Qt(), ze = Wt(), ht = ui(), gi = pi(), wi = yi();
  function lt2(r2) {
    return a(function(t2) {
      return t2 === null ? t2 : r2(t2);
    }, "nullAllowed");
  }
  a(lt2, "allowNull");
  function bi(r2) {
    return r2 === null ? r2 : r2 === "TRUE" || r2 === "t" || r2 === "true" || r2 === "y" || r2 === "yes" || r2 === "on" || r2 === "1";
  }
  a(bi, "parseBool");
  function ga(r2) {
    return r2 ? Ve.parse(r2, bi) : null;
  }
  a(ga, "parseBoolArray");
  function wa(r2) {
    return parseInt(r2, 10);
  }
  a(wa, "parseBaseTenInt");
  function Gt(r2) {
    return r2 ? Ve.parse(r2, lt2(wa)) : null;
  }
  a(Gt, "parseIntegerArray");
  function ba(r2) {
    return r2 ? Ve.parse(r2, lt2(function(e3) {
      return Si(e3).trim();
    })) : null;
  }
  a(ba, "parseBigIntegerArray");
  var Sa = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = zt(t2)), t2;
    });
    return e3.parse();
  }, "parsePointArray"), $t = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = parseFloat(t2)), t2;
    });
    return e3.parse();
  }, "parseFloatArray"), te = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2);
    return e3.parse();
  }, "parseStringArray"), Kt = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = ht(t2)), t2;
    });
    return e3.parse();
  }, "parseDateArray"), xa = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = gi(t2)), t2;
    });
    return e3.parse();
  }, "parseIntervalArray"), Ea = a(function(r2) {
    return r2 ? Ve.parse(r2, lt2(wi)) : null;
  }, "parseByteAArray"), Vt = a(function(r2) {
    return parseInt(
      r2,
      10
    );
  }, "parseInteger"), Si = a(function(r2) {
    var e3 = String(r2);
    return /^\d+$/.test(e3) ? e3 : r2;
  }, "parseBigInteger"), mi = a(
    function(r2) {
      return r2 ? Ve.parse(r2, lt2(JSON.parse)) : null;
    },
    "parseJsonArray"
  ), zt = a(function(r2) {
    return r2[0] !== "(" ? null : (r2 = r2.substring(1, r2.length - 1).split(","), { x: parseFloat(r2[0]), y: parseFloat(r2[1]) });
  }, "parsePoint"), va = a(function(r2) {
    if (r2[0] !== "<" && r2[1] !== "(")
      return null;
    for (var e3 = "(", t2 = "", n2 = false, i2 = 2; i2 < r2.length - 1; i2++) {
      if (n2 || (e3 += r2[i2]), r2[i2] === ")") {
        n2 = true;
        continue;
      } else if (!n2)
        continue;
      r2[i2] !== "," && (t2 += r2[i2]);
    }
    var s2 = zt(e3);
    return s2.radius = parseFloat(t2), s2;
  }, "parseCircle"), _a90 = a(function(r2) {
    r2(
      20,
      Si
    ), r2(21, Vt), r2(23, Vt), r2(26, Vt), r2(700, parseFloat), r2(701, parseFloat), r2(16, bi), r2(
      1082,
      ht
    ), r2(1114, ht), r2(1184, ht), r2(600, zt), r2(651, te), r2(718, va), r2(1e3, ga), r2(1001, Ea), r2(
      1005,
      Gt
    ), r2(1007, Gt), r2(1028, Gt), r2(1016, ba), r2(1017, Sa), r2(1021, $t), r2(1022, $t), r2(1231, $t), r2(1014, te), r2(1015, te), r2(1008, te), r2(1009, te), r2(1040, te), r2(1041, te), r2(1115, Kt), r2(
      1182,
      Kt
    ), r2(1185, Kt), r2(1186, gi), r2(1187, xa), r2(17, wi), r2(114, JSON.parse.bind(JSON)), r2(
      3802,
      JSON.parse.bind(JSON)
    ), r2(199, mi), r2(3807, mi), r2(3907, te), r2(2951, te), r2(791, te), r2(
      1183,
      te
    ), r2(1270, te);
  }, "init");
  xi.exports = { init: _a90 };
});
var _i = I((Rh, vi) => {
  "use strict";
  p3();
  var Y = 1e6;
  function Aa(r2) {
    var e3 = r2.readInt32BE(
      0
    ), t2 = r2.readUInt32BE(4), n2 = "";
    e3 < 0 && (e3 = ~e3 + (t2 === 0), t2 = ~t2 + 1 >>> 0, n2 = "-");
    var i2 = "", s2, o2, u2, c3, h2, l3;
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    return s2 = e3 % Y, o2 = 4294967296 * s2 + t2, u2 = "" + o2 % Y, n2 + u2 + i2;
  }
  a(Aa, "readInt8");
  vi.exports = Aa;
});
var Pi = I((Dh, Ti) => {
  p3();
  var Ca = _i(), R = a(function(r2, e3, t2, n2, i2) {
    t2 = t2 || 0, n2 = n2 || false, i2 = i2 || function(_, P2, N) {
      return _ * Math.pow(2, N) + P2;
    };
    var s2 = t2 >> 3, o2 = a(function(_) {
      return n2 ? ~_ & 255 : _;
    }, "inv"), u2 = 255, c3 = 8 - t2 % 8;
    e3 < c3 && (u2 = 255 << 8 - e3 & 255, c3 = e3), t2 && (u2 = u2 >> t2 % 8);
    var h2 = 0;
    t2 % 8 + e3 >= 8 && (h2 = i2(0, o2(r2[s2]) & u2, c3));
    for (var l3 = e3 + t2 >> 3, y2 = s2 + 1; y2 < l3; y2++)
      h2 = i2(h2, o2(r2[y2]), 8);
    var E = (e3 + t2) % 8;
    return E > 0 && (h2 = i2(h2, o2(r2[l3]) >> 8 - E, E)), h2;
  }, "parseBits"), Ii = a(function(r2, e3, t2) {
    var n2 = Math.pow(2, t2 - 1) - 1, i2 = R(r2, 1), s2 = R(r2, t2, 1);
    if (s2 === 0)
      return 0;
    var o2 = 1, u2 = a(function(h2, l3, y2) {
      h2 === 0 && (h2 = 1);
      for (var E = 1; E <= y2; E++)
        o2 /= 2, (l3 & 1 << y2 - E) > 0 && (h2 += o2);
      return h2;
    }, "parsePrecisionBits"), c3 = R(r2, e3, t2 + 1, false, u2);
    return s2 == Math.pow(2, t2 + 1) - 1 ? c3 === 0 ? i2 === 0 ? 1 / 0 : -1 / 0 : NaN : (i2 === 0 ? 1 : -1) * Math.pow(2, s2 - n2) * c3;
  }, "parseFloatFromBits"), Ia = a(function(r2) {
    return R(r2, 1) == 1 ? -1 * (R(r2, 15, 1, true) + 1) : R(r2, 15, 1);
  }, "parseInt16"), Ai = a(function(r2) {
    return R(r2, 1) == 1 ? -1 * (R(
      r2,
      31,
      1,
      true
    ) + 1) : R(r2, 31, 1);
  }, "parseInt32"), Ta = a(function(r2) {
    return Ii(r2, 23, 8);
  }, "parseFloat32"), Pa = a(function(r2) {
    return Ii(r2, 52, 11);
  }, "parseFloat64"), Ba = a(function(r2) {
    var e3 = R(r2, 16, 32);
    if (e3 == 49152)
      return NaN;
    for (var t2 = Math.pow(1e4, R(r2, 16, 16)), n2 = 0, i2 = [], s2 = R(r2, 16), o2 = 0; o2 < s2; o2++)
      n2 += R(r2, 16, 64 + 16 * o2) * t2, t2 /= 1e4;
    var u2 = Math.pow(10, R(r2, 16, 48));
    return (e3 === 0 ? 1 : -1) * Math.round(n2 * u2) / u2;
  }, "parseNumeric"), Ci = a(function(r2, e3) {
    var t2 = R(
      e3,
      1
    ), n2 = R(e3, 63, 1), i2 = new Date((t2 === 0 ? 1 : -1) * n2 / 1e3 + 9466848e5);
    return r2 || i2.setTime(i2.getTime() + i2.getTimezoneOffset() * 6e4), i2.usec = n2 % 1e3, i2.getMicroSeconds = function() {
      return this.usec;
    }, i2.setMicroSeconds = function(s2) {
      this.usec = s2;
    }, i2.getUTCMicroSeconds = function() {
      return this.usec;
    }, i2;
  }, "parseDate"), Ye = a(function(r2) {
    for (var e3 = R(r2, 32), t2 = R(r2, 32, 32), n2 = R(r2, 32, 64), i2 = 96, s2 = [], o2 = 0; o2 < e3; o2++)
      s2[o2] = R(r2, 32, i2), i2 += 32, i2 += 32;
    var u2 = a(function(h2) {
      var l3 = R(r2, 32, i2);
      if (i2 += 32, l3 == 4294967295)
        return null;
      var y2;
      if (h2 == 23 || h2 == 20)
        return y2 = R(r2, l3 * 8, i2), i2 += l3 * 8, y2;
      if (h2 == 25)
        return y2 = r2.toString(this.encoding, i2 >> 3, (i2 += l3 << 3) >> 3), y2;
      console.log("ERROR: ElementType not implemented: " + h2);
    }, "parseElement"), c3 = a(function(h2, l3) {
      var y2 = [], E;
      if (h2.length > 1) {
        var _ = h2.shift();
        for (E = 0; E < _; E++)
          y2[E] = c3(h2, l3);
        h2.unshift(
          _
        );
      } else
        for (E = 0; E < h2[0]; E++)
          y2[E] = u2(l3);
      return y2;
    }, "parse");
    return c3(s2, n2);
  }, "parseArray"), La = a(function(r2) {
    return r2.toString("utf8");
  }, "parseText"), Ra = a(function(r2) {
    return r2 === null ? null : R(r2, 8) > 0;
  }, "parseBool"), Fa = a(function(r2) {
    r2(20, Ca), r2(21, Ia), r2(23, Ai), r2(
      26,
      Ai
    ), r2(1700, Ba), r2(700, Ta), r2(701, Pa), r2(16, Ra), r2(1114, Ci.bind(null, false)), r2(1184, Ci.bind(
      null,
      true
    )), r2(1e3, Ye), r2(1007, Ye), r2(1016, Ye), r2(1008, Ye), r2(1009, Ye), r2(25, La);
  }, "init");
  Ti.exports = { init: Fa };
});
var Li = I((Uh, Bi) => {
  p3();
  Bi.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});
var Xe = I((Je) => {
  p3();
  var Ma = Ei(), Da = Pi(), Oa = Wt(), ka = Li();
  Je.getTypeParser = Ua;
  Je.setTypeParser = qa;
  Je.arrayParser = Oa;
  Je.builtins = ka;
  var Ze = { text: {}, binary: {} };
  function Ri(r2) {
    return String(
      r2
    );
  }
  a(Ri, "noParse");
  function Ua(r2, e3) {
    return e3 = e3 || "text", Ze[e3] && Ze[e3][r2] || Ri;
  }
  a(
    Ua,
    "getTypeParser"
  );
  function qa(r2, e3, t2) {
    typeof e3 == "function" && (t2 = e3, e3 = "text"), Ze[e3][r2] = t2;
  }
  a(qa, "setTypeParser");
  Ma.init(function(r2, e3) {
    Ze.text[r2] = e3;
  });
  Da.init(function(r2, e3) {
    Ze.binary[r2] = e3;
  });
});
var et = I((jh, Yt) => {
  "use strict";
  p3();
  Yt.exports = {
    host: "localhost",
    user: m2.platform === "win32" ? m2.env.USERNAME : m2.env.USER,
    database: void 0,
    password: null,
    connectionString: void 0,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 3e4,
    client_encoding: "",
    ssl: false,
    application_name: void 0,
    fallback_application_name: void 0,
    options: void 0,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var Me = Xe(), Na = Me.getTypeParser(
    20,
    "text"
  ), Qa = Me.getTypeParser(1016, "text");
  Yt.exports.__defineSetter__("parseInt8", function(r2) {
    Me.setTypeParser(20, "text", r2 ? Me.getTypeParser(23, "text") : Na), Me.setTypeParser(1016, "text", r2 ? Me.getTypeParser(1007, "text") : Qa);
  });
});
var tt = I((Gh, Mi) => {
  "use strict";
  p3();
  var Wa = (qt(), k(Ut)), ja = et();
  function Ha(r2) {
    var e3 = r2.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + e3 + '"';
  }
  a(Ha, "escapeElement");
  function Fi(r2) {
    for (var e3 = "{", t2 = 0; t2 < r2.length; t2++)
      t2 > 0 && (e3 = e3 + ","), r2[t2] === null || typeof r2[t2] > "u" ? e3 = e3 + "NULL" : Array.isArray(r2[t2]) ? e3 = e3 + Fi(r2[t2]) : r2[t2] instanceof d3 ? e3 += "\\\\x" + r2[t2].toString("hex") : e3 += Ha(ft(r2[t2]));
    return e3 = e3 + "}", e3;
  }
  a(Fi, "arrayString");
  var ft = a(function(r2, e3) {
    if (r2 == null)
      return null;
    if (r2 instanceof d3)
      return r2;
    if (ArrayBuffer.isView(r2)) {
      var t2 = d3.from(r2.buffer, r2.byteOffset, r2.byteLength);
      return t2.length === r2.byteLength ? t2 : t2.slice(
        r2.byteOffset,
        r2.byteOffset + r2.byteLength
      );
    }
    return r2 instanceof Date ? ja.parseInputDatesAsUTC ? Ka(r2) : $a(r2) : Array.isArray(r2) ? Fi(r2) : typeof r2 == "object" ? Ga(r2, e3) : r2.toString();
  }, "prepareValue");
  function Ga(r2, e3) {
    if (r2 && typeof r2.toPostgres == "function") {
      if (e3 = e3 || [], e3.indexOf(r2) !== -1)
        throw new Error('circular reference detected while preparing "' + r2 + '" for query');
      return e3.push(r2), ft(r2.toPostgres(ft), e3);
    }
    return JSON.stringify(r2);
  }
  a(Ga, "prepareObject");
  function j2(r2, e3) {
    for (r2 = "" + r2; r2.length < e3; )
      r2 = "0" + r2;
    return r2;
  }
  a(
    j2,
    "pad"
  );
  function $a(r2) {
    var e3 = -r2.getTimezoneOffset(), t2 = r2.getFullYear(), n2 = t2 < 1;
    n2 && (t2 = Math.abs(t2) + 1);
    var i2 = j2(t2, 4) + "-" + j2(r2.getMonth() + 1, 2) + "-" + j2(r2.getDate(), 2) + "T" + j2(r2.getHours(), 2) + ":" + j2(r2.getMinutes(), 2) + ":" + j2(r2.getSeconds(), 2) + "." + j2(
      r2.getMilliseconds(),
      3
    );
    return e3 < 0 ? (i2 += "-", e3 *= -1) : i2 += "+", i2 += j2(Math.floor(e3 / 60), 2) + ":" + j2(e3 % 60, 2), n2 && (i2 += " BC"), i2;
  }
  a($a, "dateToString");
  function Ka(r2) {
    var e3 = r2.getUTCFullYear(), t2 = e3 < 1;
    t2 && (e3 = Math.abs(e3) + 1);
    var n2 = j2(e3, 4) + "-" + j2(r2.getUTCMonth() + 1, 2) + "-" + j2(r2.getUTCDate(), 2) + "T" + j2(r2.getUTCHours(), 2) + ":" + j2(r2.getUTCMinutes(), 2) + ":" + j2(r2.getUTCSeconds(), 2) + "." + j2(r2.getUTCMilliseconds(), 3);
    return n2 += "+00:00", t2 && (n2 += " BC"), n2;
  }
  a(Ka, "dateToStringUTC");
  function Va(r2, e3, t2) {
    return r2 = typeof r2 == "string" ? { text: r2 } : r2, e3 && (typeof e3 == "function" ? r2.callback = e3 : r2.values = e3), t2 && (r2.callback = t2), r2;
  }
  a(Va, "normalizeQueryConfig");
  var Zt = a(function(r2) {
    return Wa.createHash("md5").update(r2, "utf-8").digest("hex");
  }, "md5"), za = a(function(r2, e3, t2) {
    var n2 = Zt(e3 + r2), i2 = Zt(d3.concat([d3.from(n2), t2]));
    return "md5" + i2;
  }, "postgresMd5PasswordHash");
  Mi.exports = { prepareValue: a(function(e3) {
    return ft(
      e3
    );
  }, "prepareValueWrapper"), normalizeQueryConfig: Va, postgresMd5PasswordHash: za, md5: Zt };
});
var qi = I((Vh, Ui) => {
  "use strict";
  p3();
  var Jt = (qt(), k(Ut));
  function Ya(r2) {
    if (r2.indexOf(
      "SCRAM-SHA-256"
    ) === -1)
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    let e3 = Jt.randomBytes(18).toString("base64");
    return { mechanism: "SCRAM-SHA-256", clientNonce: e3, response: "n,,n=*,r=" + e3, message: "SASLInitialResponse" };
  }
  a(Ya, "startSession");
  function Za(r2, e3, t2) {
    if (r2.message !== "SASLInitialResponse")
      throw new Error(
        "SASL: Last message was not SASLInitialResponse"
      );
    if (typeof e3 != "string")
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string"
      );
    if (typeof t2 != "string")
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    let n2 = eu(t2);
    if (n2.nonce.startsWith(r2.clientNonce)) {
      if (n2.nonce.length === r2.clientNonce.length)
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    var i2 = d3.from(n2.salt, "base64"), s2 = nu(
      e3,
      i2,
      n2.iteration
    ), o2 = De(s2, "Client Key"), u2 = ru(o2), c3 = "n=*,r=" + r2.clientNonce, h2 = "r=" + n2.nonce + ",s=" + n2.salt + ",i=" + n2.iteration, l3 = "c=biws,r=" + n2.nonce, y2 = c3 + "," + h2 + "," + l3, E = De(u2, y2), _ = ki(
      o2,
      E
    ), P2 = _.toString("base64"), N = De(s2, "Server Key"), J = De(N, y2);
    r2.message = "SASLResponse", r2.serverSignature = J.toString("base64"), r2.response = l3 + ",p=" + P2;
  }
  a(Za, "continueSession");
  function Ja(r2, e3) {
    if (r2.message !== "SASLResponse")
      throw new Error("SASL: Last message was not SASLResponse");
    if (typeof e3 != "string")
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    let { serverSignature: t2 } = tu(
      e3
    );
    if (t2 !== r2.serverSignature)
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
  }
  a(Ja, "finalizeSession");
  function Xa(r2) {
    if (typeof r2 != "string")
      throw new TypeError("SASL: text must be a string");
    return r2.split("").map(
      (e3, t2) => r2.charCodeAt(t2)
    ).every((e3) => e3 >= 33 && e3 <= 43 || e3 >= 45 && e3 <= 126);
  }
  a(Xa, "isPrintableChars");
  function Di(r2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r2);
  }
  a(Di, "isBase64");
  function Oi(r2) {
    if (typeof r2 != "string")
      throw new TypeError(
        "SASL: attribute pairs text must be a string"
      );
    return new Map(r2.split(",").map((e3) => {
      if (!/^.=/.test(e3))
        throw new Error("SASL: Invalid attribute pair entry");
      let t2 = e3[0], n2 = e3.substring(2);
      return [t2, n2];
    }));
  }
  a(Oi, "parseAttributePairs");
  function eu(r2) {
    let e3 = Oi(
      r2
    ), t2 = e3.get("r");
    if (t2) {
      if (!Xa(t2))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    let n2 = e3.get("s");
    if (n2) {
      if (!Di(n2))
        throw new Error(
          "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64"
        );
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    let i2 = e3.get("i");
    if (i2) {
      if (!/^[1-9][0-9]*$/.test(i2))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    let s2 = parseInt(i2, 10);
    return { nonce: t2, salt: n2, iteration: s2 };
  }
  a(eu, "parseServerFirstMessage");
  function tu(r2) {
    let t2 = Oi(r2).get("v");
    if (t2) {
      if (!Di(t2))
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    } else
      throw new Error(
        "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing"
      );
    return { serverSignature: t2 };
  }
  a(tu, "parseServerFinalMessage");
  function ki(r2, e3) {
    if (!d3.isBuffer(r2))
      throw new TypeError(
        "first argument must be a Buffer"
      );
    if (!d3.isBuffer(e3))
      throw new TypeError("second argument must be a Buffer");
    if (r2.length !== e3.length)
      throw new Error("Buffer lengths must match");
    if (r2.length === 0)
      throw new Error("Buffers cannot be empty");
    return d3.from(r2.map((t2, n2) => r2[n2] ^ e3[n2]));
  }
  a(ki, "xorBuffers");
  function ru(r2) {
    return Jt.createHash(
      "sha256"
    ).update(r2).digest();
  }
  a(ru, "sha256");
  function De(r2, e3) {
    return Jt.createHmac(
      "sha256",
      r2
    ).update(e3).digest();
  }
  a(De, "hmacSha256");
  function nu(r2, e3, t2) {
    for (var n2 = De(
      r2,
      d3.concat([e3, d3.from([0, 0, 0, 1])])
    ), i2 = n2, s2 = 0; s2 < t2 - 1; s2++)
      n2 = De(r2, n2), i2 = ki(i2, n2);
    return i2;
  }
  a(nu, "Hi");
  Ui.exports = { startSession: Ya, continueSession: Za, finalizeSession: Ja };
});
var Xt = {};
X2(Xt, { join: () => iu });
function iu(...r2) {
  return r2.join("/");
}
var er = K2(() => {
  "use strict";
  p3();
  a(iu, "join");
});
var tr = {};
X2(tr, { stat: () => su });
function su(r2, e3) {
  e3(new Error("No filesystem"));
}
var rr = K2(
  () => {
    "use strict";
    p3();
    a(su, "stat");
  }
);
var nr = {};
X2(nr, { default: () => ou });
var ou;
var ir = K2(() => {
  "use strict";
  p3();
  ou = {};
});
var Ni = {};
X2(Ni, { StringDecoder: () => sr });
var or;
var sr;
var Qi = K2(() => {
  "use strict";
  p3();
  or = class or {
    constructor(e3) {
      T(this, "td");
      this.td = new TextDecoder(e3);
    }
    write(e3) {
      return this.td.decode(e3, { stream: true });
    }
    end(e3) {
      return this.td.decode(e3);
    }
  };
  a(or, "StringDecoder");
  sr = or;
});
var Gi = I((il, Hi) => {
  "use strict";
  p3();
  var { Transform: au } = (ir(), k(nr)), { StringDecoder: uu } = (Qi(), k(Ni)), we = Symbol("last"), pt = Symbol("decoder");
  function cu(r2, e3, t2) {
    let n2;
    if (this.overflow) {
      if (n2 = this[pt].write(r2).split(this.matcher), n2.length === 1)
        return t2();
      n2.shift(), this.overflow = false;
    } else
      this[we] += this[pt].write(r2), n2 = this[we].split(this.matcher);
    this[we] = n2.pop();
    for (let i2 = 0; i2 < n2.length; i2++)
      try {
        ji(this, this.mapper(n2[i2]));
      } catch (s2) {
        return t2(
          s2
        );
      }
    if (this.overflow = this[we].length > this.maxLength, this.overflow && !this.skipOverflow) {
      t2(new Error("maximum buffer reached"));
      return;
    }
    t2();
  }
  a(cu, "transform");
  function hu(r2) {
    if (this[we] += this[pt].end(), this[we])
      try {
        ji(this, this.mapper(this[we]));
      } catch (e3) {
        return r2(e3);
      }
    r2();
  }
  a(hu, "flush");
  function ji(r2, e3) {
    e3 !== void 0 && r2.push(e3);
  }
  a(ji, "push");
  function Wi(r2) {
    return r2;
  }
  a(Wi, "noop");
  function lu(r2, e3, t2) {
    switch (r2 = r2 || /\r?\n/, e3 = e3 || Wi, t2 = t2 || {}, arguments.length) {
      case 1:
        typeof r2 == "function" ? (e3 = r2, r2 = /\r?\n/) : typeof r2 == "object" && !(r2 instanceof RegExp) && !r2[Symbol.split] && (t2 = r2, r2 = /\r?\n/);
        break;
      case 2:
        typeof r2 == "function" ? (t2 = e3, e3 = r2, r2 = /\r?\n/) : typeof e3 == "object" && (t2 = e3, e3 = Wi);
    }
    t2 = Object.assign({}, t2), t2.autoDestroy = true, t2.transform = cu, t2.flush = hu, t2.readableObjectMode = true;
    let n2 = new au(t2);
    return n2[we] = "", n2[pt] = new uu("utf8"), n2.matcher = r2, n2.mapper = e3, n2.maxLength = t2.maxLength, n2.skipOverflow = t2.skipOverflow || false, n2.overflow = false, n2._destroy = function(i2, s2) {
      this._writableState.errorEmitted = false, s2(i2);
    }, n2;
  }
  a(lu, "split");
  Hi.exports = lu;
});
var Vi = I((al, fe) => {
  "use strict";
  p3();
  var $i = (er(), k(Xt)), fu = (ir(), k(nr)).Stream, pu = Gi(), Ki = (Ge(), k(He)), du = 5432, dt = m2.platform === "win32", rt = m2.stderr, yu = 56, mu = 7, gu = 61440, wu = 32768;
  function bu(r2) {
    return (r2 & gu) == wu;
  }
  a(bu, "isRegFile");
  var Oe = [
    "host",
    "port",
    "database",
    "user",
    "password"
  ], ar = Oe.length, Su = Oe[ar - 1];
  function ur() {
    var r2 = rt instanceof fu && rt.writable === true;
    if (r2) {
      var e3 = Array.prototype.slice.call(arguments).concat(`
`);
      rt.write(Ki.format.apply(Ki, e3));
    }
  }
  a(ur, "warn");
  Object.defineProperty(
    fe.exports,
    "isWin",
    { get: function() {
      return dt;
    }, set: function(r2) {
      dt = r2;
    } }
  );
  fe.exports.warnTo = function(r2) {
    var e3 = rt;
    return rt = r2, e3;
  };
  fe.exports.getFileName = function(r2) {
    var e3 = r2 || m2.env, t2 = e3.PGPASSFILE || (dt ? $i.join(e3.APPDATA || "./", "postgresql", "pgpass.conf") : $i.join(e3.HOME || "./", ".pgpass"));
    return t2;
  };
  fe.exports.usePgPass = function(r2, e3) {
    return Object.prototype.hasOwnProperty.call(m2.env, "PGPASSWORD") ? false : dt ? true : (e3 = e3 || "<unkn>", bu(r2.mode) ? r2.mode & (yu | mu) ? (ur('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', e3), false) : true : (ur(
      'WARNING: password file "%s" is not a plain file',
      e3
    ), false));
  };
  var xu = fe.exports.match = function(r2, e3) {
    return Oe.slice(0, -1).reduce(
      function(t2, n2, i2) {
        return i2 == 1 && Number(r2[n2] || du) === Number(e3[n2]) ? t2 && true : t2 && (e3[n2] === "*" || e3[n2] === r2[n2]);
      },
      true
    );
  };
  fe.exports.getPassword = function(r2, e3, t2) {
    var n2, i2 = e3.pipe(pu());
    function s2(c3) {
      var h2 = Eu(
        c3
      );
      h2 && vu(h2) && xu(r2, h2) && (n2 = h2[Su], i2.end());
    }
    a(s2, "onLine");
    var o2 = a(function() {
      e3.destroy(), t2(n2);
    }, "onEnd"), u2 = a(function(c3) {
      e3.destroy(), ur("WARNING: error on reading file: %s", c3), t2(void 0);
    }, "onErr");
    e3.on("error", u2), i2.on("data", s2).on("end", o2).on(
      "error",
      u2
    );
  };
  var Eu = fe.exports.parseLine = function(r2) {
    if (r2.length < 11 || r2.match(/^\s+#/))
      return null;
    for (var e3 = "", t2 = "", n2 = 0, i2 = 0, s2 = 0, o2 = {}, u2 = false, c3 = a(function(l3, y2, E) {
      var _ = r2.substring(
        y2,
        E
      );
      Object.hasOwnProperty.call(m2.env, "PGPASS_NO_DEESCAPE") || (_ = _.replace(
        /\\([:\\])/g,
        "$1"
      )), o2[Oe[l3]] = _;
    }, "addToObj"), h2 = 0; h2 < r2.length - 1; h2 += 1) {
      if (e3 = r2.charAt(h2 + 1), t2 = r2.charAt(
        h2
      ), u2 = n2 == ar - 1, u2) {
        c3(n2, i2);
        break;
      }
      h2 >= 0 && e3 == ":" && t2 !== "\\" && (c3(n2, i2, h2 + 1), i2 = h2 + 2, n2 += 1);
    }
    return o2 = Object.keys(o2).length === ar ? o2 : null, o2;
  }, vu = fe.exports.isValidEntry = function(r2) {
    for (var e3 = {
      0: function(o2) {
        return o2.length > 0;
      },
      1: function(o2) {
        return o2 === "*" ? true : (o2 = Number(o2), isFinite(
          o2
        ) && o2 > 0 && o2 < 9007199254740992 && Math.floor(o2) === o2);
      },
      2: function(o2) {
        return o2.length > 0;
      },
      3: function(o2) {
        return o2.length > 0;
      },
      4: function(o2) {
        return o2.length > 0;
      }
    }, t2 = 0; t2 < Oe.length; t2 += 1) {
      var n2 = e3[t2], i2 = r2[Oe[t2]] || "", s2 = n2(i2);
      if (!s2)
        return false;
    }
    return true;
  };
});
var Yi = I((ll, cr) => {
  "use strict";
  p3();
  var hl = (er(), k(Xt)), zi = (rr(), k(tr)), yt = Vi();
  cr.exports = function(r2, e3) {
    var t2 = yt.getFileName();
    zi.stat(t2, function(n2, i2) {
      if (n2 || !yt.usePgPass(i2, t2))
        return e3(void 0);
      var s2 = zi.createReadStream(t2);
      yt.getPassword(
        r2,
        s2,
        e3
      );
    });
  };
  cr.exports.warnTo = yt.warnTo;
});
var hr = I((pl, Zi) => {
  "use strict";
  p3();
  var _u = Xe();
  function mt(r2) {
    this._types = r2 || _u, this.text = {}, this.binary = {};
  }
  a(mt, "TypeOverrides");
  mt.prototype.getOverrides = function(r2) {
    switch (r2) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  mt.prototype.setTypeParser = function(r2, e3, t2) {
    typeof e3 == "function" && (t2 = e3, e3 = "text"), this.getOverrides(e3)[r2] = t2;
  };
  mt.prototype.getTypeParser = function(r2, e3) {
    return e3 = e3 || "text", this.getOverrides(e3)[r2] || this._types.getTypeParser(r2, e3);
  };
  Zi.exports = mt;
});
var Ji = {};
X2(Ji, { default: () => Au });
var Au;
var Xi = K2(() => {
  "use strict";
  p3();
  Au = {};
});
var es = {};
X2(es, { parse: () => lr });
function lr(r2, e3 = false) {
  let { protocol: t2 } = new URL(r2), n2 = "http:" + r2.substring(t2.length), {
    username: i2,
    password: s2,
    host: o2,
    hostname: u2,
    port: c3,
    pathname: h2,
    search: l3,
    searchParams: y2,
    hash: E
  } = new URL(n2);
  s2 = decodeURIComponent(s2);
  let _ = i2 + ":" + s2, P2 = e3 ? Object.fromEntries(y2.entries()) : l3;
  return {
    href: r2,
    protocol: t2,
    auth: _,
    username: i2,
    password: s2,
    host: o2,
    hostname: u2,
    port: c3,
    pathname: h2,
    search: l3,
    query: P2,
    hash: E
  };
}
var fr = K2(
  () => {
    "use strict";
    p3();
    a(lr, "parse");
  }
);
var rs = I((bl, ts) => {
  "use strict";
  p3();
  var Cu = (fr(), k(es)), pr = (rr(), k(tr));
  function dr(r2) {
    if (r2.charAt(0) === "/") {
      var t2 = r2.split(" ");
      return { host: t2[0], database: t2[1] };
    }
    var e3 = Cu.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r2) ? encodeURI(r2).replace(
      /\%25(\d\d)/g,
      "%$1"
    ) : r2, true), t2 = e3.query;
    for (var n2 in t2)
      Array.isArray(t2[n2]) && (t2[n2] = t2[n2][t2[n2].length - 1]);
    var i2 = (e3.auth || ":").split(":");
    if (t2.user = i2[0], t2.password = i2.splice(1).join(":"), t2.port = e3.port, e3.protocol == "socket:")
      return t2.host = decodeURI(e3.pathname), t2.database = e3.query.db, t2.client_encoding = e3.query.encoding, t2;
    t2.host || (t2.host = e3.hostname);
    var s2 = e3.pathname;
    if (!t2.host && s2 && /^%2f/i.test(s2)) {
      var o2 = s2.split("/");
      t2.host = decodeURIComponent(
        o2[0]
      ), s2 = o2.splice(1).join("/");
    }
    switch (s2 && s2.charAt(0) === "/" && (s2 = s2.slice(1) || null), t2.database = s2 && decodeURI(s2), (t2.ssl === "true" || t2.ssl === "1") && (t2.ssl = true), t2.ssl === "0" && (t2.ssl = false), (t2.sslcert || t2.sslkey || t2.sslrootcert || t2.sslmode) && (t2.ssl = {}), t2.sslcert && (t2.ssl.cert = pr.readFileSync(t2.sslcert).toString()), t2.sslkey && (t2.ssl.key = pr.readFileSync(
      t2.sslkey
    ).toString()), t2.sslrootcert && (t2.ssl.ca = pr.readFileSync(t2.sslrootcert).toString()), t2.sslmode) {
      case "disable": {
        t2.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        break;
      case "no-verify": {
        t2.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return t2;
  }
  a(dr, "parse");
  ts.exports = dr;
  dr.parse = dr;
});
var gt = I((El, ss) => {
  "use strict";
  p3();
  var Iu = (Xi(), k(Ji)), is4 = et(), ns = rs().parse, V = a(
    function(r2, e3, t2) {
      return t2 === void 0 ? t2 = m2.env["PG" + r2.toUpperCase()] : t2 === false || (t2 = m2.env[t2]), e3[r2] || t2 || is4[r2];
    },
    "val"
  ), Tu = a(function() {
    switch (m2.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return is4.ssl;
  }, "readSSLConfigFromEnvironment"), ke = a(
    function(r2) {
      return "'" + ("" + r2).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    },
    "quoteParamValue"
  ), re = a(function(r2, e3, t2) {
    var n2 = e3[t2];
    n2 != null && r2.push(t2 + "=" + ke(n2));
  }, "add"), mr = class mr {
    constructor(e3) {
      e3 = typeof e3 == "string" ? ns(e3) : e3 || {}, e3.connectionString && (e3 = Object.assign({}, e3, ns(e3.connectionString))), this.user = V("user", e3), this.database = V("database", e3), this.database === void 0 && (this.database = this.user), this.port = parseInt(
        V("port", e3),
        10
      ), this.host = V("host", e3), Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: V("password", e3)
      }), this.binary = V("binary", e3), this.options = V("options", e3), this.ssl = typeof e3.ssl > "u" ? Tu() : e3.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = true), this.ssl === "no-verify" && (this.ssl = { rejectUnauthorized: false }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this.client_encoding = V("client_encoding", e3), this.replication = V("replication", e3), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = V("application_name", e3, "PGAPPNAME"), this.fallback_application_name = V("fallback_application_name", e3, false), this.statement_timeout = V("statement_timeout", e3, false), this.lock_timeout = V(
        "lock_timeout",
        e3,
        false
      ), this.idle_in_transaction_session_timeout = V("idle_in_transaction_session_timeout", e3, false), this.query_timeout = V("query_timeout", e3, false), e3.connectionTimeoutMillis === void 0 ? this.connect_timeout = m2.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e3.connectionTimeoutMillis / 1e3), e3.keepAlive === false ? this.keepalives = 0 : e3.keepAlive === true && (this.keepalives = 1), typeof e3.keepAliveInitialDelayMillis == "number" && (this.keepalives_idle = Math.floor(e3.keepAliveInitialDelayMillis / 1e3));
    }
    getLibpqConnectionString(e3) {
      var t2 = [];
      re(t2, this, "user"), re(t2, this, "password"), re(t2, this, "port"), re(t2, this, "application_name"), re(t2, this, "fallback_application_name"), re(t2, this, "connect_timeout"), re(
        t2,
        this,
        "options"
      );
      var n2 = typeof this.ssl == "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      if (re(t2, n2, "sslmode"), re(t2, n2, "sslca"), re(t2, n2, "sslkey"), re(t2, n2, "sslcert"), re(t2, n2, "sslrootcert"), this.database && t2.push("dbname=" + ke(this.database)), this.replication && t2.push("replication=" + ke(this.replication)), this.host && t2.push("host=" + ke(this.host)), this.isDomainSocket)
        return e3(null, t2.join(" "));
      this.client_encoding && t2.push("client_encoding=" + ke(this.client_encoding)), Iu.lookup(this.host, function(i2, s2) {
        return i2 ? e3(i2, null) : (t2.push("hostaddr=" + ke(s2)), e3(null, t2.join(" ")));
      });
    }
  };
  a(mr, "ConnectionParameters");
  var yr = mr;
  ss.exports = yr;
});
var us = I((Al, as) => {
  "use strict";
  p3();
  var Pu = Xe(), os = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, wr = class wr {
    constructor(e3, t2) {
      this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t2, this.RowCtor = null, this.rowAsArray = e3 === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
    }
    addCommandComplete(e3) {
      var t2;
      e3.text ? t2 = os.exec(e3.text) : t2 = os.exec(e3.command), t2 && (this.command = t2[1], t2[3] ? (this.oid = parseInt(t2[2], 10), this.rowCount = parseInt(t2[3], 10)) : t2[2] && (this.rowCount = parseInt(
        t2[2],
        10
      )));
    }
    _parseRowAsArray(e3) {
      for (var t2 = new Array(e3.length), n2 = 0, i2 = e3.length; n2 < i2; n2++) {
        var s2 = e3[n2];
        s2 !== null ? t2[n2] = this._parsers[n2](s2) : t2[n2] = null;
      }
      return t2;
    }
    parseRow(e3) {
      for (var t2 = {}, n2 = 0, i2 = e3.length; n2 < i2; n2++) {
        var s2 = e3[n2], o2 = this.fields[n2].name;
        s2 !== null ? t2[o2] = this._parsers[n2](
          s2
        ) : t2[o2] = null;
      }
      return t2;
    }
    addRow(e3) {
      this.rows.push(e3);
    }
    addFields(e3) {
      this.fields = e3, this.fields.length && (this._parsers = new Array(e3.length));
      for (var t2 = 0; t2 < e3.length; t2++) {
        var n2 = e3[t2];
        this._types ? this._parsers[t2] = this._types.getTypeParser(n2.dataTypeID, n2.format || "text") : this._parsers[t2] = Pu.getTypeParser(n2.dataTypeID, n2.format || "text");
      }
    }
  };
  a(wr, "Result");
  var gr = wr;
  as.exports = gr;
});
var fs = I((Tl, ls) => {
  "use strict";
  p3();
  var { EventEmitter: Bu } = ge(), cs = us(), hs = tt(), Sr = class Sr extends Bu {
    constructor(e3, t2, n2) {
      super(), e3 = hs.normalizeQueryConfig(e3, t2, n2), this.text = e3.text, this.values = e3.values, this.rows = e3.rows, this.types = e3.types, this.name = e3.name, this.binary = e3.binary, this.portal = e3.portal || "", this.callback = e3.callback, this._rowMode = e3.rowMode, m2.domain && e3.callback && (this.callback = m2.domain.bind(e3.callback)), this._result = new cs(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = false, this._canceledDueToError = false, this._promise = null;
    }
    requiresPreparation() {
      return this.name || this.rows ? true : !this.text || !this.values ? false : this.values.length > 0;
    }
    _checkForMultirow() {
      this._result.command && (Array.isArray(this._results) || (this._results = [this._result]), this._result = new cs(
        this._rowMode,
        this.types
      ), this._results.push(this._result));
    }
    handleRowDescription(e3) {
      this._checkForMultirow(), this._result.addFields(e3.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(e3) {
      let t2;
      if (!this._canceledDueToError) {
        try {
          t2 = this._result.parseRow(e3.fields);
        } catch (n2) {
          this._canceledDueToError = n2;
          return;
        }
        this.emit("row", t2, this._result), this._accumulateRows && this._result.addRow(t2);
      }
    }
    handleCommandComplete(e3, t2) {
      this._checkForMultirow(), this._result.addCommandComplete(e3), this.rows && t2.sync();
    }
    handleEmptyQuery(e3) {
      this.rows && e3.sync();
    }
    handleError(e3, t2) {
      if (this._canceledDueToError && (e3 = this._canceledDueToError, this._canceledDueToError = false), this.callback)
        return this.callback(e3);
      this.emit("error", e3);
    }
    handleReadyForQuery(e3) {
      if (this._canceledDueToError)
        return this.handleError(
          this._canceledDueToError,
          e3
        );
      if (this.callback)
        try {
          this.callback(null, this._results);
        } catch (t2) {
          m2.nextTick(() => {
            throw t2;
          });
        }
      this.emit("end", this._results);
    }
    submit(e3) {
      if (typeof this.text != "string" && typeof this.name != "string")
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      let t2 = e3.parsedStatements[this.name];
      return this.text && t2 && this.text !== t2 ? new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query values must be an array") : (this.requiresPreparation() ? this.prepare(e3) : e3.query(this.text), null);
    }
    hasBeenParsed(e3) {
      return this.name && e3.parsedStatements[this.name];
    }
    handlePortalSuspended(e3) {
      this._getRows(e3, this.rows);
    }
    _getRows(e3, t2) {
      e3.execute(
        { portal: this.portal, rows: t2 }
      ), t2 ? e3.flush() : e3.sync();
    }
    prepare(e3) {
      this.isPreparedStatement = true, this.hasBeenParsed(e3) || e3.parse({ text: this.text, name: this.name, types: this.types });
      try {
        e3.bind({ portal: this.portal, statement: this.name, values: this.values, binary: this.binary, valueMapper: hs.prepareValue });
      } catch (t2) {
        this.handleError(t2, e3);
        return;
      }
      e3.describe(
        { type: "P", name: this.portal || "" }
      ), this._getRows(e3, this.rows);
    }
    handleCopyInResponse(e3) {
      e3.sendCopyFail("No source stream defined");
    }
    handleCopyData(e3, t2) {
    }
  };
  a(Sr, "Query");
  var br = Sr;
  ls.exports = br;
});
var ds = {};
X2(ds, { Socket: () => _e, isIP: () => Lu });
function Lu(r2) {
  return 0;
}
var ps;
var x;
var _e;
var wt = K2(() => {
  "use strict";
  p3();
  ps = We(ge(), 1);
  a(Lu, "isIP");
  x = class x2 extends ps.EventEmitter {
    constructor() {
      super(...arguments);
      T(this, "opts", {});
      T(this, "connecting", false);
      T(this, "pending", true);
      T(this, "writable", true);
      T(this, "encrypted", false);
      T(this, "authorized", false);
      T(this, "destroyed", false);
      T(this, "ws", null);
      T(this, "writeBuffer");
      T(this, "tlsState", 0);
      T(
        this,
        "tlsRead"
      );
      T(this, "tlsWrite");
    }
    static get poolQueryViaFetch() {
      return x2.opts.poolQueryViaFetch ?? x2.defaults.poolQueryViaFetch;
    }
    static set poolQueryViaFetch(t2) {
      x2.opts.poolQueryViaFetch = t2;
    }
    static get fetchEndpoint() {
      return x2.opts.fetchEndpoint ?? x2.defaults.fetchEndpoint;
    }
    static set fetchEndpoint(t2) {
      x2.opts.fetchEndpoint = t2;
    }
    static get fetchConnectionCache() {
      return x2.opts.fetchConnectionCache ?? x2.defaults.fetchConnectionCache;
    }
    static set fetchConnectionCache(t2) {
      x2.opts.fetchConnectionCache = t2;
    }
    static get fetchFunction() {
      return x2.opts.fetchFunction ?? x2.defaults.fetchFunction;
    }
    static set fetchFunction(t2) {
      x2.opts.fetchFunction = t2;
    }
    static get webSocketConstructor() {
      return x2.opts.webSocketConstructor ?? x2.defaults.webSocketConstructor;
    }
    static set webSocketConstructor(t2) {
      x2.opts.webSocketConstructor = t2;
    }
    get webSocketConstructor() {
      return this.opts.webSocketConstructor ?? x2.webSocketConstructor;
    }
    set webSocketConstructor(t2) {
      this.opts.webSocketConstructor = t2;
    }
    static get wsProxy() {
      return x2.opts.wsProxy ?? x2.defaults.wsProxy;
    }
    static set wsProxy(t2) {
      x2.opts.wsProxy = t2;
    }
    get wsProxy() {
      return this.opts.wsProxy ?? x2.wsProxy;
    }
    set wsProxy(t2) {
      this.opts.wsProxy = t2;
    }
    static get coalesceWrites() {
      return x2.opts.coalesceWrites ?? x2.defaults.coalesceWrites;
    }
    static set coalesceWrites(t2) {
      x2.opts.coalesceWrites = t2;
    }
    get coalesceWrites() {
      return this.opts.coalesceWrites ?? x2.coalesceWrites;
    }
    set coalesceWrites(t2) {
      this.opts.coalesceWrites = t2;
    }
    static get useSecureWebSocket() {
      return x2.opts.useSecureWebSocket ?? x2.defaults.useSecureWebSocket;
    }
    static set useSecureWebSocket(t2) {
      x2.opts.useSecureWebSocket = t2;
    }
    get useSecureWebSocket() {
      return this.opts.useSecureWebSocket ?? x2.useSecureWebSocket;
    }
    set useSecureWebSocket(t2) {
      this.opts.useSecureWebSocket = t2;
    }
    static get forceDisablePgSSL() {
      return x2.opts.forceDisablePgSSL ?? x2.defaults.forceDisablePgSSL;
    }
    static set forceDisablePgSSL(t2) {
      x2.opts.forceDisablePgSSL = t2;
    }
    get forceDisablePgSSL() {
      return this.opts.forceDisablePgSSL ?? x2.forceDisablePgSSL;
    }
    set forceDisablePgSSL(t2) {
      this.opts.forceDisablePgSSL = t2;
    }
    static get disableSNI() {
      return x2.opts.disableSNI ?? x2.defaults.disableSNI;
    }
    static set disableSNI(t2) {
      x2.opts.disableSNI = t2;
    }
    get disableSNI() {
      return this.opts.disableSNI ?? x2.disableSNI;
    }
    set disableSNI(t2) {
      this.opts.disableSNI = t2;
    }
    static get pipelineConnect() {
      return x2.opts.pipelineConnect ?? x2.defaults.pipelineConnect;
    }
    static set pipelineConnect(t2) {
      x2.opts.pipelineConnect = t2;
    }
    get pipelineConnect() {
      return this.opts.pipelineConnect ?? x2.pipelineConnect;
    }
    set pipelineConnect(t2) {
      this.opts.pipelineConnect = t2;
    }
    static get subtls() {
      return x2.opts.subtls ?? x2.defaults.subtls;
    }
    static set subtls(t2) {
      x2.opts.subtls = t2;
    }
    get subtls() {
      return this.opts.subtls ?? x2.subtls;
    }
    set subtls(t2) {
      this.opts.subtls = t2;
    }
    static get pipelineTLS() {
      return x2.opts.pipelineTLS ?? x2.defaults.pipelineTLS;
    }
    static set pipelineTLS(t2) {
      x2.opts.pipelineTLS = t2;
    }
    get pipelineTLS() {
      return this.opts.pipelineTLS ?? x2.pipelineTLS;
    }
    set pipelineTLS(t2) {
      this.opts.pipelineTLS = t2;
    }
    static get rootCerts() {
      return x2.opts.rootCerts ?? x2.defaults.rootCerts;
    }
    static set rootCerts(t2) {
      x2.opts.rootCerts = t2;
    }
    get rootCerts() {
      return this.opts.rootCerts ?? x2.rootCerts;
    }
    set rootCerts(t2) {
      this.opts.rootCerts = t2;
    }
    wsProxyAddrForHost(t2, n2) {
      let i2 = this.wsProxy;
      if (i2 === void 0)
        throw new Error("No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string");
      return typeof i2 == "function" ? i2(t2, n2) : `${i2}?address=${t2}:${n2}`;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    connect(t2, n2, i2) {
      this.connecting = true, i2 && this.once("connect", i2);
      let s2 = a(() => {
        this.connecting = false, this.pending = false, this.emit("connect"), this.emit("ready");
      }, "handleWebSocketOpen"), o2 = a((c3, h2 = false) => {
        c3.binaryType = "arraybuffer", c3.addEventListener("error", (l3) => {
          this.emit("error", l3), this.emit("close");
        }), c3.addEventListener("message", (l3) => {
          if (this.tlsState === 0) {
            let y2 = d3.from(l3.data);
            this.emit(
              "data",
              y2
            );
          }
        }), c3.addEventListener("close", () => {
          this.emit("close");
        }), h2 ? s2() : c3.addEventListener(
          "open",
          s2
        );
      }, "configureWebSocket"), u2;
      try {
        u2 = this.wsProxyAddrForHost(n2, typeof t2 == "string" ? parseInt(t2, 10) : t2);
      } catch (c3) {
        this.emit("error", c3), this.emit("close");
        return;
      }
      try {
        let h2 = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u2;
        if (this.webSocketConstructor !== void 0)
          this.ws = new this.webSocketConstructor(h2), o2(this.ws);
        else
          try {
            this.ws = new WebSocket(
              h2
            ), o2(this.ws);
          } catch {
            this.ws = new __unstable_WebSocket(h2), o2(this.ws);
          }
      } catch (c3) {
        let l3 = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u2;
        fetch(l3, { headers: { Upgrade: "websocket" } }).then((y2) => {
          if (this.ws = y2.webSocket, this.ws == null)
            throw c3;
          this.ws.accept(), o2(
            this.ws,
            true
          );
        }).catch((y2) => {
          this.emit("error", new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websocket--undefined. Details: ${y2.message}`)), this.emit("close");
        });
      }
    }
    async startTls(t2) {
      if (this.subtls === void 0)
        throw new Error("For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information.");
      this.tlsState = 1;
      let n2 = this.subtls.TrustedCert.fromPEM(this.rootCerts), i2 = new this.subtls.WebSocketReadQueue(this.ws), s2 = i2.read.bind(
        i2
      ), o2 = this.rawWrite.bind(this), [u2, c3] = await this.subtls.startTls(t2, n2, s2, o2, { useSNI: !this.disableSNI, expectPreData: this.pipelineTLS ? new Uint8Array([83]) : void 0 });
      this.tlsRead = u2, this.tlsWrite = c3, this.tlsState = 2, this.encrypted = true, this.authorized = true, this.emit(
        "secureConnection",
        this
      ), this.tlsReadLoop();
    }
    async tlsReadLoop() {
      for (; ; ) {
        let t2 = await this.tlsRead();
        if (t2 === void 0)
          break;
        {
          let n2 = d3.from(t2);
          this.emit("data", n2);
        }
      }
    }
    rawWrite(t2) {
      if (!this.coalesceWrites) {
        this.ws.send(t2);
        return;
      }
      if (this.writeBuffer === void 0)
        this.writeBuffer = t2, setTimeout(
          () => {
            this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
          },
          0
        );
      else {
        let n2 = new Uint8Array(this.writeBuffer.length + t2.length);
        n2.set(this.writeBuffer), n2.set(t2, this.writeBuffer.length), this.writeBuffer = n2;
      }
    }
    write(t2, n2 = "utf8", i2 = (s2) => {
    }) {
      return t2.length === 0 ? (i2(), true) : (typeof t2 == "string" && (t2 = d3.from(t2, n2)), this.tlsState === 0 ? (this.rawWrite(t2), i2()) : this.tlsState === 1 ? this.once("secureConnection", () => {
        this.write(
          t2,
          n2,
          i2
        );
      }) : (this.tlsWrite(t2), i2()), true);
    }
    end(t2 = d3.alloc(0), n2 = "utf8", i2 = () => {
    }) {
      return this.write(t2, n2, () => {
        this.ws.close(), i2();
      }), this;
    }
    destroy() {
      return this.destroyed = true, this.end();
    }
  };
  a(x, "Socket"), T(x, "defaults", {
    poolQueryViaFetch: false,
    fetchEndpoint: (t2) => "https://" + t2 + "/sql",
    fetchConnectionCache: false,
    fetchFunction: void 0,
    webSocketConstructor: void 0,
    wsProxy: (t2) => t2 + "/v2",
    useSecureWebSocket: true,
    forceDisablePgSSL: true,
    coalesceWrites: true,
    pipelineConnect: "password",
    subtls: void 0,
    rootCerts: "",
    pipelineTLS: false,
    disableSNI: false
  }), T(x, "opts", {});
  _e = x;
});
var zr = I((C) => {
  "use strict";
  p3();
  Object.defineProperty(C, "__esModule", { value: true });
  C.NoticeMessage = C.DataRowMessage = C.CommandCompleteMessage = C.ReadyForQueryMessage = C.NotificationResponseMessage = C.BackendKeyDataMessage = C.AuthenticationMD5Password = C.ParameterStatusMessage = C.ParameterDescriptionMessage = C.RowDescriptionMessage = C.Field = C.CopyResponse = C.CopyDataMessage = C.DatabaseError = C.copyDone = C.emptyQuery = C.replicationStart = C.portalSuspended = C.noData = C.closeComplete = C.bindComplete = C.parseComplete = void 0;
  C.parseComplete = { name: "parseComplete", length: 5 };
  C.bindComplete = { name: "bindComplete", length: 5 };
  C.closeComplete = { name: "closeComplete", length: 5 };
  C.noData = { name: "noData", length: 5 };
  C.portalSuspended = { name: "portalSuspended", length: 5 };
  C.replicationStart = { name: "replicationStart", length: 4 };
  C.emptyQuery = { name: "emptyQuery", length: 4 };
  C.copyDone = { name: "copyDone", length: 4 };
  var Dr = class Dr extends Error {
    constructor(e3, t2, n2) {
      super(
        e3
      ), this.length = t2, this.name = n2;
    }
  };
  a(Dr, "DatabaseError");
  var xr = Dr;
  C.DatabaseError = xr;
  var Or = class Or {
    constructor(e3, t2) {
      this.length = e3, this.chunk = t2, this.name = "copyData";
    }
  };
  a(Or, "CopyDataMessage");
  var Er = Or;
  C.CopyDataMessage = Er;
  var kr = class kr {
    constructor(e3, t2, n2, i2) {
      this.length = e3, this.name = t2, this.binary = n2, this.columnTypes = new Array(i2);
    }
  };
  a(kr, "CopyResponse");
  var vr = kr;
  C.CopyResponse = vr;
  var Ur = class Ur {
    constructor(e3, t2, n2, i2, s2, o2, u2) {
      this.name = e3, this.tableID = t2, this.columnID = n2, this.dataTypeID = i2, this.dataTypeSize = s2, this.dataTypeModifier = o2, this.format = u2;
    }
  };
  a(Ur, "Field");
  var _r = Ur;
  C.Field = _r;
  var qr = class qr {
    constructor(e3, t2) {
      this.length = e3, this.fieldCount = t2, this.name = "rowDescription", this.fields = new Array(
        this.fieldCount
      );
    }
  };
  a(qr, "RowDescriptionMessage");
  var Ar = qr;
  C.RowDescriptionMessage = Ar;
  var Nr = class Nr {
    constructor(e3, t2) {
      this.length = e3, this.parameterCount = t2, this.name = "parameterDescription", this.dataTypeIDs = new Array(this.parameterCount);
    }
  };
  a(Nr, "ParameterDescriptionMessage");
  var Cr = Nr;
  C.ParameterDescriptionMessage = Cr;
  var Qr = class Qr {
    constructor(e3, t2, n2) {
      this.length = e3, this.parameterName = t2, this.parameterValue = n2, this.name = "parameterStatus";
    }
  };
  a(Qr, "ParameterStatusMessage");
  var Ir = Qr;
  C.ParameterStatusMessage = Ir;
  var Wr = class Wr {
    constructor(e3, t2) {
      this.length = e3, this.salt = t2, this.name = "authenticationMD5Password";
    }
  };
  a(Wr, "AuthenticationMD5Password");
  var Tr = Wr;
  C.AuthenticationMD5Password = Tr;
  var jr = class jr {
    constructor(e3, t2, n2) {
      this.length = e3, this.processID = t2, this.secretKey = n2, this.name = "backendKeyData";
    }
  };
  a(
    jr,
    "BackendKeyDataMessage"
  );
  var Pr = jr;
  C.BackendKeyDataMessage = Pr;
  var Hr = class Hr {
    constructor(e3, t2, n2, i2) {
      this.length = e3, this.processId = t2, this.channel = n2, this.payload = i2, this.name = "notification";
    }
  };
  a(Hr, "NotificationResponseMessage");
  var Br = Hr;
  C.NotificationResponseMessage = Br;
  var Gr = class Gr {
    constructor(e3, t2) {
      this.length = e3, this.status = t2, this.name = "readyForQuery";
    }
  };
  a(Gr, "ReadyForQueryMessage");
  var Lr = Gr;
  C.ReadyForQueryMessage = Lr;
  var $r = class $r {
    constructor(e3, t2) {
      this.length = e3, this.text = t2, this.name = "commandComplete";
    }
  };
  a($r, "CommandCompleteMessage");
  var Rr = $r;
  C.CommandCompleteMessage = Rr;
  var Kr = class Kr {
    constructor(e3, t2) {
      this.length = e3, this.fields = t2, this.name = "dataRow", this.fieldCount = t2.length;
    }
  };
  a(Kr, "DataRowMessage");
  var Fr = Kr;
  C.DataRowMessage = Fr;
  var Vr = class Vr {
    constructor(e3, t2) {
      this.length = e3, this.message = t2, this.name = "notice";
    }
  };
  a(Vr, "NoticeMessage");
  var Mr = Vr;
  C.NoticeMessage = Mr;
});
var ys = I((bt) => {
  "use strict";
  p3();
  Object.defineProperty(bt, "__esModule", { value: true });
  bt.Writer = void 0;
  var Zr = class Zr {
    constructor(e3 = 256) {
      this.size = e3, this.offset = 5, this.headerPosition = 0, this.buffer = d3.allocUnsafe(e3);
    }
    ensure(e3) {
      var t2 = this.buffer.length - this.offset;
      if (t2 < e3) {
        var n2 = this.buffer, i2 = n2.length + (n2.length >> 1) + e3;
        this.buffer = d3.allocUnsafe(
          i2
        ), n2.copy(this.buffer);
      }
    }
    addInt32(e3) {
      return this.ensure(4), this.buffer[this.offset++] = e3 >>> 24 & 255, this.buffer[this.offset++] = e3 >>> 16 & 255, this.buffer[this.offset++] = e3 >>> 8 & 255, this.buffer[this.offset++] = e3 >>> 0 & 255, this;
    }
    addInt16(e3) {
      return this.ensure(2), this.buffer[this.offset++] = e3 >>> 8 & 255, this.buffer[this.offset++] = e3 >>> 0 & 255, this;
    }
    addCString(e3) {
      if (!e3)
        this.ensure(1);
      else {
        var t2 = d3.byteLength(e3);
        this.ensure(t2 + 1), this.buffer.write(
          e3,
          this.offset,
          "utf-8"
        ), this.offset += t2;
      }
      return this.buffer[this.offset++] = 0, this;
    }
    addString(e3 = "") {
      var t2 = d3.byteLength(e3);
      return this.ensure(t2), this.buffer.write(e3, this.offset), this.offset += t2, this;
    }
    add(e3) {
      return this.ensure(e3.length), e3.copy(this.buffer, this.offset), this.offset += e3.length, this;
    }
    join(e3) {
      if (e3) {
        this.buffer[this.headerPosition] = e3;
        let t2 = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(t2, this.headerPosition + 1);
      }
      return this.buffer.slice(e3 ? 0 : 5, this.offset);
    }
    flush(e3) {
      var t2 = this.join(e3);
      return this.offset = 5, this.headerPosition = 0, this.buffer = d3.allocUnsafe(this.size), t2;
    }
  };
  a(Zr, "Writer");
  var Yr = Zr;
  bt.Writer = Yr;
});
var gs = I((xt) => {
  "use strict";
  p3();
  Object.defineProperty(xt, "__esModule", { value: true });
  xt.serialize = void 0;
  var Jr = ys(), F = new Jr.Writer(), Ru = a((r2) => {
    F.addInt16(3).addInt16(
      0
    );
    for (let n2 of Object.keys(r2))
      F.addCString(n2).addCString(r2[n2]);
    F.addCString("client_encoding").addCString("UTF8");
    var e3 = F.addCString("").flush(), t2 = e3.length + 4;
    return new Jr.Writer().addInt32(t2).add(e3).flush();
  }, "startup"), Fu = a(() => {
    let r2 = d3.allocUnsafe(8);
    return r2.writeInt32BE(8, 0), r2.writeInt32BE(80877103, 4), r2;
  }, "requestSsl"), Mu = a((r2) => F.addCString(r2).flush(112), "password"), Du = a(function(r2, e3) {
    return F.addCString(r2).addInt32(
      d3.byteLength(e3)
    ).addString(e3), F.flush(112);
  }, "sendSASLInitialResponseMessage"), Ou = a(
    function(r2) {
      return F.addString(r2).flush(112);
    },
    "sendSCRAMClientFinalMessage"
  ), ku = a(
    (r2) => F.addCString(r2).flush(81),
    "query"
  ), ms = [], Uu = a((r2) => {
    let e3 = r2.name || "";
    e3.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e3, e3.length), console.error("This can cause conflicts and silent errors executing queries"));
    let t2 = r2.types || ms;
    for (var n2 = t2.length, i2 = F.addCString(e3).addCString(r2.text).addInt16(n2), s2 = 0; s2 < n2; s2++)
      i2.addInt32(t2[s2]);
    return F.flush(80);
  }, "parse"), Ue = new Jr.Writer(), qu = a(function(r2, e3) {
    for (let t2 = 0; t2 < r2.length; t2++) {
      let n2 = e3 ? e3(r2[t2], t2) : r2[t2];
      n2 == null ? (F.addInt16(0), Ue.addInt32(-1)) : n2 instanceof d3 ? (F.addInt16(1), Ue.addInt32(n2.length), Ue.add(n2)) : (F.addInt16(0), Ue.addInt32(d3.byteLength(
        n2
      )), Ue.addString(n2));
    }
  }, "writeValues"), Nu = a((r2 = {}) => {
    let e3 = r2.portal || "", t2 = r2.statement || "", n2 = r2.binary || false, i2 = r2.values || ms, s2 = i2.length;
    return F.addCString(e3).addCString(t2), F.addInt16(s2), qu(i2, r2.valueMapper), F.addInt16(s2), F.add(Ue.flush()), F.addInt16(n2 ? 1 : 0), F.flush(66);
  }, "bind"), Qu = d3.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]), Wu = a((r2) => {
    if (!r2 || !r2.portal && !r2.rows)
      return Qu;
    let e3 = r2.portal || "", t2 = r2.rows || 0, n2 = d3.byteLength(e3), i2 = 4 + n2 + 1 + 4, s2 = d3.allocUnsafe(1 + i2);
    return s2[0] = 69, s2.writeInt32BE(i2, 1), s2.write(e3, 5, "utf-8"), s2[n2 + 5] = 0, s2.writeUInt32BE(t2, s2.length - 4), s2;
  }, "execute"), ju = a((r2, e3) => {
    let t2 = d3.allocUnsafe(16);
    return t2.writeInt32BE(16, 0), t2.writeInt16BE(1234, 4), t2.writeInt16BE(5678, 6), t2.writeInt32BE(
      r2,
      8
    ), t2.writeInt32BE(e3, 12), t2;
  }, "cancel"), Xr = a(
    (r2, e3) => {
      let n2 = 4 + d3.byteLength(e3) + 1, i2 = d3.allocUnsafe(1 + n2);
      return i2[0] = r2, i2.writeInt32BE(n2, 1), i2.write(e3, 5, "utf-8"), i2[n2] = 0, i2;
    },
    "cstringMessage"
  ), Hu = F.addCString("P").flush(68), Gu = F.addCString("S").flush(68), $u = a((r2) => r2.name ? Xr(68, `${r2.type}${r2.name || ""}`) : r2.type === "P" ? Hu : Gu, "describe"), Ku = a(
    (r2) => {
      let e3 = `${r2.type}${r2.name || ""}`;
      return Xr(67, e3);
    },
    "close"
  ), Vu = a((r2) => F.add(r2).flush(
    100
  ), "copyData"), zu = a((r2) => Xr(102, r2), "copyFail"), St = a((r2) => d3.from([r2, 0, 0, 0, 4]), "codeOnlyBuffer"), Yu = St(72), Zu = St(83), Ju = St(88), Xu = St(99), ec = {
    startup: Ru,
    password: Mu,
    requestSsl: Fu,
    sendSASLInitialResponseMessage: Du,
    sendSCRAMClientFinalMessage: Ou,
    query: ku,
    parse: Uu,
    bind: Nu,
    execute: Wu,
    describe: $u,
    close: Ku,
    flush: () => Yu,
    sync: () => Zu,
    end: () => Ju,
    copyData: Vu,
    copyDone: () => Xu,
    copyFail: zu,
    cancel: ju
  };
  xt.serialize = ec;
});
var ws = I((Et) => {
  "use strict";
  p3();
  Object.defineProperty(Et, "__esModule", { value: true });
  Et.BufferReader = void 0;
  var tc = d3.allocUnsafe(0), tn = class tn {
    constructor(e3 = 0) {
      this.offset = e3, this.buffer = tc, this.encoding = "utf-8";
    }
    setBuffer(e3, t2) {
      this.offset = e3, this.buffer = t2;
    }
    int16() {
      let e3 = this.buffer.readInt16BE(this.offset);
      return this.offset += 2, e3;
    }
    byte() {
      let e3 = this.buffer[this.offset];
      return this.offset++, e3;
    }
    int32() {
      let e3 = this.buffer.readInt32BE(this.offset);
      return this.offset += 4, e3;
    }
    string(e3) {
      let t2 = this.buffer.toString(this.encoding, this.offset, this.offset + e3);
      return this.offset += e3, t2;
    }
    cstring() {
      let e3 = this.offset, t2 = e3;
      for (; this.buffer[t2++] !== 0; )
        ;
      return this.offset = t2, this.buffer.toString(this.encoding, e3, t2 - 1);
    }
    bytes(e3) {
      let t2 = this.buffer.slice(this.offset, this.offset + e3);
      return this.offset += e3, t2;
    }
  };
  a(tn, "BufferReader");
  var en = tn;
  Et.BufferReader = en;
});
var bs = {};
X2(bs, { default: () => rc });
var rc;
var Ss = K2(() => {
  "use strict";
  p3();
  rc = {};
});
var vs = I((qe) => {
  "use strict";
  p3();
  var nc = qe && qe.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(qe, "__esModule", { value: true });
  qe.Parser = void 0;
  var M2 = zr(), ic = ws(), sc = nc((Ss(), k(bs))), rn = 1, oc = 4, xs = rn + oc, Es = d3.allocUnsafe(
    0
  ), sn = class sn {
    constructor(e3) {
      if (this.buffer = Es, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new ic.BufferReader(), e3?.mode === "binary")
        throw new Error("Binary mode not supported yet");
      this.mode = e3?.mode || "text";
    }
    parse(e3, t2) {
      this.mergeBuffer(e3);
      let n2 = this.bufferOffset + this.bufferLength, i2 = this.bufferOffset;
      for (; i2 + xs <= n2; ) {
        let s2 = this.buffer[i2], o2 = this.buffer.readUInt32BE(i2 + rn), u2 = rn + o2;
        if (u2 + i2 <= n2) {
          let c3 = this.handlePacket(
            i2 + xs,
            s2,
            o2,
            this.buffer
          );
          t2(c3), i2 += u2;
        } else
          break;
      }
      i2 === n2 ? (this.buffer = Es, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n2 - i2, this.bufferOffset = i2);
    }
    mergeBuffer(e3) {
      if (this.bufferLength > 0) {
        let t2 = this.bufferLength + e3.byteLength;
        if (t2 + this.bufferOffset > this.buffer.byteLength) {
          let i2;
          if (t2 <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength)
            i2 = this.buffer;
          else {
            let s2 = this.buffer.byteLength * 2;
            for (; t2 >= s2; )
              s2 *= 2;
            i2 = d3.allocUnsafe(s2);
          }
          this.buffer.copy(i2, 0, this.bufferOffset, this.bufferOffset + this.bufferLength), this.buffer = i2, this.bufferOffset = 0;
        }
        e3.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t2;
      } else
        this.buffer = e3, this.bufferOffset = 0, this.bufferLength = e3.byteLength;
    }
    handlePacket(e3, t2, n2, i2) {
      switch (t2) {
        case 50:
          return M2.bindComplete;
        case 49:
          return M2.parseComplete;
        case 51:
          return M2.closeComplete;
        case 110:
          return M2.noData;
        case 115:
          return M2.portalSuspended;
        case 99:
          return M2.copyDone;
        case 87:
          return M2.replicationStart;
        case 73:
          return M2.emptyQuery;
        case 68:
          return this.parseDataRowMessage(e3, n2, i2);
        case 67:
          return this.parseCommandCompleteMessage(
            e3,
            n2,
            i2
          );
        case 90:
          return this.parseReadyForQueryMessage(e3, n2, i2);
        case 65:
          return this.parseNotificationMessage(e3, n2, i2);
        case 82:
          return this.parseAuthenticationResponse(
            e3,
            n2,
            i2
          );
        case 83:
          return this.parseParameterStatusMessage(e3, n2, i2);
        case 75:
          return this.parseBackendKeyData(e3, n2, i2);
        case 69:
          return this.parseErrorMessage(e3, n2, i2, "error");
        case 78:
          return this.parseErrorMessage(e3, n2, i2, "notice");
        case 84:
          return this.parseRowDescriptionMessage(
            e3,
            n2,
            i2
          );
        case 116:
          return this.parseParameterDescriptionMessage(e3, n2, i2);
        case 71:
          return this.parseCopyInMessage(e3, n2, i2);
        case 72:
          return this.parseCopyOutMessage(e3, n2, i2);
        case 100:
          return this.parseCopyData(e3, n2, i2);
        default:
          sc.default.fail(`unknown message code: ${t2.toString(16)}`);
      }
    }
    parseReadyForQueryMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.string(1);
      return new M2.ReadyForQueryMessage(t2, i2);
    }
    parseCommandCompleteMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.cstring();
      return new M2.CommandCompleteMessage(
        t2,
        i2
      );
    }
    parseCopyData(e3, t2, n2) {
      let i2 = n2.slice(e3, e3 + (t2 - 4));
      return new M2.CopyDataMessage(
        t2,
        i2
      );
    }
    parseCopyInMessage(e3, t2, n2) {
      return this.parseCopyMessage(e3, t2, n2, "copyInResponse");
    }
    parseCopyOutMessage(e3, t2, n2) {
      return this.parseCopyMessage(e3, t2, n2, "copyOutResponse");
    }
    parseCopyMessage(e3, t2, n2, i2) {
      this.reader.setBuffer(e3, n2);
      let s2 = this.reader.byte() !== 0, o2 = this.reader.int16(), u2 = new M2.CopyResponse(t2, i2, s2, o2);
      for (let c3 = 0; c3 < o2; c3++)
        u2.columnTypes[c3] = this.reader.int16();
      return u2;
    }
    parseNotificationMessage(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int32(), s2 = this.reader.cstring(), o2 = this.reader.cstring();
      return new M2.NotificationResponseMessage(t2, i2, s2, o2);
    }
    parseRowDescriptionMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int16(), s2 = new M2.RowDescriptionMessage(t2, i2);
      for (let o2 = 0; o2 < i2; o2++)
        s2.fields[o2] = this.parseField();
      return s2;
    }
    parseField() {
      let e3 = this.reader.cstring(), t2 = this.reader.int32(), n2 = this.reader.int16(), i2 = this.reader.int32(), s2 = this.reader.int16(), o2 = this.reader.int32(), u2 = this.reader.int16() === 0 ? "text" : "binary";
      return new M2.Field(e3, t2, n2, i2, s2, o2, u2);
    }
    parseParameterDescriptionMessage(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int16(), s2 = new M2.ParameterDescriptionMessage(t2, i2);
      for (let o2 = 0; o2 < i2; o2++)
        s2.dataTypeIDs[o2] = this.reader.int32();
      return s2;
    }
    parseDataRowMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int16(), s2 = new Array(i2);
      for (let o2 = 0; o2 < i2; o2++) {
        let u2 = this.reader.int32();
        s2[o2] = u2 === -1 ? null : this.reader.string(u2);
      }
      return new M2.DataRowMessage(
        t2,
        s2
      );
    }
    parseParameterStatusMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.cstring(), s2 = this.reader.cstring();
      return new M2.ParameterStatusMessage(t2, i2, s2);
    }
    parseBackendKeyData(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int32(), s2 = this.reader.int32();
      return new M2.BackendKeyDataMessage(t2, i2, s2);
    }
    parseAuthenticationResponse(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int32(), s2 = { name: "authenticationOk", length: t2 };
      switch (i2) {
        case 0:
          break;
        case 3:
          s2.length === 8 && (s2.name = "authenticationCleartextPassword");
          break;
        case 5:
          if (s2.length === 12) {
            s2.name = "authenticationMD5Password";
            let u2 = this.reader.bytes(4);
            return new M2.AuthenticationMD5Password(t2, u2);
          }
          break;
        case 10:
          s2.name = "authenticationSASL", s2.mechanisms = [];
          let o2;
          do
            o2 = this.reader.cstring(), o2 && s2.mechanisms.push(o2);
          while (o2);
          break;
        case 11:
          s2.name = "authenticationSASLContinue", s2.data = this.reader.string(t2 - 8);
          break;
        case 12:
          s2.name = "authenticationSASLFinal", s2.data = this.reader.string(t2 - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + i2);
      }
      return s2;
    }
    parseErrorMessage(e3, t2, n2, i2) {
      this.reader.setBuffer(e3, n2);
      let s2 = {}, o2 = this.reader.string(1);
      for (; o2 !== "\0"; )
        s2[o2] = this.reader.cstring(), o2 = this.reader.string(1);
      let u2 = s2.M, c3 = i2 === "notice" ? new M2.NoticeMessage(
        t2,
        u2
      ) : new M2.DatabaseError(u2, t2, i2);
      return c3.severity = s2.S, c3.code = s2.C, c3.detail = s2.D, c3.hint = s2.H, c3.position = s2.P, c3.internalPosition = s2.p, c3.internalQuery = s2.q, c3.where = s2.W, c3.schema = s2.s, c3.table = s2.t, c3.column = s2.c, c3.dataType = s2.d, c3.constraint = s2.n, c3.file = s2.F, c3.line = s2.L, c3.routine = s2.R, c3;
    }
  };
  a(sn, "Parser");
  var nn = sn;
  qe.Parser = nn;
});
var on = I((be) => {
  "use strict";
  p3();
  Object.defineProperty(be, "__esModule", { value: true });
  be.DatabaseError = be.serialize = be.parse = void 0;
  var ac = zr();
  Object.defineProperty(
    be,
    "DatabaseError",
    { enumerable: true, get: function() {
      return ac.DatabaseError;
    } }
  );
  var uc = gs();
  Object.defineProperty(be, "serialize", { enumerable: true, get: function() {
    return uc.serialize;
  } });
  var cc = vs();
  function hc(r2, e3) {
    let t2 = new cc.Parser();
    return r2.on("data", (n2) => t2.parse(
      n2,
      e3
    )), new Promise((n2) => r2.on("end", () => n2()));
  }
  a(hc, "parse");
  be.parse = hc;
});
var _s = {};
X2(_s, { connect: () => lc });
function lc({ socket: r2, servername: e3 }) {
  return r2.startTls(
    e3
  ), r2;
}
var As = K2(() => {
  "use strict";
  p3();
  a(lc, "connect");
});
var cn = I((ef, Ts) => {
  "use strict";
  p3();
  var Cs = (wt(), k(ds)), fc = ge().EventEmitter, {
    parse: pc,
    serialize: q2
  } = on(), Is = q2.flush(), dc = q2.sync(), yc = q2.end(), un = class un extends fc {
    constructor(e3) {
      super(), e3 = e3 || {}, this.stream = e3.stream || new Cs.Socket(), this._keepAlive = e3.keepAlive, this._keepAliveInitialDelayMillis = e3.keepAliveInitialDelayMillis, this.lastBuffer = false, this.parsedStatements = {}, this.ssl = e3.ssl || false, this._ending = false, this._emitMessage = false;
      var t2 = this;
      this.on("newListener", function(n2) {
        n2 === "message" && (t2._emitMessage = true);
      });
    }
    connect(e3, t2) {
      var n2 = this;
      this._connecting = true, this.stream.setNoDelay(true), this.stream.connect(
        e3,
        t2
      ), this.stream.once("connect", function() {
        n2._keepAlive && n2.stream.setKeepAlive(
          true,
          n2._keepAliveInitialDelayMillis
        ), n2.emit("connect");
      });
      let i2 = a(function(s2) {
        n2._ending && (s2.code === "ECONNRESET" || s2.code === "EPIPE") || n2.emit("error", s2);
      }, "reportStreamError");
      if (this.stream.on("error", i2), this.stream.on("close", function() {
        n2.emit("end");
      }), !this.ssl)
        return this.attachListeners(this.stream);
      this.stream.once("data", function(s2) {
        var o2 = s2.toString("utf8");
        switch (o2) {
          case "S":
            break;
          case "N":
            return n2.stream.end(), n2.emit("error", new Error("The server does not support SSL connections"));
          default:
            return n2.stream.end(), n2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        var u2 = (As(), k(_s));
        let c3 = { socket: n2.stream };
        n2.ssl !== true && (Object.assign(
          c3,
          n2.ssl
        ), "key" in n2.ssl && (c3.key = n2.ssl.key)), Cs.isIP(t2) === 0 && (c3.servername = t2);
        try {
          n2.stream = u2.connect(c3);
        } catch (h2) {
          return n2.emit("error", h2);
        }
        n2.attachListeners(n2.stream), n2.stream.on("error", i2), n2.emit("sslconnect");
      });
    }
    attachListeners(e3) {
      e3.on("end", () => {
        this.emit("end");
      }), pc(e3, (t2) => {
        var n2 = t2.name === "error" ? "errorMessage" : t2.name;
        this._emitMessage && this.emit("message", t2), this.emit(n2, t2);
      });
    }
    requestSsl() {
      this.stream.write(q2.requestSsl());
    }
    startup(e3) {
      this.stream.write(q2.startup(e3));
    }
    cancel(e3, t2) {
      this._send(q2.cancel(e3, t2));
    }
    password(e3) {
      this._send(q2.password(e3));
    }
    sendSASLInitialResponseMessage(e3, t2) {
      this._send(q2.sendSASLInitialResponseMessage(
        e3,
        t2
      ));
    }
    sendSCRAMClientFinalMessage(e3) {
      this._send(q2.sendSCRAMClientFinalMessage(e3));
    }
    _send(e3) {
      return this.stream.writable ? this.stream.write(e3) : false;
    }
    query(e3) {
      this._send(q2.query(
        e3
      ));
    }
    parse(e3) {
      this._send(q2.parse(e3));
    }
    bind(e3) {
      this._send(q2.bind(e3));
    }
    execute(e3) {
      this._send(q2.execute(e3));
    }
    flush() {
      this.stream.writable && this.stream.write(Is);
    }
    sync() {
      this._ending = true, this._send(Is), this._send(dc);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      if (this._ending = true, !this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(yc, () => {
        this.stream.end();
      });
    }
    close(e3) {
      this._send(q2.close(e3));
    }
    describe(e3) {
      this._send(q2.describe(e3));
    }
    sendCopyFromChunk(e3) {
      this._send(q2.copyData(e3));
    }
    endCopyFrom() {
      this._send(q2.copyDone());
    }
    sendCopyFail(e3) {
      this._send(q2.copyFail(e3));
    }
  };
  a(un, "Connection");
  var an = un;
  Ts.exports = an;
});
var Ls = I((sf, Bs) => {
  "use strict";
  p3();
  var mc = ge().EventEmitter, nf = (Ge(), k(He)), gc = tt(), hn = qi(), wc = Yi(), bc = hr(), Sc = gt(), Ps = fs(), xc = et(), Ec = cn(), ln = class ln extends mc {
    constructor(e3) {
      super(), this.connectionParameters = new Sc(e3), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(this, "password", { configurable: true, enumerable: false, writable: true, value: this.connectionParameters.password }), this.replication = this.connectionParameters.replication;
      var t2 = e3 || {};
      this._Promise = t2.Promise || b2.Promise, this._types = new bc(t2.types), this._ending = false, this._connecting = false, this._connected = false, this._connectionError = false, this._queryable = true, this.connection = t2.connection || new Ec({ stream: t2.stream, ssl: this.connectionParameters.ssl, keepAlive: t2.keepAlive || false, keepAliveInitialDelayMillis: t2.keepAliveInitialDelayMillis || 0, encoding: this.connectionParameters.client_encoding || "utf8" }), this.queryQueue = [], this.binary = t2.binary || xc.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || false, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this._connectionTimeoutMillis = t2.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(e3) {
      let t2 = a(
        (n2) => {
          m2.nextTick(() => {
            n2.handleError(e3, this.connection);
          });
        },
        "enqueueError"
      );
      this.activeQuery && (t2(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t2), this.queryQueue.length = 0;
    }
    _connect(e3) {
      var t2 = this, n2 = this.connection;
      if (this._connectionCallback = e3, this._connecting || this._connected) {
        let i2 = new Error("Client has already been connected. You cannot reuse a client.");
        m2.nextTick(() => {
          e3(i2);
        });
        return;
      }
      this._connecting = true, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(() => {
        n2._ending = true, n2.stream.destroy(new Error("timeout expired"));
      }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n2.connect(this.host + "/.s.PGSQL." + this.port) : n2.connect(this.port, this.host), n2.on("connect", function() {
        t2.ssl ? n2.requestSsl() : n2.startup(t2.getStartupConf());
      }), n2.on("sslconnect", function() {
        n2.startup(t2.getStartupConf());
      }), this._attachListeners(n2), n2.once("end", () => {
        let i2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i2), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i2) : this._handleErrorEvent(i2) : this._connectionError || this._handleErrorEvent(
          i2
        )), m2.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(e3) {
      if (e3) {
        this._connect(e3);
        return;
      }
      return new this._Promise((t2, n2) => {
        this._connect((i2) => {
          i2 ? n2(i2) : t2();
        });
      });
    }
    _attachListeners(e3) {
      e3.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e3.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e3.on("authenticationSASL", this._handleAuthSASL.bind(this)), e3.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e3.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e3.on("backendKeyData", this._handleBackendKeyData.bind(this)), e3.on("error", this._handleErrorEvent.bind(this)), e3.on(
        "errorMessage",
        this._handleErrorMessage.bind(this)
      ), e3.on("readyForQuery", this._handleReadyForQuery.bind(this)), e3.on("notice", this._handleNotice.bind(this)), e3.on("rowDescription", this._handleRowDescription.bind(this)), e3.on("dataRow", this._handleDataRow.bind(this)), e3.on("portalSuspended", this._handlePortalSuspended.bind(this)), e3.on(
        "emptyQuery",
        this._handleEmptyQuery.bind(this)
      ), e3.on("commandComplete", this._handleCommandComplete.bind(this)), e3.on("parseComplete", this._handleParseComplete.bind(this)), e3.on("copyInResponse", this._handleCopyInResponse.bind(this)), e3.on("copyData", this._handleCopyData.bind(this)), e3.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(e3) {
      let t2 = this.connection;
      typeof this.password == "function" ? this._Promise.resolve().then(
        () => this.password()
      ).then((n2) => {
        if (n2 !== void 0) {
          if (typeof n2 != "string") {
            t2.emit("error", new TypeError("Password must be a string"));
            return;
          }
          this.connectionParameters.password = this.password = n2;
        } else
          this.connectionParameters.password = this.password = null;
        e3();
      }).catch((n2) => {
        t2.emit("error", n2);
      }) : this.password !== null ? e3() : wc(
        this.connectionParameters,
        (n2) => {
          n2 !== void 0 && (this.connectionParameters.password = this.password = n2), e3();
        }
      );
    }
    _handleAuthCleartextPassword(e3) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(e3) {
      this._checkPgPass(() => {
        let t2 = gc.postgresMd5PasswordHash(
          this.user,
          this.password,
          e3.salt
        );
        this.connection.password(t2);
      });
    }
    _handleAuthSASL(e3) {
      this._checkPgPass(() => {
        this.saslSession = hn.startSession(e3.mechanisms), this.connection.sendSASLInitialResponseMessage(
          this.saslSession.mechanism,
          this.saslSession.response
        );
      });
    }
    _handleAuthSASLContinue(e3) {
      hn.continueSession(this.saslSession, this.password, e3.data), this.connection.sendSCRAMClientFinalMessage(
        this.saslSession.response
      );
    }
    _handleAuthSASLFinal(e3) {
      hn.finalizeSession(
        this.saslSession,
        e3.data
      ), this.saslSession = null;
    }
    _handleBackendKeyData(e3) {
      this.processID = e3.processID, this.secretKey = e3.secretKey;
    }
    _handleReadyForQuery(e3) {
      this._connecting && (this._connecting = false, this._connected = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
      let { activeQuery: t2 } = this;
      this.activeQuery = null, this.readyForQuery = true, t2 && t2.handleReadyForQuery(this.connection), this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(e3) {
      if (!this._connectionError) {
        if (this._connectionError = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback)
          return this._connectionCallback(e3);
        this.emit("error", e3);
      }
    }
    _handleErrorEvent(e3) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e3);
      this._queryable = false, this._errorAllQueries(e3), this.emit("error", e3);
    }
    _handleErrorMessage(e3) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e3);
      let t2 = this.activeQuery;
      if (!t2) {
        this._handleErrorEvent(
          e3
        );
        return;
      }
      this.activeQuery = null, t2.handleError(e3, this.connection);
    }
    _handleRowDescription(e3) {
      this.activeQuery.handleRowDescription(e3);
    }
    _handleDataRow(e3) {
      this.activeQuery.handleDataRow(
        e3
      );
    }
    _handlePortalSuspended(e3) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(e3) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(e3) {
      this.activeQuery.handleCommandComplete(e3, this.connection);
    }
    _handleParseComplete(e3) {
      this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
    }
    _handleCopyInResponse(e3) {
      this.activeQuery.handleCopyInResponse(
        this.connection
      );
    }
    _handleCopyData(e3) {
      this.activeQuery.handleCopyData(e3, this.connection);
    }
    _handleNotification(e3) {
      this.emit("notification", e3);
    }
    _handleNotice(e3) {
      this.emit("notice", e3);
    }
    getStartupConf() {
      var e3 = this.connectionParameters, t2 = { user: e3.user, database: e3.database }, n2 = e3.application_name || e3.fallback_application_name;
      return n2 && (t2.application_name = n2), e3.replication && (t2.replication = "" + e3.replication), e3.statement_timeout && (t2.statement_timeout = String(parseInt(
        e3.statement_timeout,
        10
      ))), e3.lock_timeout && (t2.lock_timeout = String(parseInt(e3.lock_timeout, 10))), e3.idle_in_transaction_session_timeout && (t2.idle_in_transaction_session_timeout = String(parseInt(
        e3.idle_in_transaction_session_timeout,
        10
      ))), e3.options && (t2.options = e3.options), t2;
    }
    cancel(e3, t2) {
      if (e3.activeQuery === t2) {
        var n2 = this.connection;
        this.host && this.host.indexOf("/") === 0 ? n2.connect(this.host + "/.s.PGSQL." + this.port) : n2.connect(this.port, this.host), n2.on("connect", function() {
          n2.cancel(
            e3.processID,
            e3.secretKey
          );
        });
      } else
        e3.queryQueue.indexOf(t2) !== -1 && e3.queryQueue.splice(e3.queryQueue.indexOf(t2), 1);
    }
    setTypeParser(e3, t2, n2) {
      return this._types.setTypeParser(e3, t2, n2);
    }
    getTypeParser(e3, t2) {
      return this._types.getTypeParser(e3, t2);
    }
    escapeIdentifier(e3) {
      return '"' + e3.replace(
        /"/g,
        '""'
      ) + '"';
    }
    escapeLiteral(e3) {
      for (var t2 = false, n2 = "'", i2 = 0; i2 < e3.length; i2++) {
        var s2 = e3[i2];
        s2 === "'" ? n2 += s2 + s2 : s2 === "\\" ? (n2 += s2 + s2, t2 = true) : n2 += s2;
      }
      return n2 += "'", t2 === true && (n2 = " E" + n2), n2;
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true)
        if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
          this.readyForQuery = false, this.hasExecuted = true;
          let e3 = this.activeQuery.submit(this.connection);
          e3 && m2.nextTick(() => {
            this.activeQuery.handleError(e3, this.connection), this.readyForQuery = true, this._pulseQueryQueue();
          });
        } else
          this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
    }
    query(e3, t2, n2) {
      var i2, s2, o2, u2, c3;
      if (e3 == null)
        throw new TypeError("Client was passed a null or undefined query");
      return typeof e3.submit == "function" ? (o2 = e3.query_timeout || this.connectionParameters.query_timeout, s2 = i2 = e3, typeof t2 == "function" && (i2.callback = i2.callback || t2)) : (o2 = this.connectionParameters.query_timeout, i2 = new Ps(
        e3,
        t2,
        n2
      ), i2.callback || (s2 = new this._Promise((h2, l3) => {
        i2.callback = (y2, E) => y2 ? l3(y2) : h2(E);
      }))), o2 && (c3 = i2.callback, u2 = setTimeout(() => {
        var h2 = new Error("Query read timeout");
        m2.nextTick(
          () => {
            i2.handleError(h2, this.connection);
          }
        ), c3(h2), i2.callback = () => {
        };
        var l3 = this.queryQueue.indexOf(i2);
        l3 > -1 && this.queryQueue.splice(l3, 1), this._pulseQueryQueue();
      }, o2), i2.callback = (h2, l3) => {
        clearTimeout(u2), c3(h2, l3);
      }), this.binary && !i2.binary && (i2.binary = true), i2._result && !i2._result._types && (i2._result._types = this._types), this._queryable ? this._ending ? (m2.nextTick(() => {
        i2.handleError(
          new Error("Client was closed and is not queryable"),
          this.connection
        );
      }), s2) : (this.queryQueue.push(i2), this._pulseQueryQueue(), s2) : (m2.nextTick(
        () => {
          i2.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        }
      ), s2);
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(e3) {
      if (this._ending = true, !this.connection._connecting)
        if (e3)
          e3();
        else
          return this._Promise.resolve();
      if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e3)
        this.connection.once("end", e3);
      else
        return new this._Promise((t2) => {
          this.connection.once("end", t2);
        });
    }
  };
  a(ln, "Client");
  var vt = ln;
  vt.Query = Ps;
  Bs.exports = vt;
});
var Ds = I((uf, Ms) => {
  "use strict";
  p3();
  var vc = ge().EventEmitter, Rs = a(function() {
  }, "NOOP"), Fs = a(
    (r2, e3) => {
      let t2 = r2.findIndex(e3);
      return t2 === -1 ? void 0 : r2.splice(t2, 1)[0];
    },
    "removeWhere"
  ), dn = class dn {
    constructor(e3, t2, n2) {
      this.client = e3, this.idleListener = t2, this.timeoutId = n2;
    }
  };
  a(dn, "IdleItem");
  var fn = dn, yn = class yn {
    constructor(e3) {
      this.callback = e3;
    }
  };
  a(yn, "PendingItem");
  var Ne = yn;
  function _c() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  a(_c, "throwOnDoubleRelease");
  function _t(r2, e3) {
    if (e3)
      return { callback: e3, result: void 0 };
    let t2, n2, i2 = a(function(o2, u2) {
      o2 ? t2(o2) : n2(u2);
    }, "cb"), s2 = new r2(function(o2, u2) {
      n2 = o2, t2 = u2;
    }).catch((o2) => {
      throw Error.captureStackTrace(
        o2
      ), o2;
    });
    return { callback: i2, result: s2 };
  }
  a(_t, "promisify");
  function Ac(r2, e3) {
    return a(
      function t2(n2) {
        n2.client = e3, e3.removeListener("error", t2), e3.on("error", () => {
          r2.log("additional client error after disconnection due to error", n2);
        }), r2._remove(e3), r2.emit("error", n2, e3);
      },
      "idleListener"
    );
  }
  a(Ac, "makeIdleListener");
  var mn = class mn extends vc {
    constructor(e3, t2) {
      super(), this.options = Object.assign({}, e3), e3 != null && "password" in e3 && Object.defineProperty(
        this.options,
        "password",
        { configurable: true, enumerable: false, writable: true, value: e3.password }
      ), e3 != null && e3.ssl && e3.ssl.key && Object.defineProperty(this.options.ssl, "key", { enumerable: false }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || false, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {
      }, this.Client = this.options.Client || t2 || At().Client, this.Promise = this.options.Promise || b2.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = /* @__PURE__ */ new WeakSet(), this._pendingQueue = [], this._endCallback = void 0, this.ending = false, this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      if (this.log("pulse queue"), this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log(
          "pulse queue on ending"
        ), this._idle.length && this._idle.slice().map((t2) => {
          this._remove(
            t2.client
          );
        }), this._clients.length || (this.ended = true, this._endCallback());
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull())
        return;
      let e3 = this._pendingQueue.shift();
      if (this._idle.length) {
        let t2 = this._idle.pop();
        clearTimeout(t2.timeoutId);
        let n2 = t2.client;
        n2.ref && n2.ref();
        let i2 = t2.idleListener;
        return this._acquireClient(n2, e3, i2, false);
      }
      if (!this._isFull())
        return this.newClient(e3);
      throw new Error("unexpected condition");
    }
    _remove(e3) {
      let t2 = Fs(this._idle, (n2) => n2.client === e3);
      t2 !== void 0 && clearTimeout(t2.timeoutId), this._clients = this._clients.filter((n2) => n2 !== e3), e3.end(), this.emit("remove", e3);
    }
    connect(e3) {
      if (this.ending) {
        let i2 = new Error("Cannot use a pool after calling end on the pool");
        return e3 ? e3(i2) : this.Promise.reject(
          i2
        );
      }
      let t2 = _t(this.Promise, e3), n2 = t2.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length && m2.nextTick(() => this._pulseQueue()), !this.options.connectionTimeoutMillis)
          return this._pendingQueue.push(new Ne(t2.callback)), n2;
        let i2 = a((u2, c3, h2) => {
          clearTimeout(
            o2
          ), t2.callback(u2, c3, h2);
        }, "queueCallback"), s2 = new Ne(i2), o2 = setTimeout(() => {
          Fs(
            this._pendingQueue,
            (u2) => u2.callback === i2
          ), s2.timedOut = true, t2.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        return this._pendingQueue.push(s2), n2;
      }
      return this.newClient(new Ne(t2.callback)), n2;
    }
    newClient(e3) {
      let t2 = new this.Client(this.options);
      this._clients.push(t2);
      let n2 = Ac(this, t2);
      this.log("checking client timeout");
      let i2, s2 = false;
      this.options.connectionTimeoutMillis && (i2 = setTimeout(() => {
        this.log("ending client due to timeout"), s2 = true, t2.connection ? t2.connection.stream.destroy() : t2.end();
      }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t2.connect((o2) => {
        if (i2 && clearTimeout(i2), t2.on("error", n2), o2)
          this.log("client failed to connect", o2), this._clients = this._clients.filter((u2) => u2 !== t2), s2 && (o2.message = "Connection terminated due to connection timeout"), this._pulseQueue(), e3.timedOut || e3.callback(
            o2,
            void 0,
            Rs
          );
        else {
          if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
            let u2 = setTimeout(() => {
              this.log("ending client due to expired lifetime"), this._expired.add(t2), this._idle.findIndex((h2) => h2.client === t2) !== -1 && this._acquireClient(
                t2,
                new Ne((h2, l3, y2) => y2()),
                n2,
                false
              );
            }, this.options.maxLifetimeSeconds * 1e3);
            u2.unref(), t2.once(
              "end",
              () => clearTimeout(u2)
            );
          }
          return this._acquireClient(t2, e3, n2, true);
        }
      });
    }
    _acquireClient(e3, t2, n2, i2) {
      i2 && this.emit("connect", e3), this.emit("acquire", e3), e3.release = this._releaseOnce(e3, n2), e3.removeListener("error", n2), t2.timedOut ? i2 && this.options.verify ? this.options.verify(
        e3,
        e3.release
      ) : e3.release() : i2 && this.options.verify ? this.options.verify(e3, (s2) => {
        if (s2)
          return e3.release(s2), t2.callback(s2, void 0, Rs);
        t2.callback(void 0, e3, e3.release);
      }) : t2.callback(
        void 0,
        e3,
        e3.release
      );
    }
    _releaseOnce(e3, t2) {
      let n2 = false;
      return (i2) => {
        n2 && _c(), n2 = true, this._release(
          e3,
          t2,
          i2
        );
      };
    }
    _release(e3, t2, n2) {
      if (e3.on("error", t2), e3._poolUseCount = (e3._poolUseCount || 0) + 1, this.emit("release", n2, e3), n2 || this.ending || !e3._queryable || e3._ending || e3._poolUseCount >= this.options.maxUses) {
        e3._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e3), this._pulseQueue();
        return;
      }
      if (this._expired.has(e3)) {
        this.log("remove expired client"), this._expired.delete(e3), this._remove(e3), this._pulseQueue();
        return;
      }
      let s2;
      this.options.idleTimeoutMillis && (s2 = setTimeout(() => {
        this.log("remove idle client"), this._remove(e3);
      }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s2.unref()), this.options.allowExitOnIdle && e3.unref(), this._idle.push(new fn(e3, t2, s2)), this._pulseQueue();
    }
    query(e3, t2, n2) {
      if (typeof e3 == "function") {
        let s2 = _t(this.Promise, e3);
        return S2(function() {
          return s2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        }), s2.result;
      }
      typeof t2 == "function" && (n2 = t2, t2 = void 0);
      let i2 = _t(this.Promise, n2);
      return n2 = i2.callback, this.connect((s2, o2) => {
        if (s2)
          return n2(s2);
        let u2 = false, c3 = a((h2) => {
          u2 || (u2 = true, o2.release(h2), n2(h2));
        }, "onError");
        o2.once("error", c3), this.log("dispatching query");
        try {
          o2.query(e3, t2, (h2, l3) => {
            if (this.log("query dispatched"), o2.removeListener("error", c3), !u2)
              return u2 = true, o2.release(h2), h2 ? n2(h2) : n2(
                void 0,
                l3
              );
          });
        } catch (h2) {
          return o2.release(h2), n2(h2);
        }
      }), i2.result;
    }
    end(e3) {
      if (this.log("ending"), this.ending) {
        let n2 = new Error("Called end on pool more than once");
        return e3 ? e3(n2) : this.Promise.reject(n2);
      }
      this.ending = true;
      let t2 = _t(this.Promise, e3);
      return this._endCallback = t2.callback, this._pulseQueue(), t2.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((e3, t2) => e3 + (this._expired.has(t2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  };
  a(mn, "Pool");
  var pn = mn;
  Ms.exports = pn;
});
var Os = {};
X2(Os, { default: () => Cc });
var Cc;
var ks = K2(() => {
  "use strict";
  p3();
  Cc = {};
});
var Us = I((ff, Ic) => {
  Ic.exports = { name: "pg", version: "8.8.0", description: "PostgreSQL client - pure javascript & libpq with the same API", keywords: [
    "database",
    "libpq",
    "pg",
    "postgre",
    "postgres",
    "postgresql",
    "rdbms"
  ], homepage: "https://github.com/brianc/node-postgres", repository: { type: "git", url: "git://github.com/brianc/node-postgres.git", directory: "packages/pg" }, author: "Brian Carlson <brian.m.carlson@gmail.com>", main: "./lib", dependencies: {
    "buffer-writer": "2.0.0",
    "packet-reader": "1.0.0",
    "pg-connection-string": "^2.5.0",
    "pg-pool": "^3.5.2",
    "pg-protocol": "^1.5.0",
    "pg-types": "^2.1.0",
    pgpass: "1.x"
  }, devDependencies: { async: "2.6.4", bluebird: "3.5.2", co: "4.6.0", "pg-copy-streams": "0.3.0" }, peerDependencies: { "pg-native": ">=3.0.1" }, peerDependenciesMeta: {
    "pg-native": { optional: true }
  }, scripts: { test: "make test-all" }, files: ["lib", "SPONSORS.md"], license: "MIT", engines: { node: ">= 8.0.0" }, gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655" };
});
var Qs = I((pf, Ns) => {
  "use strict";
  p3();
  var qs2 = ge().EventEmitter, Tc = (Ge(), k(He)), gn = tt(), Qe = Ns.exports = function(r2, e3, t2) {
    qs2.call(this), r2 = gn.normalizeQueryConfig(r2, e3, t2), this.text = r2.text, this.values = r2.values, this.name = r2.name, this.callback = r2.callback, this.state = "new", this._arrayMode = r2.rowMode === "array", this._emitRowEvents = false, this.on("newListener", function(n2) {
      n2 === "row" && (this._emitRowEvents = true);
    }.bind(this));
  };
  Tc.inherits(
    Qe,
    qs2
  );
  var Pc = { sqlState: "code", statementPosition: "position", messagePrimary: "message", context: "where", schemaName: "schema", tableName: "table", columnName: "column", dataTypeName: "dataType", constraintName: "constraint", sourceFile: "file", sourceLine: "line", sourceFunction: "routine" };
  Qe.prototype.handleError = function(r2) {
    var e3 = this.native.pq.resultErrorFields();
    if (e3)
      for (var t2 in e3) {
        var n2 = Pc[t2] || t2;
        r2[n2] = e3[t2];
      }
    this.callback ? this.callback(r2) : this.emit("error", r2), this.state = "error";
  };
  Qe.prototype.then = function(r2, e3) {
    return this._getPromise().then(r2, e3);
  };
  Qe.prototype.catch = function(r2) {
    return this._getPromise().catch(r2);
  };
  Qe.prototype._getPromise = function() {
    return this._promise ? this._promise : (this._promise = new Promise(function(r2, e3) {
      this._once("end", r2), this._once(
        "error",
        e3
      );
    }.bind(this)), this._promise);
  };
  Qe.prototype.submit = function(r2) {
    this.state = "running";
    var e3 = this;
    this.native = r2.native, r2.native.arrayMode = this._arrayMode;
    var t2 = a(
      function(s2, o2, u2) {
        if (r2.native.arrayMode = false, S2(function() {
          e3.emit("_done");
        }), s2)
          return e3.handleError(s2);
        e3._emitRowEvents && (u2.length > 1 ? o2.forEach((c3, h2) => {
          c3.forEach((l3) => {
            e3.emit(
              "row",
              l3,
              u2[h2]
            );
          });
        }) : o2.forEach(function(c3) {
          e3.emit("row", c3, u2);
        })), e3.state = "end", e3.emit(
          "end",
          u2
        ), e3.callback && e3.callback(null, u2);
      },
      "after"
    );
    if (m2.domain && (t2 = m2.domain.bind(
      t2
    )), this.name) {
      this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error(
        "You supplied %s (%s)",
        this.name,
        this.name.length
      ), console.error("This can cause conflicts and silent errors executing queries"));
      var n2 = (this.values || []).map(gn.prepareValue);
      if (r2.namedQueries[this.name]) {
        if (this.text && r2.namedQueries[this.name] !== this.text) {
          let s2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return t2(s2);
        }
        return r2.native.execute(this.name, n2, t2);
      }
      return r2.native.prepare(
        this.name,
        this.text,
        n2.length,
        function(s2) {
          return s2 ? t2(s2) : (r2.namedQueries[e3.name] = e3.text, e3.native.execute(e3.name, n2, t2));
        }
      );
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        let s2 = new Error("Query values must be an array");
        return t2(s2);
      }
      var i2 = this.values.map(gn.prepareValue);
      r2.native.query(this.text, i2, t2);
    } else
      r2.native.query(this.text, t2);
  };
});
var Gs = I((gf, Hs) => {
  "use strict";
  p3();
  var Bc = (ks(), k(Os)), Lc = hr(), mf = Us(), Ws = ge().EventEmitter, Rc = (Ge(), k(He)), Fc = gt(), js = Qs(), Z2 = Hs.exports = function(r2) {
    Ws.call(this), r2 = r2 || {}, this._Promise = r2.Promise || b2.Promise, this._types = new Lc(r2.types), this.native = new Bc({ types: this._types }), this._queryQueue = [], this._ending = false, this._connecting = false, this._connected = false, this._queryable = true;
    var e3 = this.connectionParameters = new Fc(
      r2
    );
    this.user = e3.user, Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: e3.password
    }), this.database = e3.database, this.host = e3.host, this.port = e3.port, this.namedQueries = {};
  };
  Z2.Query = js;
  Rc.inherits(Z2, Ws);
  Z2.prototype._errorAllQueries = function(r2) {
    let e3 = a(
      (t2) => {
        m2.nextTick(() => {
          t2.native = this.native, t2.handleError(r2);
        });
      },
      "enqueueError"
    );
    this._hasActiveQuery() && (e3(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e3), this._queryQueue.length = 0;
  };
  Z2.prototype._connect = function(r2) {
    var e3 = this;
    if (this._connecting) {
      m2.nextTick(() => r2(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true, this.connectionParameters.getLibpqConnectionString(function(t2, n2) {
      if (t2)
        return r2(
          t2
        );
      e3.native.connect(n2, function(i2) {
        if (i2)
          return e3.native.end(), r2(i2);
        e3._connected = true, e3.native.on("error", function(s2) {
          e3._queryable = false, e3._errorAllQueries(s2), e3.emit("error", s2);
        }), e3.native.on("notification", function(s2) {
          e3.emit("notification", { channel: s2.relname, payload: s2.extra });
        }), e3.emit("connect"), e3._pulseQueryQueue(true), r2();
      });
    });
  };
  Z2.prototype.connect = function(r2) {
    if (r2) {
      this._connect(r2);
      return;
    }
    return new this._Promise(
      (e3, t2) => {
        this._connect((n2) => {
          n2 ? t2(n2) : e3();
        });
      }
    );
  };
  Z2.prototype.query = function(r2, e3, t2) {
    var n2, i2, s2, o2, u2;
    if (r2 == null)
      throw new TypeError("Client was passed a null or undefined query");
    if (typeof r2.submit == "function")
      s2 = r2.query_timeout || this.connectionParameters.query_timeout, i2 = n2 = r2, typeof e3 == "function" && (r2.callback = e3);
    else if (s2 = this.connectionParameters.query_timeout, n2 = new js(r2, e3, t2), !n2.callback) {
      let c3, h2;
      i2 = new this._Promise((l3, y2) => {
        c3 = l3, h2 = y2;
      }), n2.callback = (l3, y2) => l3 ? h2(l3) : c3(y2);
    }
    return s2 && (u2 = n2.callback, o2 = setTimeout(() => {
      var c3 = new Error("Query read timeout");
      m2.nextTick(() => {
        n2.handleError(c3, this.connection);
      }), u2(c3), n2.callback = () => {
      };
      var h2 = this._queryQueue.indexOf(n2);
      h2 > -1 && this._queryQueue.splice(h2, 1), this._pulseQueryQueue();
    }, s2), n2.callback = (c3, h2) => {
      clearTimeout(o2), u2(c3, h2);
    }), this._queryable ? this._ending ? (n2.native = this.native, m2.nextTick(() => {
      n2.handleError(
        new Error("Client was closed and is not queryable")
      );
    }), i2) : (this._queryQueue.push(
      n2
    ), this._pulseQueryQueue(), i2) : (n2.native = this.native, m2.nextTick(() => {
      n2.handleError(
        new Error("Client has encountered a connection error and is not queryable")
      );
    }), i2);
  };
  Z2.prototype.end = function(r2) {
    var e3 = this;
    this._ending = true, this._connected || this.once(
      "connect",
      this.end.bind(this, r2)
    );
    var t2;
    return r2 || (t2 = new this._Promise(function(n2, i2) {
      r2 = a((s2) => s2 ? i2(s2) : n2(), "cb");
    })), this.native.end(function() {
      e3._errorAllQueries(new Error(
        "Connection terminated"
      )), m2.nextTick(() => {
        e3.emit("end"), r2 && r2();
      });
    }), t2;
  };
  Z2.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Z2.prototype._pulseQueryQueue = function(r2) {
    if (this._connected && !this._hasActiveQuery()) {
      var e3 = this._queryQueue.shift();
      if (!e3) {
        r2 || this.emit("drain");
        return;
      }
      this._activeQuery = e3, e3.submit(this);
      var t2 = this;
      e3.once(
        "_done",
        function() {
          t2._pulseQueryQueue();
        }
      );
    }
  };
  Z2.prototype.cancel = function(r2) {
    this._activeQuery === r2 ? this.native.cancel(function() {
    }) : this._queryQueue.indexOf(r2) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r2), 1);
  };
  Z2.prototype.ref = function() {
  };
  Z2.prototype.unref = function() {
  };
  Z2.prototype.setTypeParser = function(r2, e3, t2) {
    return this._types.setTypeParser(r2, e3, t2);
  };
  Z2.prototype.getTypeParser = function(r2, e3) {
    return this._types.getTypeParser(r2, e3);
  };
});
var wn = I((Sf, $s) => {
  "use strict";
  p3();
  $s.exports = Gs();
});
var At = I((Ef, nt) => {
  "use strict";
  p3();
  var Mc = Ls(), Dc = et(), Oc = cn(), kc = Ds(), { DatabaseError: Uc } = on(), qc = a((r2) => {
    var e3;
    return e3 = class extends kc {
      constructor(n2) {
        super(n2, r2);
      }
    }, a(e3, "BoundPool"), e3;
  }, "poolFactory"), bn = a(function(r2) {
    this.defaults = Dc, this.Client = r2, this.Query = this.Client.Query, this.Pool = qc(this.Client), this._pools = [], this.Connection = Oc, this.types = Xe(), this.DatabaseError = Uc;
  }, "PG");
  typeof m2.env.NODE_PG_FORCE_NATIVE < "u" ? nt.exports = new bn(wn()) : (nt.exports = new bn(Mc), Object.defineProperty(nt.exports, "native", { configurable: true, enumerable: false, get() {
    var r2 = null;
    try {
      r2 = new bn(wn());
    } catch (e3) {
      if (e3.code !== "MODULE_NOT_FOUND")
        throw e3;
    }
    return Object.defineProperty(nt.exports, "native", { value: r2 }), r2;
  } }));
});
p3();
var Ct = We(At());
wt();
p3();
fr();
wt();
var zs = We(tt());
var Sn = class Sn2 extends Error {
  constructor() {
    super(...arguments);
    T(this, "name", "NeonDbError");
    T(this, "code", null);
    T(this, "sourceError");
  }
};
a(Sn, "NeonDbError");
var Ae = Sn;
var Ks = "transaction() expects an array of queries, or a function returning an array of queries";
function Ys(r2, {
  arrayMode: e3,
  fullResults: t2,
  fetchOptions: n2,
  isolationLevel: i2,
  readOnly: s2,
  deferrable: o2,
  queryCallback: u2,
  resultCallback: c3
} = {}) {
  if (!r2)
    throw new Error(
      "No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?"
    );
  let h2;
  try {
    h2 = lr(r2);
  } catch {
    throw new Error("Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(
      r2
    ));
  }
  let { protocol: l3, username: y2, password: E, hostname: _, port: P2, pathname: N } = h2;
  if (l3 !== "postgres:" && l3 !== "postgresql:" || !y2 || !E || !_ || !N)
    throw new Error("Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value");
  function J(A, ...g2) {
    let D, H;
    if (typeof A == "string")
      D = A, H = g2[1], g2 = g2[0] ?? [];
    else {
      D = "";
      for (let W = 0; W < A.length; W++)
        D += A[W], W < g2.length && (D += "$" + (W + 1));
    }
    g2 = g2.map((W) => (0, zs.prepareValue)(W));
    let Q = { query: D, params: g2 };
    return u2 && u2(Q), Nc(
      pe,
      Q,
      H
    );
  }
  a(J, "resolve"), J.transaction = async (A, g2) => {
    if (typeof A == "function" && (A = A(J)), !Array.isArray(A))
      throw new Error(Ks);
    let D = A.map((H) => {
      if (H[Symbol.toStringTag] !== "NeonQueryPromise")
        throw new Error(Ks);
      return H.parameterizedQuery;
    });
    return pe(
      D,
      g2
    );
  };
  async function pe(A, g2) {
    let D = n2 ?? {}, { fetchEndpoint: H, fetchConnectionCache: Q, fetchFunction: W } = _e, ue = typeof H == "function" ? H(_, P2) : H, de = Array.isArray(A) ? { queries: A } : A, L = e3 ?? false, G = t2 ?? false, ce = i2, ye = s2, xe = o2;
    g2 !== void 0 && (g2.arrayMode !== void 0 && (L = g2.arrayMode), g2.fullResults !== void 0 && (G = g2.fullResults), g2.fetchOptions !== void 0 && (D = { ...D, ...g2.fetchOptions }), g2.isolationLevel !== void 0 && (ce = g2.isolationLevel), g2.readOnly !== void 0 && (ye = g2.readOnly), g2.deferrable !== void 0 && (xe = g2.deferrable));
    let he = { "Neon-Connection-String": r2, "Neon-Raw-Text-Output": "true", "Neon-Array-Mode": "true" };
    Q === true && (he["Neon-Pool-Opt-In"] = "true"), Array.isArray(A) && (ce !== void 0 && (he["Neon-Batch-Isolation-Level"] = ce), ye !== void 0 && (he["Neon-Batch-Read-Only"] = String(ye)), xe !== void 0 && (he["Neon-Batch-Deferrable"] = String(xe)));
    let ie;
    try {
      ie = await (W ?? fetch)(ue, { method: "POST", body: JSON.stringify(de), headers: he, ...D });
    } catch (se) {
      let $ = new Ae(`Error connecting to database: ${se.message}`);
      throw $.sourceError = se, $;
    }
    if (ie.ok) {
      let se = await ie.json();
      if (Array.isArray(A)) {
        let $ = se.results;
        if (!Array.isArray($))
          throw new Ae("Neon internal error: unexpected result format");
        return $.map((ne2, Ce) => Vs(ne2, {
          arrayMode: L,
          fullResults: G,
          parameterizedQuery: A[Ce],
          resultCallback: c3
        }));
      } else
        return Vs(se, {
          arrayMode: L,
          fullResults: G,
          parameterizedQuery: A,
          resultCallback: c3
        });
    } else {
      let { status: se } = ie;
      if (se === 400) {
        let { message: $, code: ne2 } = await ie.json(), Ce = new Ae($);
        throw Ce.code = ne2, Ce;
      } else {
        let $ = await ie.text();
        throw new Ae(`Server error (HTTP status ${se}): ${$}`);
      }
    }
  }
  return a(
    pe,
    "execute"
  ), J;
}
a(Ys, "neon");
function Nc(r2, e3, t2) {
  return { [Symbol.toStringTag]: "NeonQueryPromise", parameterizedQuery: e3, opts: t2, then: (n2, i2) => r2(e3, t2).then(n2, i2), catch: (n2) => r2(
    e3,
    t2
  ).catch(n2), finally: (n2) => r2(e3, t2).finally(n2) };
}
a(Nc, "createNeonQueryPromise");
function Vs(r2, {
  arrayMode: e3,
  fullResults: t2,
  parameterizedQuery: n2,
  resultCallback: i2
}) {
  let s2 = r2.fields.map((c3) => c3.name), o2 = r2.fields.map((c3) => Se.types.getTypeParser(c3.dataTypeID)), u2 = e3 === true ? r2.rows.map((c3) => c3.map((h2, l3) => h2 === null ? null : o2[l3](h2))) : r2.rows.map((c3) => Object.fromEntries(
    c3.map((h2, l3) => [s2[l3], h2 === null ? null : o2[l3](h2)])
  ));
  return i2 && i2(n2, r2, u2, { arrayMode: e3, fullResults: t2 }), t2 ? (r2.viaNeonFetch = true, r2.rowAsArray = e3, r2.rows = u2, r2) : u2;
}
a(Vs, "processQueryResult");
var Js = We(gt());
var Se = We(At());
var En = class En2 extends Ct.Client {
  constructor(t2) {
    super(t2);
    this.config = t2;
  }
  get neonConfig() {
    return this.connection.stream;
  }
  connect(t2) {
    let { neonConfig: n2 } = this;
    n2.forceDisablePgSSL && (this.ssl = this.connection.ssl = false), this.ssl && n2.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
    let i2 = this.config?.host !== void 0 || this.config?.connectionString !== void 0 || m2.env.PGHOST !== void 0, s2 = m2.env.USER ?? m2.env.USERNAME;
    if (!i2 && this.host === "localhost" && this.user === s2 && this.database === s2 && this.password === null)
      throw new Error(`No database host or connection string was set, and key parameters have default values (host: localhost, user: ${s2}, db: ${s2}, password: null). Is an environment variable missing? Alternatively, if you intended to connect with these parameters, please set the host to 'localhost' explicitly.`);
    let o2 = super.connect(t2), u2 = n2.pipelineTLS && this.ssl, c3 = n2.pipelineConnect === "password";
    if (!u2 && !n2.pipelineConnect)
      return o2;
    let h2 = this.connection;
    if (u2 && h2.on("connect", () => h2.stream.emit("data", "S")), c3) {
      h2.removeAllListeners(
        "authenticationCleartextPassword"
      ), h2.removeAllListeners("readyForQuery"), h2.once(
        "readyForQuery",
        () => h2.on("readyForQuery", this._handleReadyForQuery.bind(this))
      );
      let l3 = this.ssl ? "sslconnect" : "connect";
      h2.on(l3, () => {
        this._handleAuthCleartextPassword(), this._handleReadyForQuery();
      });
    }
    return o2;
  }
  async _handleAuthSASLContinue(t2) {
    let n2 = this.saslSession, i2 = this.password, s2 = t2.data;
    if (n2.message !== "SASLInitialResponse" || typeof i2 != "string" || typeof s2 != "string")
      throw new Error("SASL: protocol error");
    let o2 = Object.fromEntries(s2.split(",").map(($) => {
      if (!/^.=/.test($))
        throw new Error("SASL: Invalid attribute pair entry");
      let ne2 = $[0], Ce = $.substring(2);
      return [ne2, Ce];
    })), u2 = o2.r, c3 = o2.s, h2 = o2.i;
    if (!u2 || !/^[!-+--~]+$/.test(u2))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable");
    if (!c3 || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(c3))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64");
    if (!h2 || !/^[1-9][0-9]*$/.test(h2))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count");
    if (!u2.startsWith(n2.clientNonce))
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce"
      );
    if (u2.length === n2.clientNonce.length)
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    let l3 = parseInt(h2, 10), y2 = d3.from(c3, "base64"), E = new TextEncoder(), _ = E.encode(i2), P2 = await w2.subtle.importKey("raw", _, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), N = new Uint8Array(await w2.subtle.sign("HMAC", P2, d3.concat([y2, d3.from(
      [0, 0, 0, 1]
    )]))), J = N;
    for (var pe = 0; pe < l3 - 1; pe++)
      N = new Uint8Array(await w2.subtle.sign(
        "HMAC",
        P2,
        N
      )), J = d3.from(J.map(($, ne2) => J[ne2] ^ N[ne2]));
    let A = J, g2 = await w2.subtle.importKey(
      "raw",
      A,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), D = new Uint8Array(await w2.subtle.sign("HMAC", g2, E.encode("Client Key"))), H = await w2.subtle.digest(
      "SHA-256",
      D
    ), Q = "n=*,r=" + n2.clientNonce, W = "r=" + u2 + ",s=" + c3 + ",i=" + l3, ue = "c=biws,r=" + u2, de = Q + "," + W + "," + ue, L = await w2.subtle.importKey(
      "raw",
      H,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    );
    var G = new Uint8Array(await w2.subtle.sign("HMAC", L, E.encode(de))), ce = d3.from(D.map(($, ne2) => D[ne2] ^ G[ne2])), ye = ce.toString("base64");
    let xe = await w2.subtle.importKey("raw", A, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), he = await w2.subtle.sign("HMAC", xe, E.encode("Server Key")), ie = await w2.subtle.importKey("raw", he, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var se = d3.from(await w2.subtle.sign("HMAC", ie, E.encode(de)));
    n2.message = "SASLResponse", n2.serverSignature = se.toString("base64"), n2.response = ue + ",p=" + ye, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
  }
};
a(En, "NeonClient");
var xn = En;
function Qc(r2, e3) {
  if (e3)
    return {
      callback: e3,
      result: void 0
    };
  let t2, n2, i2 = a(function(o2, u2) {
    o2 ? t2(o2) : n2(u2);
  }, "cb"), s2 = new r2(function(o2, u2) {
    n2 = o2, t2 = u2;
  });
  return { callback: i2, result: s2 };
}
a(Qc, "promisify");
var vn = class vn2 extends Ct.Pool {
  constructor() {
    super(...arguments);
    T(this, "Client", xn);
    T(this, "hasFetchUnsupportedListeners", false);
  }
  on(t2, n2) {
    return t2 !== "error" && (this.hasFetchUnsupportedListeners = true), super.on(t2, n2);
  }
  query(t2, n2, i2) {
    if (!_e.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t2 == "function")
      return super.query(t2, n2, i2);
    typeof n2 == "function" && (i2 = n2, n2 = void 0);
    let s2 = Qc(
      this.Promise,
      i2
    );
    i2 = s2.callback;
    try {
      let o2 = new Js.default(this.options), u2 = encodeURIComponent, c3 = encodeURI, h2 = `postgresql://${u2(o2.user)}:${u2(o2.password)}@${u2(o2.host)}/${c3(o2.database)}`, l3 = typeof t2 == "string" ? t2 : t2.text, y2 = n2 ?? t2.values ?? [];
      Ys(h2, { fullResults: true, arrayMode: t2.rowMode === "array" })(l3, y2).then((_) => i2(void 0, _)).catch((_) => i2(_));
    } catch (o2) {
      i2(o2);
    }
    return s2.result;
  }
};
a(vn, "NeonPool");
var export_ClientBase = Se.ClientBase;
var export_Connection = Se.Connection;
var export_DatabaseError = Se.DatabaseError;
var export_Query = Se.Query;
var export_defaults = Se.defaults;
var export_types = Se.types;

// ../node_modules/drizzle-orm/entity.js
init_modules_watch_stub();
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../node_modules/drizzle-orm/logger.js
init_modules_watch_stub();
var _a;
var ConsoleLogWriter = class {
  write(message2) {
    console.log(message2);
  }
};
_a = entityKind;
__publicField(ConsoleLogWriter, _a, "ConsoleLogWriter");
var _a2;
var DefaultLogger = class {
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p4) => {
      try {
        return JSON.stringify(p4);
      } catch {
        return String(p4);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
_a2 = entityKind;
__publicField(DefaultLogger, _a2, "DefaultLogger");
var _a3;
var NoopLogger = class {
  logQuery() {
  }
};
_a3 = entityKind;
__publicField(NoopLogger, _a3, "NoopLogger");

// ../node_modules/drizzle-orm/pg-core/db.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/query-builders/delete.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/query-promise.js
init_modules_watch_stub();
var _a4;
var QueryPromise = class {
  [(_a4 = entityKind, Symbol.toStringTag)] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};
__publicField(QueryPromise, _a4, "QueryPromise");

// ../node_modules/drizzle-orm/table.js
init_modules_watch_stub();
var TableName = Symbol.for("drizzle:Name");
var Schema2 = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var _a5;
var Table = class {
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [(_a5 = entityKind, TableName)];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema2];
  /** @internal */
  [Columns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  [IsDrizzleTable] = true;
  constructor(name, schema4, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema2] = schema4;
    this[BaseName] = baseName;
  }
};
__publicField(Table, _a5, "Table");
/** @internal */
__publicField(Table, "Symbol", {
  Name: TableName,
  Schema: Schema2,
  OriginalName,
  Columns,
  BaseName,
  IsAlias,
  ExtraConfigBuilder
});
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}

// ../node_modules/drizzle-orm/tracing.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/tracing-utils.js
init_modules_watch_stub();
function iife(fn, ...args) {
  return fn(...args);
}

// ../node_modules/drizzle-orm/version.js
init_modules_watch_stub();
var version = "0.30.1";

// ../node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span) => {
          try {
            return fn(span);
          } catch (e3) {
            span.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e3 instanceof Error ? e3.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e3;
          } finally {
            span.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// ../node_modules/drizzle-orm/utils.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/column.js
init_modules_watch_stub();
var _a6;
var Column = class {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
};
_a6 = entityKind;
__publicField(Column, _a6, "Column");

// ../node_modules/drizzle-orm/sql/sql.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/subquery.js
init_modules_watch_stub();
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");
var _a7;
var Subquery = class {
  /** @internal */
  [(_a7 = entityKind, SubqueryConfig)];
  constructor(sql2, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql2,
      selection,
      alias,
      isWith
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
__publicField(Subquery, _a7, "Subquery");
var _a8;
var WithSubquery = class extends Subquery {
};
_a8 = entityKind;
__publicField(WithSubquery, _a8, "WithSubquery");

// ../node_modules/drizzle-orm/view-common.js
init_modules_watch_stub();
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../node_modules/drizzle-orm/sql/sql.js
var _a9;
var FakePrimitiveParam = class {
};
_a9 = entityKind;
__publicField(FakePrimitiveParam, _a9, "FakePrimitiveParam");
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
var _a10;
var StringChunk = class {
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a10 = entityKind;
__publicField(StringChunk, _a10, "StringChunk");
var _a11;
var _SQL = class {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p4] of chunk.entries()) {
          result.push(p4);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== void 0) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
};
var SQL = _SQL;
_a11 = entityKind;
__publicField(SQL, _a11, "SQL");
var _a12;
var Name = class {
  constructor(value) {
    this.value = value;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a12 = entityKind;
__publicField(Name, _a12, "Name");
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var _a13;
var Param = class {
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a13 = entityKind;
__publicField(Param, _a13, "Param");
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var _a14;
var Placeholder = class {
  constructor(name2) {
    this.name = name2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a14 = entityKind;
__publicField(Placeholder, _a14, "Placeholder");
function fillPlaceholders(params, values) {
  return params.map((p4) => {
    if (is(p4, Placeholder)) {
      if (!(p4.name in values)) {
        throw new Error(`No value for placeholder "${p4.name}" was provided`);
      }
      return values[p4.name];
    }
    return p4;
  });
}
var _a15;
var View = class {
  /** @internal */
  [(_a15 = entityKind, ViewBaseConfig)];
  constructor({ name: name2, schema: schema4, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema: schema4,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
__publicField(View, _a15, "View");
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index2, key] of leftKeys.entries()) {
    if (key !== rightKeys[index2]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}

// ../node_modules/drizzle-orm/pg-core/query-builders/delete.js
var _a16;
var PgDeleteBase = class extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  config;
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will delete only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   *
   * ```ts
   * // Delete all cars with green color
   * await db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Delete all BMW cars with a green color
   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Delete all cars with the green or blue color
   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
_a16 = entityKind;
__publicField(PgDeleteBase, _a16, "PgDelete");

// ../node_modules/drizzle-orm/pg-core/query-builders/insert.js
init_modules_watch_stub();
var _a17;
var PgInsertBuilder = class {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
};
_a17 = entityKind;
__publicField(PgInsertBuilder, _a17, "PgInsertBuilder");
var _a18;
var PgInsertBase = class extends QueryPromise {
  constructor(table, values, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList };
  }
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   *
   * Calling this method simply avoids inserting a row as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   *
   * @param config The `target` and `where` clauses.
   *
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   *
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config = {}) {
    if (config.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
      const whereSql = config.where ? sql` where ${config.where}` : void 0;
      this.config.onConflict = sql`(${sql.raw(targetColumn)}) do nothing${whereSql}`;
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   *
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
   *
   * @param config The `target`, `set` and `where` clauses.
   *
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'Porsche' }
   *   });
   *
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config) {
    const whereSql = config.where ? sql` where ${config.where}` : void 0;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
    this.config.onConflict = sql`(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
_a18 = entityKind;
__publicField(PgInsertBase, _a18, "PgInsert");

// ../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/dialect.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/alias.js
init_modules_watch_stub();
var _a19;
var ColumnAliasProxyHandler = class {
  constructor(table) {
    this.table = table;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
_a19 = entityKind;
__publicField(ColumnAliasProxyHandler, _a19, "ColumnAliasProxyHandler");
var _a20;
var TableAliasProxyHandler = class {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(
          columns[key],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
_a20 = entityKind;
__publicField(TableAliasProxyHandler, _a20, "TableAliasProxyHandler");
var _a21;
var RelationTableAliasProxyHandler = class {
  constructor(alias) {
    this.alias = alias;
  }
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
_a21 = entityKind;
__publicField(RelationTableAliasProxyHandler, _a21, "RelationTableAliasProxyHandler");
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c3) => {
    if (is(c3, Column)) {
      return aliasedTableColumn(c3, alias);
    }
    if (is(c3, SQL)) {
      return mapColumnsInSQLToAlias(c3, alias);
    }
    if (is(c3, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c3, alias);
    }
    return c3;
  }));
}

// ../node_modules/drizzle-orm/errors.js
init_modules_watch_stub();
var _a22;
var DrizzleError = class extends Error {
  constructor({ message: message2, cause }) {
    super(message2);
    this.name = "DrizzleError";
    this.cause = cause;
  }
};
_a22 = entityKind;
__publicField(DrizzleError, _a22, "DrizzleError");
var _a23;
var TransactionRollbackError = class extends DrizzleError {
  constructor() {
    super({ message: "Rollback" });
  }
};
_a23 = entityKind;
__publicField(TransactionRollbackError, _a23, "TransactionRollbackError");

// ../node_modules/drizzle-orm/pg-core/columns/common.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/column-builder.js
init_modules_watch_stub();
var _a24;
var ColumnBuilder = class {
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
};
_a24 = entityKind;
__publicField(ColumnBuilder, _a24, "ColumnBuilder");

// ../node_modules/drizzle-orm/pg-core/foreign-keys.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/table.js
init_modules_watch_stub();
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var _a25;
var PgTable = class extends Table {
  /**@internal */
  [(_a25 = entityKind, InlineForeignKeys)] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__publicField(PgTable, _a25, "PgTable");
/** @internal */
__publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys
}));
function pgTableWithSchema(name, columns, extraConfig, schema4, baseName = name) {
  const rawTable = new PgTable(name, schema4, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, void 0);
};

// ../node_modules/drizzle-orm/pg-core/foreign-keys.js
var _a26;
var ForeignKeyBuilder = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey(table, this);
  }
};
_a26 = entityKind;
__publicField(ForeignKeyBuilder, _a26, "PgForeignKeyBuilder");
var _a27;
var ForeignKey = class {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
_a27 = entityKind;
__publicField(ForeignKey, _a27, "PgForeignKey");

// ../node_modules/drizzle-orm/pg-core/unique-constraint.js
init_modules_watch_stub();
function unique(name) {
  return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
  return `${table[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var _a28;
var UniqueConstraintBuilder = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
_a28 = entityKind;
__publicField(UniqueConstraintBuilder, _a28, "PgUniqueConstraintBuilder");
var _a29;
var UniqueOnConstraintBuilder = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
_a29 = entityKind;
__publicField(UniqueOnConstraintBuilder, _a29, "PgUniqueOnConstraintBuilder");
var _a30;
var UniqueConstraint = class {
  constructor(table, columns, nullsNotDistinct, name) {
    this.table = table;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};
_a30 = entityKind;
__publicField(UniqueConstraint, _a30, "PgUniqueConstraint");

// ../node_modules/drizzle-orm/pg-core/utils/array.js
init_modules_watch_stub();
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom; i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../node_modules/drizzle-orm/pg-core/columns/common.js
var _a31;
var PgColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife(
        (ref2, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table);
        },
        ref,
        actions
      );
    });
  }
};
_a31 = entityKind;
__publicField(PgColumnBuilder, _a31, "PgColumnBuilder");
var _a32;
var PgColumn = class extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
};
_a32 = entityKind;
__publicField(PgColumn, _a32, "PgColumn");
var _a33;
var PgArrayBuilder = class extends PgColumnBuilder {
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(
      table,
      this.config,
      baseColumn
    );
  }
};
_a33 = entityKind;
__publicField(PgArrayBuilder, _a33, "PgArrayBuilder");
var _a34;
var _PgArray = class extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v3) => this.baseColumn.mapFromDriverValue(v3));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a2 = value.map(
      (v3) => v3 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v3, true) : this.baseColumn.mapToDriverValue(v3)
    );
    if (isNestedArray)
      return a2;
    return makePgArray(a2);
  }
};
var PgArray = _PgArray;
_a34 = entityKind;
__publicField(PgArray, _a34, "PgArray");

// ../node_modules/drizzle-orm/pg-core/columns/boolean.js
init_modules_watch_stub();
var _a35;
var PgBooleanBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  /** @internal */
  build(table) {
    return new PgBoolean(table, this.config);
  }
};
_a35 = entityKind;
__publicField(PgBooleanBuilder, _a35, "PgBooleanBuilder");
var _a36;
var PgBoolean = class extends PgColumn {
  getSQLType() {
    return "boolean";
  }
};
_a36 = entityKind;
__publicField(PgBoolean, _a36, "PgBoolean");
function boolean(name) {
  return new PgBooleanBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/date.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/columns/date.common.js
init_modules_watch_stub();
var _a37;
var PgDateColumnBaseBuilder = class extends PgColumnBuilder {
  defaultNow() {
    return this.default(sql`now()`);
  }
};
_a37 = entityKind;
__publicField(PgDateColumnBaseBuilder, _a37, "PgDateColumnBaseBuilder");

// ../node_modules/drizzle-orm/pg-core/columns/date.js
var _a38;
var PgDateBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "date", "PgDate");
  }
  /** @internal */
  build(table) {
    return new PgDate(table, this.config);
  }
};
_a38 = entityKind;
__publicField(PgDateBuilder, _a38, "PgDateBuilder");
var _a39;
var PgDate = class extends PgColumn {
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
};
_a39 = entityKind;
__publicField(PgDate, _a39, "PgDate");
var _a40;
var PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  /** @internal */
  build(table) {
    return new PgDateString(
      table,
      this.config
    );
  }
};
_a40 = entityKind;
__publicField(PgDateStringBuilder, _a40, "PgDateStringBuilder");
var _a41;
var PgDateString = class extends PgColumn {
  getSQLType() {
    return "date";
  }
};
_a41 = entityKind;
__publicField(PgDateString, _a41, "PgDateString");

// ../node_modules/drizzle-orm/pg-core/columns/json.js
init_modules_watch_stub();
var _a42;
var PgJsonBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJson");
  }
  /** @internal */
  build(table) {
    return new PgJson(table, this.config);
  }
};
_a42 = entityKind;
__publicField(PgJsonBuilder, _a42, "PgJsonBuilder");
var _a43;
var PgJson = class extends PgColumn {
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
_a43 = entityKind;
__publicField(PgJson, _a43, "PgJson");

// ../node_modules/drizzle-orm/pg-core/columns/jsonb.js
init_modules_watch_stub();
var _a44;
var PgJsonbBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  /** @internal */
  build(table) {
    return new PgJsonb(table, this.config);
  }
};
_a44 = entityKind;
__publicField(PgJsonbBuilder, _a44, "PgJsonbBuilder");
var _a45;
var PgJsonb = class extends PgColumn {
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
_a45 = entityKind;
__publicField(PgJsonb, _a45, "PgJsonb");

// ../node_modules/drizzle-orm/pg-core/columns/numeric.js
init_modules_watch_stub();
var _a46;
var PgNumericBuilder = class extends PgColumnBuilder {
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumeric(table, this.config);
  }
};
_a46 = entityKind;
__publicField(PgNumericBuilder, _a46, "PgNumericBuilder");
var _a47;
var PgNumeric = class extends PgColumn {
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
_a47 = entityKind;
__publicField(PgNumeric, _a47, "PgNumeric");

// ../node_modules/drizzle-orm/pg-core/columns/text.js
init_modules_watch_stub();
var _a48;
var PgTextBuilder = class extends PgColumnBuilder {
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new PgText(table, this.config);
  }
};
_a48 = entityKind;
__publicField(PgTextBuilder, _a48, "PgTextBuilder");
var _a49;
var PgText = class extends PgColumn {
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
};
_a49 = entityKind;
__publicField(PgText, _a49, "PgText");
function text(name, config = {}) {
  return new PgTextBuilder(name, config);
}

// ../node_modules/drizzle-orm/pg-core/columns/time.js
init_modules_watch_stub();
var _a50;
var PgTimeBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTime(table, this.config);
  }
};
_a50 = entityKind;
__publicField(PgTimeBuilder, _a50, "PgTimeBuilder");
var _a51;
var PgTime = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
_a51 = entityKind;
__publicField(PgTime, _a51, "PgTime");

// ../node_modules/drizzle-orm/pg-core/columns/timestamp.js
init_modules_watch_stub();
var _a52;
var PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestamp(table, this.config);
  }
};
_a52 = entityKind;
__publicField(PgTimestampBuilder, _a52, "PgTimestampBuilder");
var _a53;
var PgTimestamp = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
};
_a53 = entityKind;
__publicField(PgTimestamp, _a53, "PgTimestamp");
var _a54;
var PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestampString(
      table,
      this.config
    );
  }
};
_a54 = entityKind;
__publicField(PgTimestampStringBuilder, _a54, "PgTimestampStringBuilder");
var _a55;
var PgTimestampString = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
_a55 = entityKind;
__publicField(PgTimestampString, _a55, "PgTimestampString");
function timestamp2(name, config = {}) {
  if (config.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

// ../node_modules/drizzle-orm/pg-core/columns/uuid.js
init_modules_watch_stub();
var _a56;
var PgUUIDBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  /**
   * Adds `default gen_random_uuid()` to the column definition.
   */
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  /** @internal */
  build(table) {
    return new PgUUID(table, this.config);
  }
};
_a56 = entityKind;
__publicField(PgUUIDBuilder, _a56, "PgUUIDBuilder");
var _a57;
var PgUUID = class extends PgColumn {
  getSQLType() {
    return "uuid";
  }
};
_a57 = entityKind;
__publicField(PgUUID, _a57, "PgUUID");
function uuid(name) {
  return new PgUUIDBuilder(name);
}

// ../node_modules/drizzle-orm/relations.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/primary-keys.js
init_modules_watch_stub();
var _a58;
var PrimaryKeyBuilder = class {
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
};
_a58 = entityKind;
__publicField(PrimaryKeyBuilder, _a58, "PgPrimaryKeyBuilder");
var _a59;
var PrimaryKey = class {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
_a59 = entityKind;
__publicField(PrimaryKey, _a59, "PgPrimaryKey");

// ../node_modules/drizzle-orm/sql/expressions/conditions.js
init_modules_watch_stub();
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c3) => c3 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or2(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c3) => c3 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt2 = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v3) => bindIfParam(v3, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v3) => bindIfParam(v3, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// ../node_modules/drizzle-orm/sql/expressions/select.js
init_modules_watch_stub();
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../node_modules/drizzle-orm/relations.js
var _a60;
var Relation = class {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  referencedTableName;
  fieldName;
};
_a60 = entityKind;
__publicField(Relation, _a60, "Relation");
var _a61;
var Relations = class {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
};
_a61 = entityKind;
__publicField(Relations, _a61, "Relations");
var _a62;
var _One = class extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var One = _One;
_a62 = entityKind;
__publicField(One, _a62, "One");
var _a63;
var _Many = class extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = _Many;
_a63 = entityKind;
__publicField(Many, _a63, "Many");
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt: gt2,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or: or2,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema4, configHelpers) {
  if (Object.keys(schema4).length === 1 && "default" in schema4 && !is(schema4["default"], Table)) {
    schema4 = schema4["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema4)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(
    table,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key)
      ])
    )
  );
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(
      sourceTable,
      table,
      config,
      config?.fields.reduce((res, f3) => res && f3.notNull, true) ?? false
    );
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema4, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema4[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// ../node_modules/drizzle-orm/pg-core/view-base.js
init_modules_watch_stub();
var _a64;
var PgViewBase = class extends View {
};
_a64 = entityKind;
__publicField(PgViewBase, _a64, "PgViewBase");

// ../node_modules/drizzle-orm/pg-core/dialect.js
var _a65;
var PgDialect = class {
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(
      sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`
    );
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(
            sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return void 0;
    const withSqlChunks = [sql`with `];
    for (const [i2, w3] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w3[SubqueryConfig].alias)} as (${w3[SubqueryConfig].sql})`);
      if (i2 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set2) {
    const setEntries = Object.entries(set2);
    const setSize = setEntries.length;
    return sql.join(
      setEntries.flatMap(([colName, value], i2) => {
        const col = table[Table.Symbol.Columns][colName];
        const res = sql`${sql.identifier(col.name)} = ${value}`;
        if (i2 < setSize - 1) {
          return [res, sql.raw(", ")];
        }
        return [res];
      })
    );
  }
  buildUpdateQuery({ table, set: set2, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table, set2);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(
            new SQL(
              query.queryChunks.map((c3) => {
                if (is(c3, PgColumn)) {
                  return sql.identifier(c3.name);
                }
                return c3;
              })
            )
          );
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f3 of fieldsList) {
      if (is(f3.field, Column) && getTableName(f3.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
        ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
      ))(f3.field.table)) {
        const tableName = getTableName(f3.field.table);
        throw new Error(
          `Your "${f3.path.join("->")}" field references a column "${tableName}"."${f3.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
        if (table[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
        if (is(table2, PgTable)) {
          const tableName = table2[PgTable.Symbol.Name];
          const tableSchema = table2[PgTable.Symbol.Schema];
          const origTableName = table2[PgTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
          );
        } else if (is(table2, View)) {
          const viewName = table2[ViewBaseConfig].name;
          const viewSchema = table2[ViewBaseConfig].schema;
          const origViewName = table2[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
          );
        } else {
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`
          );
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(
          sql` of ${sql.join(
            Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
            sql`, `
          )}`
        );
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : void 0;
    const withNoDataSql = withNoData ? sql` with no data` : void 0;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder, PgDate)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  // buildRelationalQueryWithPK({
  // 	fullSchema,
  // 	schema,
  // 	tableNamesMap,
  // 	table,
  // 	tableConfig,
  // 	queryConfig: config,
  // 	tableAlias,
  // 	isRoot = false,
  // 	joinOn,
  // }: {
  // 	fullSchema: Record<string, unknown>;
  // 	schema: TablesRelationalConfig;
  // 	tableNamesMap: Record<string, string>;
  // 	table: PgTable;
  // 	tableConfig: TableRelationalConfig;
  // 	queryConfig: true | DBQueryConfig<'many', true>;
  // 	tableAlias: string;
  // 	isRoot?: boolean;
  // 	joinOn?: SQL;
  // }): BuildRelationalQueryResult<PgTable, PgColumn> {
  // 	// For { "<relation>": true }, return a table with selection of all columns
  // 	if (config === true) {
  // 		const selectionEntries = Object.entries(tableConfig.columns);
  // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
  // 			[key, value],
  // 		) => ({
  // 			dbKey: value.name,
  // 			tsKey: key,
  // 			field: value as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection,
  // 		};
  // 	}
  // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// let selectionForBuild = selection;
  // 	const aliasedColumns = Object.fromEntries(
  // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
  // 	);
  // 	const aliasedRelations = Object.fromEntries(
  // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
  // 	);
  // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
  // 	let where, hasUserDefinedWhere;
  // 	if (config.where) {
  // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
  // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
  // 		hasUserDefinedWhere = !!where;
  // 	}
  // 	where = and(joinOn, where);
  // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
  // 	let joins: Join[] = [];
  // 	let selectedColumns: string[] = [];
  // 	// Figure out which columns to select
  // 	if (config.columns) {
  // 		let isIncludeMode = false;
  // 		for (const [field, value] of Object.entries(config.columns)) {
  // 			if (value === undefined) {
  // 				continue;
  // 			}
  // 			if (field in tableConfig.columns) {
  // 				if (!isIncludeMode && value === true) {
  // 					isIncludeMode = true;
  // 				}
  // 				selectedColumns.push(field);
  // 			}
  // 		}
  // 		if (selectedColumns.length > 0) {
  // 			selectedColumns = isIncludeMode
  // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
  // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
  // 		}
  // 	} else {
  // 		// Select all columns if selection is not specified
  // 		selectedColumns = Object.keys(tableConfig.columns);
  // 	}
  // 	// for (const field of selectedColumns) {
  // 	// 	const column = tableConfig.columns[field]! as PgColumn;
  // 	// 	fieldsSelection.push({ tsKey: field, value: column });
  // 	// }
  // 	let initiallySelectedRelations: {
  // 		tsKey: string;
  // 		queryConfig: true | DBQueryConfig<'many', false>;
  // 		relation: Relation;
  // 	}[] = [];
  // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// Figure out which relations to select
  // 	if (config.with) {
  // 		initiallySelectedRelations = Object.entries(config.with)
  // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
  // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
  // 	}
  // 	const manyRelations = initiallySelectedRelations.filter((r) =>
  // 		is(r.relation, Many)
  // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
  // 	);
  // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
  // 	const isInnermostQuery = manyRelations.length < 2;
  // 	const selectedExtras: {
  // 		tsKey: string;
  // 		value: SQL.Aliased;
  // 	}[] = [];
  // 	// Figure out which extras to select
  // 	if (isInnermostQuery && config.extras) {
  // 		const extras = typeof config.extras === 'function'
  // 			? config.extras(aliasedFields, { sql })
  // 			: config.extras;
  // 		for (const [tsKey, value] of Object.entries(extras)) {
  // 			selectedExtras.push({
  // 				tsKey,
  // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
  // 			});
  // 		}
  // 	}
  // 	// Transform `fieldsSelection` into `selection`
  // 	// `fieldsSelection` shouldn't be used after this point
  // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
  // 	// 	selection.push({
  // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
  // 	// 		tsKey,
  // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
  // 	// 		relationTableTsKey: undefined,
  // 	// 		isJson: false,
  // 	// 		isExtra,
  // 	// 		selection: [],
  // 	// 	});
  // 	// }
  // 	let orderByOrig = typeof config.orderBy === 'function'
  // 		? config.orderBy(aliasedFields, orderByOperators)
  // 		: config.orderBy ?? [];
  // 	if (!Array.isArray(orderByOrig)) {
  // 		orderByOrig = [orderByOrig];
  // 	}
  // 	const orderBy = orderByOrig.map((orderByValue) => {
  // 		if (is(orderByValue, Column)) {
  // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
  // 		}
  // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
  // 	});
  // 	const limit = isInnermostQuery ? config.limit : undefined;
  // 	const offset = isInnermostQuery ? config.offset : undefined;
  // 	// For non-root queries without additional config except columns, return a table with selection
  // 	if (
  // 		!isRoot
  // 		&& initiallySelectedRelations.length === 0
  // 		&& selectedExtras.length === 0
  // 		&& !where
  // 		&& orderBy.length === 0
  // 		&& limit === undefined
  // 		&& offset === undefined
  // 	) {
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection: selectedColumns.map((key) => ({
  // 				dbKey: tableConfig.columns[key]!.name,
  // 				tsKey: key,
  // 				field: tableConfig.columns[key] as PgColumn,
  // 				relationTableTsKey: undefined,
  // 				isJson: false,
  // 				selection: [],
  // 			})),
  // 		};
  // 	}
  // 	const selectedRelationsWithoutPK:
  // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of initiallySelectedRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length > 0) {
  // 			continue;
  // 		}
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithoutPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 			nestedQueryRelation: relation,
  // 		});
  // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
  // 		joins.push({
  // 			on: sql`true`,
  // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: true,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
  // 		is(r.relation, One)
  // 	);
  // 	// Process all One relations with PKs, because they can all be joined on the same level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of oneRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length === 0) {
  // 			continue;
  // 		}
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
  // 			sql.join(
  // 				builtRelation.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelation.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: is(builtRelation.sql, SQL)
  // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
  // 				: aliasedTable(builtRelation.sql, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: is(builtRelation.sql, SQL),
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	let distinct: PgSelectConfig['distinct'];
  // 	let tableFrom: PgTable | Subquery = table;
  // 	// Process first Many relation - each one requires a nested subquery
  // 	const manyRelation = manyRelations[0];
  // 	if (manyRelation) {
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			relation,
  // 		} = manyRelation;
  // 		distinct = {
  // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
  // 		};
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const builtRelationSelectionField = sql`case when ${
  // 			sql.identifier(relationTableAlias)
  // 		} is null then '[]' else json_agg(json_build_array(${
  // 			sql.join(
  // 				builtRelationJoin.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: isLateralJoin
  // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
  // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: isLateralJoin,
  // 		});
  // 		// Build the "from" subquery with the remaining Many relations
  // 		const builtTableFrom = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table,
  // 			tableConfig,
  // 			queryConfig: {
  // 				...config,
  // 				where: undefined,
  // 				orderBy: undefined,
  // 				limit: undefined,
  // 				offset: undefined,
  // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
  // 					(result, { tsKey, queryConfig: configValue }) => {
  // 						result[tsKey] = configValue;
  // 						return result;
  // 					},
  // 					{},
  // 				),
  // 			},
  // 			tableAlias,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field: builtRelationSelectionField,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelationJoin.selection,
  // 		});
  // 		// selection = builtTableFrom.selection.map((item) =>
  // 		// 	is(item.field, SQL.Aliased)
  // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 		// 		: item
  // 		// );
  // 		// selectionForBuild = [{
  // 		// 	dbKey: '*',
  // 		// 	tsKey: '*',
  // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
  // 		// 	selection: [],
  // 		// 	isJson: false,
  // 		// 	relationTableTsKey: undefined,
  // 		// }];
  // 		// const newSelectionItem: (typeof selection)[number] = {
  // 		// 	dbKey: selectedRelationTsKey,
  // 		// 	tsKey: selectedRelationTsKey,
  // 		// 	field,
  // 		// 	relationTableTsKey: relationTableTsName,
  // 		// 	isJson: true,
  // 		// 	selection: builtRelationJoin.selection,
  // 		// };
  // 		// selection.push(newSelectionItem);
  // 		// selectionForBuild.push(newSelectionItem);
  // 		tableFrom = is(builtTableFrom.sql, PgTable)
  // 			? builtTableFrom.sql
  // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
  // 	}
  // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
  // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
  // 	}
  // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
  // 	function prepareSelectedColumns() {
  // 		return selectedColumns.map((key) => ({
  // 			dbKey: tableConfig.columns[key]!.name,
  // 			tsKey: key,
  // 			field: tableConfig.columns[key] as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	function prepareSelectedExtras() {
  // 		return selectedExtras.map((item) => ({
  // 			dbKey: item.value.fieldAlias,
  // 			tsKey: item.tsKey,
  // 			field: item.value,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	if (isRoot) {
  // 		selection = [
  // 			...prepareSelectedColumns(),
  // 			...prepareSelectedExtras(),
  // 		];
  // 	}
  // 	if (hasUserDefinedWhere || orderBy.length > 0) {
  // 		tableFrom = new Subquery(
  // 			this.buildSelectQuery({
  // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 				fields: {},
  // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 					path: [],
  // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 				})),
  // 				joins,
  // 				distinct,
  // 			}),
  // 			{},
  // 			tableAlias,
  // 		);
  // 		selectionForBuild = selection.map((item) =>
  // 			is(item.field, SQL.Aliased)
  // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 				: item
  // 		);
  // 		joins = [];
  // 		distinct = undefined;
  // 	}
  // 	const result = this.buildSelectQuery({
  // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 		fields: {},
  // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 			path: [],
  // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 		})),
  // 		where,
  // 		limit,
  // 		offset,
  // 		joins,
  // 		orderBy,
  // 		distinct,
  // 	});
  // 	return {
  // 		tableTsKey: tableConfig.tsName,
  // 		sql: result,
  // 		selection,
  // 	};
  // }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema: schema4,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
      );
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c3) => config.columns?.[c3] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig2]) => ({ tsKey, queryConfig: queryConfig2, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema4, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i2) => eq(
              aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema: schema4,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema4[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(
        selection.map(
          ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
_a65 = entityKind;
__publicField(PgDialect, _a65, "PgDialect");

// ../node_modules/drizzle-orm/pg-core/query-builders/select.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/query-builders/query-builder.js
init_modules_watch_stub();
var _a66;
var TypedQueryBuilder = class {
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};
_a66 = entityKind;
__publicField(TypedQueryBuilder, _a66, "TypedQueryBuilder");

// ../node_modules/drizzle-orm/selection-proxy.js
init_modules_watch_stub();
var _a67;
var _SelectionProxyHandler = class {
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery[SubqueryConfig],
        selection: new Proxy(
          subquery[SubqueryConfig].selection,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value,
          new ColumnAliasProxyHandler(
            new Proxy(
              value.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};
var SelectionProxyHandler = _SelectionProxyHandler;
_a67 = entityKind;
__publicField(SelectionProxyHandler, _a67, "SelectionProxyHandler");

// ../node_modules/drizzle-orm/pg-core/query-builders/select.js
var _a68;
var PgSelectBuilder = class {
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  /**
   * Specify the table, subquery, or other target that you're
   * building a select query against.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
   */
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]])
      );
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
_a68 = entityKind;
__publicField(PgSelectBuilder, _a68, "PgSelectBuilder");
var _a69;
var PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on2) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on2 === "function") {
        on2 = on2(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on: on2, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left");
  /**
   * Executes a `right join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right");
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner");
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   *
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   *
   * @example
   *
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/pg-core'
   *
   * await union(
   *   db.select({ name: users.name }).from(users),
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   *
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   *
   * @example
   *
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/pg-core'
   *
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   *
   * @example
   *
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/pg-core'
   *
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `intersect all` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets including all duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
   *
   * @example
   *
   * ```ts
   * // Select all products and quantities that are ordered by both regular and VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered
   * })
   * .from(regularCustomerOrders)
   * .intersectAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { intersectAll } from 'drizzle-orm/pg-core'
   *
   * await intersectAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  intersectAll = this.createSetOperator("intersect", true);
  /**
   * Adds `except` set operator to the query.
   *
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   *
   * @example
   *
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/pg-core'
   *
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /**
   * Adds `except all` set operator to the query.
   *
   * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
   *
   * @example
   *
   * ```ts
   * // Select all products that are ordered by regular customers but not by VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered,
   * })
   * .from(regularCustomerOrders)
   * .exceptAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered,
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { exceptAll } from 'drizzle-orm/pg-core'
   *
   * await exceptAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  exceptAll = this.createSetOperator("except", true);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   *
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   *
   * @param having the `having` clause.
   *
   * @example
   *
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   *
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param limit the `limit` clause.
   *
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   *
   * Calling this method will skip a number of rows when returning results from this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param offset the `offset` clause.
   *
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /**
   * Adds a `for` clause to the query.
   *
   * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
   *
   * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
   *
   * @param strength the lock strength.
   * @param config the lock configuration.
   */
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias),
      new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
};
_a69 = entityKind;
__publicField(PgSelectQueryBuilderBase, _a69, "PgSelectQueryBuilder");
var _a70;
var PgSelectBase = class extends PgSelectQueryBuilderBase {
  /** @internal */
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  /**
   * Create a prepared statement for this query. This allows
   * the database to remember this query for the given session
   * and call it by name, rather than specifying the full query.
   *
   * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
   */
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
_a70 = entityKind;
__publicField(PgSelectBase, _a70, "PgSelect");
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var _a71;
var QueryBuilder = class {
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on2, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: { on: on2 }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on2, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on: on2 }
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect();
    }
    return this.dialect;
  }
};
_a71 = entityKind;
__publicField(QueryBuilder, _a71, "PgQueryBuilder");

// ../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
init_modules_watch_stub();
var _a72;
var PgRefreshMaterializedView = class extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  config;
  concurrently() {
    if (this.config.withNoData !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
_a72 = entityKind;
__publicField(PgRefreshMaterializedView, _a72, "PgRefreshMaterializedView");

// ../node_modules/drizzle-orm/pg-core/query-builders/update.js
init_modules_watch_stub();
var _a73;
var PgUpdateBuilder = class {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  set(values) {
    return new PgUpdateBase(
      this.table,
      mapUpdateSet(this.table, values),
      this.session,
      this.dialect,
      this.withList
    );
  }
};
_a73 = entityKind;
__publicField(PgUpdateBuilder, _a73, "PgUpdateBuilder");
var _a74;
var PgUpdateBase = class extends QueryPromise {
  constructor(table, set2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table, withList };
  }
  config;
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * await db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * await db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
};
_a74 = entityKind;
__publicField(PgUpdateBase, _a74, "PgUpdate");

// ../node_modules/drizzle-orm/pg-core/query-builders/query.js
init_modules_watch_stub();
var _a75;
var RelationalQueryBuilder = class {
  constructor(fullSchema, schema4, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema4;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  findMany(config) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config ? config : {},
      "many"
    );
  }
  findFirst(config) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config ? { ...config, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
_a75 = entityKind;
__publicField(RelationalQueryBuilder, _a75, "PgRelationalQueryBuilder");
var _a76;
var PgRelationalQuery = class extends QueryPromise {
  constructor(fullSchema, schema4, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema4;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  /** @internal */
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(
        builtQuery,
        void 0,
        name,
        (rawRows, mapColumnValue) => {
          const rows = rawRows.map(
            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
          );
          if (this.mode === "first") {
            return rows[0];
          }
          return rows;
        }
      );
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  /** @internal */
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
};
_a76 = entityKind;
__publicField(PgRelationalQuery, _a76, "PgRelationalQuery");

// ../node_modules/drizzle-orm/pg-core/query-builders/raw.js
init_modules_watch_stub();
var _a77;
var PgRaw = class extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  /** @internal */
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
};
_a77 = entityKind;
__publicField(PgRaw, _a77, "PgRaw");

// ../node_modules/drizzle-orm/pg-core/db.js
var _a78;
var PgDatabase = class {
  constructor(dialect, session, schema4) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema4 ? { schema: schema4.schema, tableNamesMap: schema4.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          schema4.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema4.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on2, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on: on2 }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on2, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on: on2 }
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query) {
    const sql2 = query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sql2);
    const prepared = this.session.prepareQuery(
      builtQuery,
      void 0,
      void 0
    );
    return new PgRaw(
      () => prepared.execute(),
      sql2,
      builtQuery,
      (result) => prepared.mapResult(result, false)
    );
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
};
_a78 = entityKind;
__publicField(PgDatabase, _a78, "PgDatabase");

// ../node_modules/drizzle-orm/neon-http/session.js
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/indexes.js
init_modules_watch_stub();
var _a79;
var IndexBuilderOn = class {
  constructor(unique2, name) {
    this.unique = unique2;
    this.name = name;
  }
  on(...columns) {
    return new IndexBuilder(columns, this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns, this.unique, true, this.name);
  }
};
_a79 = entityKind;
__publicField(IndexBuilderOn, _a79, "PgIndexBuilderOn");
var _a80;
var IndexBuilder = class {
  /** @internal */
  config;
  constructor(columns, unique2, only, name) {
    this.config = {
      name,
      columns,
      unique: unique2,
      only
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  using(method) {
    this.config.using = method;
    return this;
  }
  asc() {
    this.config.order = "asc";
    return this;
  }
  desc() {
    this.config.order = "desc";
    return this;
  }
  nullsFirst() {
    this.config.nulls = "first";
    return this;
  }
  nullsLast() {
    this.config.nulls = "last";
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index(this.config, table);
  }
};
_a80 = entityKind;
__publicField(IndexBuilder, _a80, "PgIndexBuilder");
var _a81;
var Index = class {
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
};
_a81 = entityKind;
__publicField(Index, _a81, "PgIndex");
function index(name) {
  return new IndexBuilderOn(false, name);
}

// ../node_modules/drizzle-orm/pg-core/session.js
init_modules_watch_stub();
var _a82;
var PgPreparedQuery = class {
  constructor(query) {
    this.query = query;
  }
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  /** @internal */
  joinsNotNullableMap;
};
_a82 = entityKind;
__publicField(PgPreparedQuery, _a82, "PgPreparedQuery");
var _a83;
var PgSession = class {
  constructor(dialect) {
    this.dialect = dialect;
  }
  execute(query) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0
        );
      });
      return prepared.execute();
    });
  }
  all(query) {
    return this.prepareQuery(
      this.dialect.sqlToQuery(query),
      void 0,
      void 0
    ).all();
  }
};
_a83 = entityKind;
__publicField(PgSession, _a83, "PgSession");
var _a84;
var PgTransaction = class extends PgDatabase {
  constructor(dialect, session, schema4, nestedIndex = 0) {
    super(dialect, session, schema4);
    this.schema = schema4;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
  /** @internal */
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
};
_a84 = entityKind;
__publicField(PgTransaction, _a84, "PgTransaction");

// ../node_modules/drizzle-orm/neon-http/session.js
var rawQueryConfig = {
  arrayMode: false,
  fullResults: true
};
var queryConfig = {
  arrayMode: true,
  fullResults: true
};
var _a85;
var NeonHttpPreparedQuery = class extends PgPreparedQuery {
  constructor(client, query, logger, fields, customResultMapper) {
    super(query);
    this.client = client;
    this.logger = logger;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
  }
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    const { fields, client, query, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return client(query.sql, params, rawQueryConfig);
    }
    const result = await client(query.sql, params, queryConfig);
    return this.mapResult(result);
  }
  mapResult(result) {
    if (!this.fields && !this.customResultMapper) {
      return result;
    }
    const rows = result.rows;
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.client(this.query.sql, params, rawQueryConfig).then((result) => result.rows);
  }
  values(placeholderValues = {}) {
    const params = fillPlaceholders(this.query.params, placeholderValues);
    this.logger.logQuery(this.query.sql, params);
    return this.client(this.query.sql, params).then((result) => result.rows);
  }
};
_a85 = entityKind;
__publicField(NeonHttpPreparedQuery, _a85, "NeonHttpPreparedQuery");
var _a86;
var NeonHttpSession = class extends PgSession {
  constructor(client, dialect, schema4, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema4;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
  }
  logger;
  prepareQuery(query, fields, name, customResultMapper) {
    return new NeonHttpPreparedQuery(
      this.client,
      query,
      this.logger,
      fields,
      customResultMapper
    );
  }
  async batch(queries) {
    const preparedQueries = [];
    const builtQueries = [];
    for (const query of queries) {
      const preparedQuery = query._prepare();
      const builtQuery = preparedQuery.getQuery();
      preparedQueries.push(preparedQuery);
      builtQueries.push(this.client(builtQuery.sql, builtQuery.params));
    }
    const batchResults = await this.client.transaction(builtQueries, queryConfig);
    return batchResults.map((result, i2) => preparedQueries[i2].mapResult(result, true));
  }
  // change return type to QueryRows<true>
  async query(query, params) {
    this.logger.logQuery(query, params);
    const result = await this.client(query, params, { arrayMode: true });
    return result;
  }
  // change return type to QueryRows<false>
  async queryObjects(query, params) {
    return this.client(query, params);
  }
  async transaction(_transaction, _config = {}) {
    throw new Error("No transactions support in neon-http driver");
  }
};
_a86 = entityKind;
__publicField(NeonHttpSession, _a86, "NeonHttpSession");
var _a87;
var NeonTransaction = class extends PgTransaction {
  async transaction(_transaction) {
    throw new Error("No transactions support in neon-http driver");
  }
};
_a87 = entityKind;
__publicField(NeonTransaction, _a87, "NeonHttpTransaction");

// ../node_modules/drizzle-orm/neon-http/driver.js
var _a88;
var NeonHttpDriver = class {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
    this.initMappers();
  }
  createSession(schema4) {
    return new NeonHttpSession(this.client, this.dialect, schema4, { logger: this.options.logger });
  }
  initMappers() {
    export_types.setTypeParser(export_types.builtins.TIMESTAMPTZ, (val) => val);
    export_types.setTypeParser(export_types.builtins.TIMESTAMP, (val) => val);
    export_types.setTypeParser(export_types.builtins.DATE, (val) => val);
  }
};
_a88 = entityKind;
__publicField(NeonHttpDriver, _a88, "NeonDriver");
var _a89;
var NeonHttpDatabase = class extends PgDatabase {
  async batch(batch) {
    return this.session.batch(batch);
  }
};
_a89 = entityKind;
__publicField(NeonHttpDatabase, _a89, "NeonHttpDatabase");
function drizzle(client, config = {}) {
  const dialect = new PgDialect();
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema4;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config.schema,
      createTableRelationsHelpers
    );
    schema4 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NeonHttpDriver(client, dialect, { logger });
  const session = driver.createSession(schema4);
  return new NeonHttpDatabase(
    dialect,
    session,
    schema4
  );
}

// lib/schema.ts
var schema_exports = {};
__export(schema_exports, {
  channel: () => channel,
  conversation: () => conversation,
  conversationRelations: () => conversationRelations,
  slackConnection: () => slackConnection,
  slackConnectionRelations: () => slackConnectionRelations,
  slackOauthState: () => slackOauthState,
  subscription: () => subscription,
  zendeskConnection: () => zendeskConnection
});
init_modules_watch_stub();
var slackOauthState = pgTable("slack_oauth_states", {
  id: uuid("id").primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }).defaultNow().notNull()
});
var slackConnection = pgTable("slack_connections", {
  id: uuid("id").defaultRandom().primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }).defaultNow().notNull(),
  updatedAt: timestamp2("updated_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }),
  slackTeamId: text("slack_team_id").notNull().unique(),
  name: text("name"),
  domain: text("domain"),
  emailDomain: text("email_domain"),
  iconUrl: text("icon_url"),
  slackEnterpriseId: text("slack_enterprise_id"),
  slackEnterpriseName: text("slack_enterprise_name"),
  encryptedToken: text("encrypted_token").notNull(),
  authedUserId: text("authed_user_id"),
  botUserId: text("bot_user_id").notNull(),
  appId: text("app_id").notNull().unique(),
  status: text("status"),
  subscriptionId: uuid("subscription_id").unique().references(() => subscription.id, {
    onDelete: "no action"
  }),
  stripeCustomerId: text("stripe_customer_id"),
  supportSlackChannelId: text("support_slack_channel_id"),
  supportSlackChannelName: text("support_slack_channel_name")
});
var zendeskConnection = pgTable("zendesk_connections", {
  id: uuid("id").defaultRandom().primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }).defaultNow().notNull(),
  updatedAt: timestamp2("updated_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }),
  slackConnectionId: uuid("slack_connection_id").notNull().unique().references(() => slackConnection.id, {
    onDelete: "cascade"
  }),
  zendeskDomain: text("zendesk_domain").notNull(),
  zendeskEmail: text("zendesk_email").notNull(),
  encryptedZendeskApiKey: text("encrypted_zendesk_api_key").notNull(),
  zendeskTriggerId: text("zendesk_trigger_id"),
  zendeskWebhookId: text("zendesk_webhook_id"),
  hashedWebhookBearerToken: text("hashed_webhook_bearer_token"),
  status: text("status")
});
var channel = pgTable(
  "channels",
  {
    id: uuid("id").defaultRandom().primaryKey().notNull(),
    createdAt: timestamp2("created_at", {
      mode: "date",
      withTimezone: true,
      precision: 3
    }).defaultNow().notNull(),
    updatedAt: timestamp2("updated_at", {
      mode: "date",
      withTimezone: true,
      precision: 3
    }),
    slackChannelIdentifier: text("slack_channel_identifier").notNull(),
    slackConnectionId: uuid("slack_connection_id").notNull().references(() => slackConnection.id, { onDelete: "cascade" }),
    type: text("type"),
    isMember: boolean("is_member"),
    name: text("name"),
    isShared: boolean("is_shared"),
    defaultAssigneeEmail: text("default_assignee_email"),
    latestActivityAt: timestamp2("latest_activity_at", {
      mode: "date",
      withTimezone: true,
      precision: 3
    }),
    tags: text("tags").array(),
    status: text("status")
  },
  (table) => ({
    channels_slack_connection_slack_channel_unique: unique().on(
      table.slackConnectionId,
      table.slackChannelIdentifier
    ),
    idx_channels_slack_connection_is_member: index().on(
      table.slackConnectionId,
      table.isMember
    )
  })
);
var conversation = pgTable(
  "conversations",
  {
    id: uuid("id").defaultRandom().primaryKey().notNull(),
    createdAt: timestamp2("created_at", {
      mode: "date",
      withTimezone: true,
      precision: 3
    }).defaultNow().notNull(),
    updatedAt: timestamp2("updated_at", {
      mode: "date",
      withTimezone: true,
      precision: 3
    }),
    channelId: uuid("channel_id").notNull().references(() => channel.id, { onDelete: "cascade" }),
    zendeskTicketId: text("zendesk_ticket_id").notNull(),
    slackParentMessageId: text("slack_parent_message_id").notNull(),
    slackAuthorUserId: text("slack_author_user_id").notNull(),
    latestSlackMessageId: text("latest_slack_message_id")
  },
  (table) => ({
    conversations_channel_zendesk_ticket_unique: unique().on(
      table.channelId,
      table.zendeskTicketId
    ),
    conversations_channel_slack_message_unique: unique().on(
      table.channelId,
      table.slackParentMessageId
    )
  })
);
var conversationRelations = relations(conversation, ({ one }) => ({
  channel: one(channel, {
    fields: [conversation.channelId],
    references: [channel.id]
  })
}));
var subscription = pgTable("subscriptions", {
  id: uuid("id").defaultRandom().primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }).defaultNow().notNull(),
  updatedAt: timestamp2("updated_at", {
    mode: "date",
    withTimezone: true,
    precision: 3
  }),
  stripeSubscriptionId: text("stripe_subscription_id").unique().notNull(),
  stripeProductId: text("stripe_product_id").notNull(),
  periodStart: timestamp2("period_start", {
    mode: "date",
    withTimezone: true
  }),
  periodEnd: timestamp2("period_end", {
    mode: "date",
    withTimezone: true
  }),
  canceledAt: timestamp2("canceled_at", {
    mode: "date",
    withTimezone: true
  })
});
var slackConnectionRelations = relations(
  slackConnection,
  ({ one }) => ({
    subscription: one(subscription, {
      fields: [slackConnection.subscriptionId],
      references: [subscription.id]
    })
  })
);

// lib/drizzle.ts
function initializeDb(env) {
  const sql2 = Ys(env.POSTGRES_URL);
  const db = drizzle(sql2, { schema: schema_exports });
  return db;
}

// lib/utils.ts
init_modules_watch_stub();

// lib/encryption.ts
init_modules_watch_stub();
async function encryptData(data, key) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encodedData = new TextEncoder().encode(data);
  const encryptedData = await crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    encodedData
  );
  const combinedIvAndData = new Uint8Array(
    iv.length + encryptedData.byteLength
  );
  combinedIvAndData.set(iv, 0);
  combinedIvAndData.set(new Uint8Array(encryptedData), iv.length);
  return btoa(String.fromCharCode(...combinedIvAndData));
}
async function decryptData(base64DataWithIv, key) {
  const binaryStr = atob(base64DataWithIv);
  const len = binaryStr.length;
  const bytes = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    bytes[i2] = binaryStr.charCodeAt(i2);
  }
  const iv = bytes.slice(0, 12);
  const encryptedData = bytes.slice(12);
  const decryptedBuffer = await crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    encryptedData
  );
  return new TextDecoder().decode(decryptedBuffer);
}
var encryptionKey;
async function importEncryptionKeyFromEnvironment(env) {
  if (encryptionKey) {
    return encryptionKey;
  }
  const rawKey = atob(env.ENCRYPTION_KEY);
  const keyBuffer = new Uint8Array(new ArrayBuffer(rawKey.length));
  for (let i2 = 0; i2 < rawKey.length; i2++) {
    keyBuffer[i2] = rawKey.charCodeAt(i2);
  }
  encryptionKey = await crypto.subtle.importKey(
    "raw",
    keyBuffer,
    { name: "AES-GCM", length: 256 },
    false,
    // Whether the key is extractable
    ["encrypt", "decrypt"]
  );
  return encryptionKey;
}

// node_modules/stripe/esm/stripe.esm.worker.js
init_modules_watch_stub();

// node_modules/stripe/esm/platform/WebPlatformFunctions.js
init_modules_watch_stub();

// node_modules/stripe/esm/platform/PlatformFunctions.js
init_modules_watch_stub();

// node_modules/stripe/esm/net/FetchHttpClient.js
init_modules_watch_stub();

// node_modules/stripe/esm/net/HttpClient.js
init_modules_watch_stub();
var HttpClient = class {
  /** The client name used for diagnostics. */
  getClientName() {
    throw new Error("getClientName not implemented.");
  }
  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
    throw new Error("makeRequest not implemented.");
  }
  /** Helper to make a consistent timeout error across implementations. */
  static makeTimeoutError() {
    const timeoutErr = new TypeError(HttpClient.TIMEOUT_ERROR_CODE);
    timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;
    return timeoutErr;
  }
};
HttpClient.CONNECTION_CLOSED_ERROR_CODES = ["ECONNRESET", "EPIPE"];
HttpClient.TIMEOUT_ERROR_CODE = "ETIMEDOUT";
var HttpClientResponse = class {
  constructor(statusCode, headers) {
    this._statusCode = statusCode;
    this._headers = headers;
  }
  getStatusCode() {
    return this._statusCode;
  }
  getHeaders() {
    return this._headers;
  }
  getRawResponse() {
    throw new Error("getRawResponse not implemented.");
  }
  toStream(streamCompleteCallback) {
    throw new Error("toStream not implemented.");
  }
  toJSON() {
    throw new Error("toJSON not implemented.");
  }
};

// node_modules/stripe/esm/net/FetchHttpClient.js
var FetchHttpClient = class extends HttpClient {
  constructor(fetchFn) {
    super();
    if (!fetchFn) {
      if (!globalThis.fetch) {
        throw new Error("fetch() function not provided and is not defined in the global scope. You must provide a fetch implementation.");
      }
      fetchFn = globalThis.fetch;
    }
    if (globalThis.AbortController) {
      this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);
    } else {
      this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);
    }
  }
  static makeFetchWithRaceTimeout(fetchFn) {
    return (url, init, timeout) => {
      let pendingTimeoutId;
      const timeoutPromise = new Promise((_, reject) => {
        pendingTimeoutId = setTimeout(() => {
          pendingTimeoutId = null;
          reject(HttpClient.makeTimeoutError());
        }, timeout);
      });
      const fetchPromise = fetchFn(url, init);
      return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
        if (pendingTimeoutId) {
          clearTimeout(pendingTimeoutId);
        }
      });
    };
  }
  static makeFetchWithAbortTimeout(fetchFn) {
    return async (url, init, timeout) => {
      const abort = new AbortController();
      let timeoutId = setTimeout(() => {
        timeoutId = null;
        abort.abort(HttpClient.makeTimeoutError());
      }, timeout);
      try {
        return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));
      } catch (err) {
        if (err.name === "AbortError") {
          throw HttpClient.makeTimeoutError();
        } else {
          throw err;
        }
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    };
  }
  /** @override. */
  getClientName() {
    return "fetch";
  }
  async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
    const isInsecureConnection = protocol === "http";
    const url = new URL(path, `${isInsecureConnection ? "http" : "https"}://${host}`);
    url.port = port;
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    const body = requestData || (methodHasPayload ? "" : void 0);
    const res = await this._fetchFn(url.toString(), {
      method,
      // @ts-ignore
      headers,
      // @ts-ignore
      body
    }, timeout);
    return new FetchHttpClientResponse(res);
  }
};
var FetchHttpClientResponse = class extends HttpClientResponse {
  constructor(res) {
    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));
    this._res = res;
  }
  getRawResponse() {
    return this._res;
  }
  toStream(streamCompleteCallback) {
    streamCompleteCallback();
    return this._res.body;
  }
  toJSON() {
    return this._res.json();
  }
  static _transformHeadersToObject(headers) {
    const headersObj = {};
    for (const entry of headers) {
      if (!Array.isArray(entry) || entry.length != 2) {
        throw new Error("Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.");
      }
      headersObj[entry[0]] = entry[1];
    }
    return headersObj;
  }
};

// node_modules/stripe/esm/crypto/SubtleCryptoProvider.js
init_modules_watch_stub();

// node_modules/stripe/esm/crypto/CryptoProvider.js
init_modules_watch_stub();
var CryptoProvider = class {
  /**
   * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
   * The output HMAC should be encoded in hexadecimal.
   *
   * Sample values for implementations:
   * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
   * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
   */
  computeHMACSignature(payload, secret) {
    throw new Error("computeHMACSignature not implemented.");
  }
  /**
   * Asynchronous version of `computeHMACSignature`. Some implementations may
   * only allow support async signature computation.
   *
   * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
   * The output HMAC should be encoded in hexadecimal.
   *
   * Sample values for implementations:
   * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
   * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
   */
  computeHMACSignatureAsync(payload, secret) {
    throw new Error("computeHMACSignatureAsync not implemented.");
  }
};
var CryptoProviderOnlySupportsAsyncError = class extends Error {
};

// node_modules/stripe/esm/crypto/SubtleCryptoProvider.js
var SubtleCryptoProvider = class extends CryptoProvider {
  constructor(subtleCrypto) {
    super();
    this.subtleCrypto = subtleCrypto || crypto.subtle;
  }
  /** @override */
  computeHMACSignature(payload, secret) {
    throw new CryptoProviderOnlySupportsAsyncError("SubtleCryptoProvider cannot be used in a synchronous context.");
  }
  /** @override */
  async computeHMACSignatureAsync(payload, secret) {
    const encoder = new TextEncoder();
    const key = await this.subtleCrypto.importKey("raw", encoder.encode(secret), {
      name: "HMAC",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const signatureBuffer = await this.subtleCrypto.sign("hmac", key, encoder.encode(payload));
    const signatureBytes = new Uint8Array(signatureBuffer);
    const signatureHexCodes = new Array(signatureBytes.length);
    for (let i2 = 0; i2 < signatureBytes.length; i2++) {
      signatureHexCodes[i2] = byteHexMapping[signatureBytes[i2]];
    }
    return signatureHexCodes.join("");
  }
};
var byteHexMapping = new Array(256);
for (let i2 = 0; i2 < byteHexMapping.length; i2++) {
  byteHexMapping[i2] = i2.toString(16).padStart(2, "0");
}

// node_modules/stripe/esm/platform/PlatformFunctions.js
var PlatformFunctions = class {
  constructor() {
    this._fetchFn = null;
    this._agent = null;
  }
  /**
   * Gets uname with Node's built-in `exec` function, if available.
   */
  getUname() {
    throw new Error("getUname not implemented.");
  }
  /**
   * Generates a v4 UUID. See https://stackoverflow.com/a/2117523
   */
  uuid4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c3) => {
      const r2 = Math.random() * 16 | 0;
      const v3 = c3 === "x" ? r2 : r2 & 3 | 8;
      return v3.toString(16);
    });
  }
  /**
   * Compares strings in constant time.
   */
  secureCompare(a2, b3) {
    if (a2.length !== b3.length) {
      return false;
    }
    const len = a2.length;
    let result = 0;
    for (let i2 = 0; i2 < len; ++i2) {
      result |= a2.charCodeAt(i2) ^ b3.charCodeAt(i2);
    }
    return result === 0;
  }
  /**
   * Creates an event emitter.
   */
  createEmitter() {
    throw new Error("createEmitter not implemented.");
  }
  /**
   * Checks if the request data is a stream. If so, read the entire stream
   * to a buffer and return the buffer.
   */
  tryBufferData(data) {
    throw new Error("tryBufferData not implemented.");
  }
  /**
   * Creates an HTTP client which uses the Node `http` and `https` packages
   * to issue requests.
   */
  createNodeHttpClient(agent) {
    throw new Error("createNodeHttpClient not implemented.");
  }
  /**
   * Creates an HTTP client for issuing Stripe API requests which uses the Web
   * Fetch API.
   *
   * A fetch function can optionally be passed in as a parameter. If none is
   * passed, will default to the default `fetch` function in the global scope.
   */
  createFetchHttpClient(fetchFn) {
    return new FetchHttpClient(fetchFn);
  }
  /**
   * Creates an HTTP client using runtime-specific APIs.
   */
  createDefaultHttpClient() {
    throw new Error("createDefaultHttpClient not implemented.");
  }
  /**
   * Creates a CryptoProvider which uses the Node `crypto` package for its computations.
   */
  createNodeCryptoProvider() {
    throw new Error("createNodeCryptoProvider not implemented.");
  }
  /**
   * Creates a CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
   */
  createSubtleCryptoProvider(subtleCrypto) {
    return new SubtleCryptoProvider(subtleCrypto);
  }
  createDefaultCryptoProvider() {
    throw new Error("createDefaultCryptoProvider not implemented.");
  }
};

// node_modules/stripe/esm/StripeEmitter.js
init_modules_watch_stub();
var _StripeEvent = class extends Event {
  constructor(eventName, data) {
    super(eventName);
    this.data = data;
  }
};
var StripeEmitter = class {
  constructor() {
    this.eventTarget = new EventTarget();
    this.listenerMapping = /* @__PURE__ */ new Map();
  }
  on(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper);
  }
  removeListener(eventName, listener) {
    const listenerWrapper = this.listenerMapping.get(listener);
    this.listenerMapping.delete(listener);
    return this.eventTarget.removeEventListener(eventName, listenerWrapper);
  }
  once(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper, {
      once: true
    });
  }
  emit(eventName, data) {
    return this.eventTarget.dispatchEvent(new _StripeEvent(eventName, data));
  }
};

// node_modules/stripe/esm/platform/WebPlatformFunctions.js
var WebPlatformFunctions = class extends PlatformFunctions {
  /** @override */
  getUname() {
    return Promise.resolve(null);
  }
  /** @override */
  createEmitter() {
    return new StripeEmitter();
  }
  /** @override */
  tryBufferData(data) {
    if (data.file.data instanceof ReadableStream) {
      throw new Error("Uploading a file as a stream is not supported in non-Node environments. Please open or upvote an issue at github.com/stripe/stripe-node if you use this, detailing your use-case.");
    }
    return Promise.resolve(data);
  }
  /** @override */
  createNodeHttpClient() {
    throw new Error("Stripe: `createNodeHttpClient()` is not available in non-Node environments. Please use `createFetchHttpClient()` instead.");
  }
  /** @override */
  createDefaultHttpClient() {
    return super.createFetchHttpClient();
  }
  /** @override */
  createNodeCryptoProvider() {
    throw new Error("Stripe: `createNodeCryptoProvider()` is not available in non-Node environments. Please use `createSubtleCryptoProvider()` instead.");
  }
  /** @override */
  createDefaultCryptoProvider() {
    return this.createSubtleCryptoProvider();
  }
};

// node_modules/stripe/esm/stripe.core.js
init_modules_watch_stub();

// node_modules/stripe/esm/Error.js
var Error_exports = {};
__export(Error_exports, {
  StripeAPIError: () => StripeAPIError,
  StripeAuthenticationError: () => StripeAuthenticationError,
  StripeCardError: () => StripeCardError,
  StripeConnectionError: () => StripeConnectionError,
  StripeError: () => StripeError,
  StripeIdempotencyError: () => StripeIdempotencyError,
  StripeInvalidGrantError: () => StripeInvalidGrantError,
  StripeInvalidRequestError: () => StripeInvalidRequestError,
  StripePermissionError: () => StripePermissionError,
  StripeRateLimitError: () => StripeRateLimitError,
  StripeSignatureVerificationError: () => StripeSignatureVerificationError,
  StripeUnknownError: () => StripeUnknownError,
  generate: () => generate
});
init_modules_watch_stub();
var generate = (rawStripeError) => {
  switch (rawStripeError.type) {
    case "card_error":
      return new StripeCardError(rawStripeError);
    case "invalid_request_error":
      return new StripeInvalidRequestError(rawStripeError);
    case "api_error":
      return new StripeAPIError(rawStripeError);
    case "authentication_error":
      return new StripeAuthenticationError(rawStripeError);
    case "rate_limit_error":
      return new StripeRateLimitError(rawStripeError);
    case "idempotency_error":
      return new StripeIdempotencyError(rawStripeError);
    case "invalid_grant":
      return new StripeInvalidGrantError(rawStripeError);
    default:
      return new StripeUnknownError(rawStripeError);
  }
};
var StripeError = class extends Error {
  constructor(raw = {}) {
    super(raw.message);
    this.type = this.constructor.name;
    this.raw = raw;
    this.rawType = raw.type;
    this.code = raw.code;
    this.doc_url = raw.doc_url;
    this.param = raw.param;
    this.detail = raw.detail;
    this.headers = raw.headers;
    this.requestId = raw.requestId;
    this.statusCode = raw.statusCode;
    this.message = raw.message;
    this.charge = raw.charge;
    this.decline_code = raw.decline_code;
    this.payment_intent = raw.payment_intent;
    this.payment_method = raw.payment_method;
    this.payment_method_type = raw.payment_method_type;
    this.setup_intent = raw.setup_intent;
    this.source = raw.source;
  }
};
StripeError.generate = generate;
var StripeCardError = class extends StripeError {
};
var StripeInvalidRequestError = class extends StripeError {
};
var StripeAPIError = class extends StripeError {
};
var StripeAuthenticationError = class extends StripeError {
};
var StripePermissionError = class extends StripeError {
};
var StripeRateLimitError = class extends StripeError {
};
var StripeConnectionError = class extends StripeError {
};
var StripeSignatureVerificationError = class extends StripeError {
  constructor(header, payload, raw = {}) {
    super(raw);
    this.header = header;
    this.payload = payload;
  }
};
var StripeIdempotencyError = class extends StripeError {
};
var StripeInvalidGrantError = class extends StripeError {
};
var StripeUnknownError = class extends StripeError {
};

// node_modules/stripe/esm/apiVersion.js
init_modules_watch_stub();
var ApiVersion = "2023-10-16";

// node_modules/stripe/esm/resources.js
var resources_exports = {};
__export(resources_exports, {
  Account: () => Accounts2,
  AccountLinks: () => AccountLinks,
  AccountSessions: () => AccountSessions,
  Accounts: () => Accounts2,
  ApplePayDomains: () => ApplePayDomains,
  ApplicationFees: () => ApplicationFees,
  Apps: () => Apps,
  Balance: () => Balance,
  BalanceTransactions: () => BalanceTransactions,
  BillingPortal: () => BillingPortal,
  Charges: () => Charges,
  Checkout: () => Checkout,
  Climate: () => Climate,
  CountrySpecs: () => CountrySpecs,
  Coupons: () => Coupons,
  CreditNotes: () => CreditNotes,
  CustomerSessions: () => CustomerSessions,
  Customers: () => Customers2,
  Disputes: () => Disputes2,
  EphemeralKeys: () => EphemeralKeys,
  Events: () => Events,
  ExchangeRates: () => ExchangeRates,
  FileLinks: () => FileLinks,
  Files: () => Files,
  FinancialConnections: () => FinancialConnections,
  Identity: () => Identity,
  InvoiceItems: () => InvoiceItems,
  Invoices: () => Invoices,
  Issuing: () => Issuing,
  Mandates: () => Mandates,
  OAuth: () => OAuth,
  PaymentIntents: () => PaymentIntents,
  PaymentLinks: () => PaymentLinks,
  PaymentMethodConfigurations: () => PaymentMethodConfigurations,
  PaymentMethodDomains: () => PaymentMethodDomains,
  PaymentMethods: () => PaymentMethods,
  Payouts: () => Payouts,
  Plans: () => Plans,
  Prices: () => Prices,
  Products: () => Products2,
  PromotionCodes: () => PromotionCodes,
  Quotes: () => Quotes,
  Radar: () => Radar,
  Refunds: () => Refunds2,
  Reporting: () => Reporting,
  Reviews: () => Reviews,
  SetupAttempts: () => SetupAttempts,
  SetupIntents: () => SetupIntents,
  ShippingRates: () => ShippingRates,
  Sigma: () => Sigma,
  Sources: () => Sources,
  SubscriptionItems: () => SubscriptionItems,
  SubscriptionSchedules: () => SubscriptionSchedules,
  Subscriptions: () => Subscriptions,
  Tax: () => Tax,
  TaxCodes: () => TaxCodes,
  TaxRates: () => TaxRates,
  Terminal: () => Terminal,
  TestHelpers: () => TestHelpers,
  Tokens: () => Tokens2,
  Topups: () => Topups,
  Transfers: () => Transfers,
  Treasury: () => Treasury,
  WebhookEndpoints: () => WebhookEndpoints
});
init_modules_watch_stub();

// node_modules/stripe/esm/ResourceNamespace.js
init_modules_watch_stub();
function ResourceNamespace(stripe, resources) {
  for (const name in resources) {
    const camelCaseName = name[0].toLowerCase() + name.substring(1);
    const resource = new resources[name](stripe);
    this[camelCaseName] = resource;
  }
}
function resourceNamespace(namespace, resources) {
  return function(stripe) {
    return new ResourceNamespace(stripe, resources);
  };
}

// node_modules/stripe/esm/resources/FinancialConnections/Accounts.js
init_modules_watch_stub();

// node_modules/stripe/esm/StripeResource.js
init_modules_watch_stub();

// node_modules/stripe/esm/utils.js
init_modules_watch_stub();
var qs = __toESM(require_lib(), 1);
var OPTIONS_KEYS = [
  "apiKey",
  "idempotencyKey",
  "stripeAccount",
  "apiVersion",
  "maxNetworkRetries",
  "timeout",
  "host"
];
function isOptionsHash(o2) {
  return o2 && typeof o2 === "object" && OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o2, prop));
}
function stringifyRequestData(data) {
  return qs.stringify(data, {
    serializeDate: (d4) => Math.floor(d4.getTime() / 1e3).toString()
  }).replace(/%5B/g, "[").replace(/%5D/g, "]");
}
var makeURLInterpolator = (() => {
  const rc2 = {
    "\n": "\\n",
    '"': '\\"',
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  return (str) => {
    const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc2[$0]);
    return (outputs) => {
      return cleanString.replace(/\{([\s\S]+?)\}/g, ($0, $1) => (
        // @ts-ignore
        encodeURIComponent(outputs[$1] || "")
      ));
    };
  };
})();
function extractUrlParams(path) {
  const params = path.match(/\{\w+\}/g);
  if (!params) {
    return [];
  }
  return params.map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!Array.isArray(args) || !args[0] || typeof args[0] !== "object") {
    return {};
  }
  if (!isOptionsHash(args[0])) {
    return args.shift();
  }
  const argKeys = Object.keys(args[0]);
  const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
  if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {
    emitWarning(`Options found in arguments (${optionKeysInArgs.join(", ")}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.`);
  }
  return {};
}
function getOptionsFromArgs(args) {
  const opts = {
    auth: null,
    host: null,
    headers: {},
    settings: {}
  };
  if (args.length > 0) {
    const arg = args[args.length - 1];
    if (typeof arg === "string") {
      opts.auth = args.pop();
    } else if (isOptionsHash(arg)) {
      const params = Object.assign({}, args.pop());
      const extraKeys = Object.keys(params).filter((key) => !OPTIONS_KEYS.includes(key));
      if (extraKeys.length) {
        emitWarning(`Invalid options found (${extraKeys.join(", ")}); ignoring.`);
      }
      if (params.apiKey) {
        opts.auth = params.apiKey;
      }
      if (params.idempotencyKey) {
        opts.headers["Idempotency-Key"] = params.idempotencyKey;
      }
      if (params.stripeAccount) {
        opts.headers["Stripe-Account"] = params.stripeAccount;
      }
      if (params.apiVersion) {
        opts.headers["Stripe-Version"] = params.apiVersion;
      }
      if (Number.isInteger(params.maxNetworkRetries)) {
        opts.settings.maxNetworkRetries = params.maxNetworkRetries;
      }
      if (Number.isInteger(params.timeout)) {
        opts.settings.timeout = params.timeout;
      }
      if (params.host) {
        opts.host = params.host;
      }
    }
  }
  return opts;
}
function protoExtend(sub) {
  const Super = this;
  const Constructor = Object.prototype.hasOwnProperty.call(sub, "constructor") ? sub.constructor : function(...args) {
    Super.apply(this, args);
  };
  Object.assign(Constructor, Super);
  Constructor.prototype = Object.create(Super.prototype);
  Object.assign(Constructor.prototype, sub);
  return Constructor;
}
function removeNullish(obj) {
  if (typeof obj !== "object") {
    throw new Error("Argument must be an object");
  }
  return Object.keys(obj).reduce((result, key) => {
    if (obj[key] != null) {
      result[key] = obj[key];
    }
    return result;
  }, {});
}
function normalizeHeaders(obj) {
  if (!(obj && typeof obj === "object")) {
    return obj;
  }
  return Object.keys(obj).reduce((result, header) => {
    result[normalizeHeader(header)] = obj[header];
    return result;
  }, {});
}
function normalizeHeader(header) {
  return header.split("-").map((text2) => text2.charAt(0).toUpperCase() + text2.substr(1).toLowerCase()).join("-");
}
function callbackifyPromiseWithTimeout(promise, callback) {
  if (callback) {
    return promise.then((res) => {
      setTimeout(() => {
        callback(null, res);
      }, 0);
    }, (err) => {
      setTimeout(() => {
        callback(err, null);
      }, 0);
    });
  }
  return promise;
}
function pascalToCamelCase(name) {
  if (name === "OAuth") {
    return "oauth";
  } else {
    return name[0].toLowerCase() + name.substring(1);
  }
}
function emitWarning(warning) {
  if (typeof process.emitWarning !== "function") {
    return console.warn(`Stripe: ${warning}`);
  }
  return process.emitWarning(warning, "Stripe");
}
function isObject(obj) {
  const type = typeof obj;
  return (type === "function" || type === "object") && !!obj;
}
function flattenAndStringify(data) {
  const result = {};
  const step = (obj, prevKey) => {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      const newKey = prevKey ? `${prevKey}[${key}]` : key;
      if (isObject(value)) {
        if (!(value instanceof Uint8Array) && !Object.prototype.hasOwnProperty.call(value, "data")) {
          return step(value, newKey);
        } else {
          result[newKey] = value;
        }
      } else {
        result[newKey] = String(value);
      }
    });
  };
  step(data, null);
  return result;
}
function validateInteger(name, n2, defaultVal) {
  if (!Number.isInteger(n2)) {
    if (defaultVal !== void 0) {
      return defaultVal;
    } else {
      throw new Error(`${name} must be an integer`);
    }
  }
  return n2;
}
function determineProcessUserAgentProperties() {
  return typeof process === "undefined" ? {} : {
    lang_version: process.version,
    platform: process.platform
  };
}

// node_modules/stripe/esm/StripeMethod.js
init_modules_watch_stub();

// node_modules/stripe/esm/autoPagination.js
init_modules_watch_stub();
var StripeIterator = class {
  constructor(firstPagePromise, requestArgs, spec, stripeResource) {
    this.index = 0;
    this.pagePromise = firstPagePromise;
    this.promiseCache = { currentPromise: null };
    this.requestArgs = requestArgs;
    this.spec = spec;
    this.stripeResource = stripeResource;
  }
  async iterate(pageResult) {
    if (!(pageResult && pageResult.data && typeof pageResult.data.length === "number")) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `data` array.");
    }
    const reverseIteration = isReverseIteration(this.requestArgs);
    if (this.index < pageResult.data.length) {
      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;
      const value = pageResult.data[idx];
      this.index += 1;
      return { value, done: false };
    } else if (pageResult.has_more) {
      this.index = 0;
      this.pagePromise = this.getNextPage(pageResult);
      const nextPageResult = await this.pagePromise;
      return this.iterate(nextPageResult);
    }
    return { done: true, value: void 0 };
  }
  /** @abstract */
  getNextPage(_pageResult) {
    throw new Error("Unimplemented");
  }
  async _next() {
    return this.iterate(await this.pagePromise);
  }
  next() {
    if (this.promiseCache.currentPromise) {
      return this.promiseCache.currentPromise;
    }
    const nextPromise = (async () => {
      const ret = await this._next();
      this.promiseCache.currentPromise = null;
      return ret;
    })();
    this.promiseCache.currentPromise = nextPromise;
    return nextPromise;
  }
};
var ListIterator = class extends StripeIterator {
  getNextPage(pageResult) {
    const reverseIteration = isReverseIteration(this.requestArgs);
    const lastId = getLastId(pageResult, reverseIteration);
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      [reverseIteration ? "ending_before" : "starting_after"]: lastId
    });
  }
};
var SearchIterator = class extends StripeIterator {
  getNextPage(pageResult) {
    if (!pageResult.next_page) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.");
    }
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      page: pageResult.next_page
    });
  }
};
var makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {
  if (spec.methodType === "search") {
    return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  if (spec.methodType === "list") {
    return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  return null;
};
var makeAutoPaginationMethodsFromIterator = (iterator) => {
  const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));
  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
  const autoPaginationMethods = {
    autoPagingEach,
    autoPagingToArray,
    // Async iterator functions:
    next: () => iterator.next(),
    return: () => {
      return {};
    },
    [getAsyncIteratorSymbol()]: () => {
      return autoPaginationMethods;
    }
  };
  return autoPaginationMethods;
};
function getAsyncIteratorSymbol() {
  if (typeof Symbol !== "undefined" && Symbol.asyncIterator) {
    return Symbol.asyncIterator;
  }
  return "@@asyncIterator";
}
function getDoneCallback(args) {
  if (args.length < 2) {
    return null;
  }
  const onDone = args[1];
  if (typeof onDone !== "function") {
    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);
  }
  return onDone;
}
function getItemCallback(args) {
  if (args.length === 0) {
    return void 0;
  }
  const onItem = args[0];
  if (typeof onItem !== "function") {
    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);
  }
  if (onItem.length === 2) {
    return onItem;
  }
  if (onItem.length > 2) {
    throw Error(`The \`onItem\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);
  }
  return function _onItem(item, next) {
    const shouldContinue = onItem(item);
    next(shouldContinue);
  };
}
function getLastId(listResult, reverseIteration) {
  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
  const lastItem = listResult.data[lastIdx];
  const lastId = lastItem && lastItem.id;
  if (!lastId) {
    throw Error("Unexpected: No `id` found on the last item while auto-paging a list.");
  }
  return lastId;
}
function makeAutoPagingEach(asyncIteratorNext) {
  return function autoPagingEach() {
    const args = [].slice.call(arguments);
    const onItem = getItemCallback(args);
    const onDone = getDoneCallback(args);
    if (args.length > 2) {
      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);
    }
    const autoPagePromise = wrapAsyncIteratorWithCallback(
      asyncIteratorNext,
      // @ts-ignore we might need a null check
      onItem
    );
    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);
  };
}
function makeAutoPagingToArray(autoPagingEach) {
  return function autoPagingToArray(opts, onDone) {
    const limit = opts && opts.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.");
    }
    if (limit > 1e4) {
      throw Error("You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.");
    }
    const promise = new Promise((resolve, reject) => {
      const items = [];
      autoPagingEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve(items);
      }).catch(reject);
    });
    return callbackifyPromiseWithTimeout(promise, onDone);
  };
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
  return new Promise((resolve, reject) => {
    function handleIteration(iterResult) {
      if (iterResult.done) {
        resolve();
        return;
      }
      const item = iterResult.value;
      return new Promise((next) => {
        onItem(item, next);
      }).then((shouldContinue) => {
        if (shouldContinue === false) {
          return handleIteration({ done: true, value: void 0 });
        } else {
          return asyncIteratorNext().then(handleIteration);
        }
      });
    }
    asyncIteratorNext().then(handleIteration).catch(reject);
  });
}
function isReverseIteration(requestArgs) {
  const args = [].slice.call(requestArgs);
  const dataFromArgs = getDataFromArgs(args);
  return !!dataFromArgs.ending_before;
}

// node_modules/stripe/esm/StripeMethod.js
function stripeMethod(spec) {
  if (spec.path !== void 0 && spec.fullPath !== void 0) {
    throw new Error(`Method spec specified both a 'path' (${spec.path}) and a 'fullPath' (${spec.fullPath}).`);
  }
  return function(...args) {
    const callback = typeof args[args.length - 1] == "function" && args.pop();
    spec.urlParams = extractUrlParams(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ""));
    const requestPromise = callbackifyPromiseWithTimeout(this._makeRequest(args, spec, {}), callback);
    Object.assign(requestPromise, makeAutoPaginationMethods(this, args, spec, requestPromise));
    return requestPromise;
  };
}

// node_modules/stripe/esm/StripeResource.js
StripeResource.extend = protoExtend;
StripeResource.method = stripeMethod;
StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
function StripeResource(stripe, deprecatedUrlData) {
  this._stripe = stripe;
  if (deprecatedUrlData) {
    throw new Error("Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.");
  }
  this.basePath = makeURLInterpolator(
    // @ts-ignore changing type of basePath
    this.basePath || stripe.getApiField("basePath")
  );
  this.resourcePath = this.path;
  this.path = makeURLInterpolator(this.path);
  this.initialize(...arguments);
}
StripeResource.prototype = {
  _stripe: null,
  // @ts-ignore the type of path changes in ctor
  path: "",
  resourcePath: "",
  // Methods that don't use the API's default '/v1' path can override it with this setting.
  basePath: null,
  initialize() {
  },
  // Function to override the default data processor. This allows full control
  // over how a StripeResource's request data will get converted into an HTTP
  // body. This is useful for non-standard HTTP requests. The function should
  // take method name, data, and headers as arguments.
  requestDataProcessor: null,
  // Function to add a validation checks before sending the request, errors should
  // be thrown, and they will be passed to the callback/promise.
  validateRequest: null,
  createFullPath(commandPath, urlData) {
    const urlParts = [this.basePath(urlData), this.path(urlData)];
    if (typeof commandPath === "function") {
      const computedCommandPath = commandPath(urlData);
      if (computedCommandPath) {
        urlParts.push(computedCommandPath);
      }
    } else {
      urlParts.push(commandPath);
    }
    return this._joinUrlParts(urlParts);
  },
  // Creates a relative resource path with symbols left in (unlike
  // createFullPath which takes some data to replace them with). For example it
  // might produce: /invoices/{id}
  createResourcePathWithSymbols(pathWithSymbols) {
    if (pathWithSymbols) {
      return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;
    } else {
      return `/${this.resourcePath}`;
    }
  },
  _joinUrlParts(parts) {
    return parts.join("/").replace(/\/{2,}/g, "/");
  },
  _getRequestOpts(requestArgs, spec, overrideData) {
    const requestMethod = (spec.method || "GET").toUpperCase();
    const usage = spec.usage || [];
    const urlParams = spec.urlParams || [];
    const encode = spec.encode || ((data2) => data2);
    const isUsingFullPath = !!spec.fullPath;
    const commandPath = makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || "");
    const path = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);
    const args = [].slice.call(requestArgs);
    const urlData = urlParams.reduce((urlData2, param) => {
      const arg = args.shift();
      if (typeof arg !== "string") {
        throw new Error(`Stripe: Argument "${param}" must be a string, but got: ${arg} (on API request to \`${requestMethod} ${path}\`)`);
      }
      urlData2[param] = arg;
      return urlData2;
    }, {});
    const dataFromArgs = getDataFromArgs(args);
    const data = encode(Object.assign({}, dataFromArgs, overrideData));
    const options = getOptionsFromArgs(args);
    const host = options.host || spec.host;
    const streaming = !!spec.streaming;
    if (args.filter((x2) => x2 != null).length) {
      throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \`${path}\`)`);
    }
    const requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);
    const headers = Object.assign(options.headers, spec.headers);
    if (spec.validator) {
      spec.validator(data, { headers });
    }
    const dataInQuery = spec.method === "GET" || spec.method === "DELETE";
    const bodyData = dataInQuery ? {} : data;
    const queryData = dataInQuery ? data : {};
    return {
      requestMethod,
      requestPath,
      bodyData,
      queryData,
      auth: options.auth,
      headers,
      host: host !== null && host !== void 0 ? host : null,
      streaming,
      settings: options.settings,
      usage
    };
  },
  _makeRequest(requestArgs, spec, overrideData) {
    return new Promise((resolve, reject) => {
      var _a90;
      let opts;
      try {
        opts = this._getRequestOpts(requestArgs, spec, overrideData);
      } catch (err) {
        reject(err);
        return;
      }
      function requestCallback(err, response) {
        if (err) {
          reject(err);
        } else {
          resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);
        }
      }
      const emptyQuery = Object.keys(opts.queryData).length === 0;
      const path = [
        opts.requestPath,
        emptyQuery ? "" : "?",
        stringifyRequestData(opts.queryData)
      ].join("");
      const { headers, settings } = opts;
      this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, { headers, settings, streaming: opts.streaming }, opts.usage, requestCallback, (_a90 = this.requestDataProcessor) === null || _a90 === void 0 ? void 0 : _a90.bind(this));
    });
  }
};

// node_modules/stripe/esm/resources/FinancialConnections/Accounts.js
var stripeMethod2 = StripeResource.method;
var Accounts = StripeResource.extend({
  retrieve: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}"
  }),
  list: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts",
    methodType: "list"
  }),
  disconnect: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/disconnect"
  }),
  listOwners: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}/owners",
    methodType: "list"
  }),
  refresh: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/refresh"
  }),
  subscribe: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/subscribe"
  }),
  unsubscribe: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/unsubscribe"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Authorizations.js
init_modules_watch_stub();
var stripeMethod3 = StripeResource.method;
var Authorizations = StripeResource.extend({
  create: stripeMethod3({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations"
  }),
  capture: stripeMethod3({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/capture"
  }),
  expire: stripeMethod3({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/expire"
  }),
  increment: stripeMethod3({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/increment"
  }),
  reverse: stripeMethod3({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/reverse"
  })
});

// node_modules/stripe/esm/resources/Issuing/Authorizations.js
init_modules_watch_stub();
var stripeMethod4 = StripeResource.method;
var Authorizations2 = StripeResource.extend({
  retrieve: stripeMethod4({
    method: "GET",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  update: stripeMethod4({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  list: stripeMethod4({
    method: "GET",
    fullPath: "/v1/issuing/authorizations",
    methodType: "list"
  }),
  approve: stripeMethod4({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/approve"
  }),
  decline: stripeMethod4({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/decline"
  })
});

// node_modules/stripe/esm/resources/Tax/Calculations.js
init_modules_watch_stub();
var stripeMethod5 = StripeResource.method;
var Calculations = StripeResource.extend({
  create: stripeMethod5({ method: "POST", fullPath: "/v1/tax/calculations" }),
  listLineItems: stripeMethod5({
    method: "GET",
    fullPath: "/v1/tax/calculations/{calculation}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Cardholders.js
init_modules_watch_stub();
var stripeMethod6 = StripeResource.method;
var Cardholders = StripeResource.extend({
  create: stripeMethod6({ method: "POST", fullPath: "/v1/issuing/cardholders" }),
  retrieve: stripeMethod6({
    method: "GET",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  update: stripeMethod6({
    method: "POST",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  list: stripeMethod6({
    method: "GET",
    fullPath: "/v1/issuing/cardholders",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Cards.js
init_modules_watch_stub();
var stripeMethod7 = StripeResource.method;
var Cards = StripeResource.extend({
  deliverCard: stripeMethod7({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/deliver"
  }),
  failCard: stripeMethod7({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/fail"
  }),
  returnCard: stripeMethod7({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/return"
  }),
  shipCard: stripeMethod7({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/ship"
  })
});

// node_modules/stripe/esm/resources/Issuing/Cards.js
init_modules_watch_stub();
var stripeMethod8 = StripeResource.method;
var Cards2 = StripeResource.extend({
  create: stripeMethod8({ method: "POST", fullPath: "/v1/issuing/cards" }),
  retrieve: stripeMethod8({ method: "GET", fullPath: "/v1/issuing/cards/{card}" }),
  update: stripeMethod8({ method: "POST", fullPath: "/v1/issuing/cards/{card}" }),
  list: stripeMethod8({
    method: "GET",
    fullPath: "/v1/issuing/cards",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/BillingPortal/Configurations.js
init_modules_watch_stub();
var stripeMethod9 = StripeResource.method;
var Configurations = StripeResource.extend({
  create: stripeMethod9({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations"
  }),
  retrieve: stripeMethod9({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  update: stripeMethod9({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  list: stripeMethod9({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Terminal/Configurations.js
init_modules_watch_stub();
var stripeMethod10 = StripeResource.method;
var Configurations2 = StripeResource.extend({
  create: stripeMethod10({
    method: "POST",
    fullPath: "/v1/terminal/configurations"
  }),
  retrieve: stripeMethod10({
    method: "GET",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  update: stripeMethod10({
    method: "POST",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  list: stripeMethod10({
    method: "GET",
    fullPath: "/v1/terminal/configurations",
    methodType: "list"
  }),
  del: stripeMethod10({
    method: "DELETE",
    fullPath: "/v1/terminal/configurations/{configuration}"
  })
});

// node_modules/stripe/esm/resources/Terminal/ConnectionTokens.js
init_modules_watch_stub();
var stripeMethod11 = StripeResource.method;
var ConnectionTokens = StripeResource.extend({
  create: stripeMethod11({
    method: "POST",
    fullPath: "/v1/terminal/connection_tokens"
  })
});

// node_modules/stripe/esm/resources/Treasury/CreditReversals.js
init_modules_watch_stub();
var stripeMethod12 = StripeResource.method;
var CreditReversals = StripeResource.extend({
  create: stripeMethod12({
    method: "POST",
    fullPath: "/v1/treasury/credit_reversals"
  }),
  retrieve: stripeMethod12({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals/{credit_reversal}"
  }),
  list: stripeMethod12({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Customers.js
init_modules_watch_stub();
var stripeMethod13 = StripeResource.method;
var Customers = StripeResource.extend({
  fundCashBalance: stripeMethod13({
    method: "POST",
    fullPath: "/v1/test_helpers/customers/{customer}/fund_cash_balance"
  })
});

// node_modules/stripe/esm/resources/Treasury/DebitReversals.js
init_modules_watch_stub();
var stripeMethod14 = StripeResource.method;
var DebitReversals = StripeResource.extend({
  create: stripeMethod14({
    method: "POST",
    fullPath: "/v1/treasury/debit_reversals"
  }),
  retrieve: stripeMethod14({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals/{debit_reversal}"
  }),
  list: stripeMethod14({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Disputes.js
init_modules_watch_stub();
var stripeMethod15 = StripeResource.method;
var Disputes = StripeResource.extend({
  create: stripeMethod15({ method: "POST", fullPath: "/v1/issuing/disputes" }),
  retrieve: stripeMethod15({
    method: "GET",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  update: stripeMethod15({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  list: stripeMethod15({
    method: "GET",
    fullPath: "/v1/issuing/disputes",
    methodType: "list"
  }),
  submit: stripeMethod15({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}/submit"
  })
});

// node_modules/stripe/esm/resources/Radar/EarlyFraudWarnings.js
init_modules_watch_stub();
var stripeMethod16 = StripeResource.method;
var EarlyFraudWarnings = StripeResource.extend({
  retrieve: stripeMethod16({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings/{early_fraud_warning}"
  }),
  list: stripeMethod16({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/FinancialAccounts.js
init_modules_watch_stub();
var stripeMethod17 = StripeResource.method;
var FinancialAccounts = StripeResource.extend({
  create: stripeMethod17({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts"
  }),
  retrieve: stripeMethod17({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  update: stripeMethod17({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  list: stripeMethod17({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts",
    methodType: "list"
  }),
  retrieveFeatures: stripeMethod17({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  }),
  updateFeatures: stripeMethod17({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/InboundTransfers.js
init_modules_watch_stub();
var stripeMethod18 = StripeResource.method;
var InboundTransfers = StripeResource.extend({
  fail: stripeMethod18({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/fail"
  }),
  returnInboundTransfer: stripeMethod18({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/return"
  }),
  succeed: stripeMethod18({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/succeed"
  })
});

// node_modules/stripe/esm/resources/Treasury/InboundTransfers.js
init_modules_watch_stub();
var stripeMethod19 = StripeResource.method;
var InboundTransfers2 = StripeResource.extend({
  create: stripeMethod19({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers"
  }),
  retrieve: stripeMethod19({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers/{id}"
  }),
  list: stripeMethod19({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod19({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers/{inbound_transfer}/cancel"
  })
});

// node_modules/stripe/esm/resources/Terminal/Locations.js
init_modules_watch_stub();
var stripeMethod20 = StripeResource.method;
var Locations = StripeResource.extend({
  create: stripeMethod20({ method: "POST", fullPath: "/v1/terminal/locations" }),
  retrieve: stripeMethod20({
    method: "GET",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  update: stripeMethod20({
    method: "POST",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  list: stripeMethod20({
    method: "GET",
    fullPath: "/v1/terminal/locations",
    methodType: "list"
  }),
  del: stripeMethod20({
    method: "DELETE",
    fullPath: "/v1/terminal/locations/{location}"
  })
});

// node_modules/stripe/esm/resources/Climate/Orders.js
init_modules_watch_stub();
var stripeMethod21 = StripeResource.method;
var Orders = StripeResource.extend({
  create: stripeMethod21({ method: "POST", fullPath: "/v1/climate/orders" }),
  retrieve: stripeMethod21({
    method: "GET",
    fullPath: "/v1/climate/orders/{order}"
  }),
  update: stripeMethod21({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}"
  }),
  list: stripeMethod21({
    method: "GET",
    fullPath: "/v1/climate/orders",
    methodType: "list"
  }),
  cancel: stripeMethod21({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}/cancel"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundPayments.js
init_modules_watch_stub();
var stripeMethod22 = StripeResource.method;
var OutboundPayments = StripeResource.extend({
  fail: stripeMethod22({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/fail"
  }),
  post: stripeMethod22({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/post"
  }),
  returnOutboundPayment: stripeMethod22({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/return"
  })
});

// node_modules/stripe/esm/resources/Treasury/OutboundPayments.js
init_modules_watch_stub();
var stripeMethod23 = StripeResource.method;
var OutboundPayments2 = StripeResource.extend({
  create: stripeMethod23({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments"
  }),
  retrieve: stripeMethod23({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments/{id}"
  }),
  list: stripeMethod23({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments",
    methodType: "list"
  }),
  cancel: stripeMethod23({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments/{id}/cancel"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundTransfers.js
init_modules_watch_stub();
var stripeMethod24 = StripeResource.method;
var OutboundTransfers = StripeResource.extend({
  fail: stripeMethod24({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail"
  }),
  post: stripeMethod24({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post"
  }),
  returnOutboundTransfer: stripeMethod24({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return"
  })
});

// node_modules/stripe/esm/resources/Treasury/OutboundTransfers.js
init_modules_watch_stub();
var stripeMethod25 = StripeResource.method;
var OutboundTransfers2 = StripeResource.extend({
  create: stripeMethod25({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers"
  }),
  retrieve: stripeMethod25({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}"
  }),
  list: stripeMethod25({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod25({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}/cancel"
  })
});

// node_modules/stripe/esm/resources/Climate/Products.js
init_modules_watch_stub();
var stripeMethod26 = StripeResource.method;
var Products = StripeResource.extend({
  retrieve: stripeMethod26({
    method: "GET",
    fullPath: "/v1/climate/products/{product}"
  }),
  list: stripeMethod26({
    method: "GET",
    fullPath: "/v1/climate/products",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Terminal/Readers.js
init_modules_watch_stub();
var stripeMethod27 = StripeResource.method;
var Readers = StripeResource.extend({
  presentPaymentMethod: stripeMethod27({
    method: "POST",
    fullPath: "/v1/test_helpers/terminal/readers/{reader}/present_payment_method"
  })
});

// node_modules/stripe/esm/resources/Terminal/Readers.js
init_modules_watch_stub();
var stripeMethod28 = StripeResource.method;
var Readers2 = StripeResource.extend({
  create: stripeMethod28({ method: "POST", fullPath: "/v1/terminal/readers" }),
  retrieve: stripeMethod28({
    method: "GET",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  update: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  list: stripeMethod28({
    method: "GET",
    fullPath: "/v1/terminal/readers",
    methodType: "list"
  }),
  del: stripeMethod28({
    method: "DELETE",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  cancelAction: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/cancel_action"
  }),
  processPaymentIntent: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_payment_intent"
  }),
  processSetupIntent: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_setup_intent"
  }),
  refundPayment: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/refund_payment"
  }),
  setReaderDisplay: stripeMethod28({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/set_reader_display"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedCredits.js
init_modules_watch_stub();
var stripeMethod29 = StripeResource.method;
var ReceivedCredits = StripeResource.extend({
  create: stripeMethod29({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_credits"
  })
});

// node_modules/stripe/esm/resources/Treasury/ReceivedCredits.js
init_modules_watch_stub();
var stripeMethod30 = StripeResource.method;
var ReceivedCredits2 = StripeResource.extend({
  retrieve: stripeMethod30({
    method: "GET",
    fullPath: "/v1/treasury/received_credits/{id}"
  }),
  list: stripeMethod30({
    method: "GET",
    fullPath: "/v1/treasury/received_credits",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedDebits.js
init_modules_watch_stub();
var stripeMethod31 = StripeResource.method;
var ReceivedDebits = StripeResource.extend({
  create: stripeMethod31({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_debits"
  })
});

// node_modules/stripe/esm/resources/Treasury/ReceivedDebits.js
init_modules_watch_stub();
var stripeMethod32 = StripeResource.method;
var ReceivedDebits2 = StripeResource.extend({
  retrieve: stripeMethod32({
    method: "GET",
    fullPath: "/v1/treasury/received_debits/{id}"
  }),
  list: stripeMethod32({
    method: "GET",
    fullPath: "/v1/treasury/received_debits",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Refunds.js
init_modules_watch_stub();
var stripeMethod33 = StripeResource.method;
var Refunds = StripeResource.extend({
  expire: stripeMethod33({
    method: "POST",
    fullPath: "/v1/test_helpers/refunds/{refund}/expire"
  })
});

// node_modules/stripe/esm/resources/Tax/Registrations.js
init_modules_watch_stub();
var stripeMethod34 = StripeResource.method;
var Registrations = StripeResource.extend({
  create: stripeMethod34({ method: "POST", fullPath: "/v1/tax/registrations" }),
  retrieve: stripeMethod34({
    method: "GET",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  update: stripeMethod34({
    method: "POST",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  list: stripeMethod34({
    method: "GET",
    fullPath: "/v1/tax/registrations",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Reporting/ReportRuns.js
init_modules_watch_stub();
var stripeMethod35 = StripeResource.method;
var ReportRuns = StripeResource.extend({
  create: stripeMethod35({ method: "POST", fullPath: "/v1/reporting/report_runs" }),
  retrieve: stripeMethod35({
    method: "GET",
    fullPath: "/v1/reporting/report_runs/{report_run}"
  }),
  list: stripeMethod35({
    method: "GET",
    fullPath: "/v1/reporting/report_runs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Reporting/ReportTypes.js
init_modules_watch_stub();
var stripeMethod36 = StripeResource.method;
var ReportTypes = StripeResource.extend({
  retrieve: stripeMethod36({
    method: "GET",
    fullPath: "/v1/reporting/report_types/{report_type}"
  }),
  list: stripeMethod36({
    method: "GET",
    fullPath: "/v1/reporting/report_types",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Sigma/ScheduledQueryRuns.js
init_modules_watch_stub();
var stripeMethod37 = StripeResource.method;
var ScheduledQueryRuns = StripeResource.extend({
  retrieve: stripeMethod37({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs/{scheduled_query_run}"
  }),
  list: stripeMethod37({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Apps/Secrets.js
init_modules_watch_stub();
var stripeMethod38 = StripeResource.method;
var Secrets = StripeResource.extend({
  create: stripeMethod38({ method: "POST", fullPath: "/v1/apps/secrets" }),
  list: stripeMethod38({
    method: "GET",
    fullPath: "/v1/apps/secrets",
    methodType: "list"
  }),
  deleteWhere: stripeMethod38({
    method: "POST",
    fullPath: "/v1/apps/secrets/delete"
  }),
  find: stripeMethod38({ method: "GET", fullPath: "/v1/apps/secrets/find" })
});

// node_modules/stripe/esm/resources/BillingPortal/Sessions.js
init_modules_watch_stub();
var stripeMethod39 = StripeResource.method;
var Sessions = StripeResource.extend({
  create: stripeMethod39({
    method: "POST",
    fullPath: "/v1/billing_portal/sessions"
  })
});

// node_modules/stripe/esm/resources/Checkout/Sessions.js
init_modules_watch_stub();
var stripeMethod40 = StripeResource.method;
var Sessions2 = StripeResource.extend({
  create: stripeMethod40({ method: "POST", fullPath: "/v1/checkout/sessions" }),
  retrieve: stripeMethod40({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}"
  }),
  list: stripeMethod40({
    method: "GET",
    fullPath: "/v1/checkout/sessions",
    methodType: "list"
  }),
  expire: stripeMethod40({
    method: "POST",
    fullPath: "/v1/checkout/sessions/{session}/expire"
  }),
  listLineItems: stripeMethod40({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/FinancialConnections/Sessions.js
init_modules_watch_stub();
var stripeMethod41 = StripeResource.method;
var Sessions3 = StripeResource.extend({
  create: stripeMethod41({
    method: "POST",
    fullPath: "/v1/financial_connections/sessions"
  }),
  retrieve: stripeMethod41({
    method: "GET",
    fullPath: "/v1/financial_connections/sessions/{session}"
  })
});

// node_modules/stripe/esm/resources/Tax/Settings.js
init_modules_watch_stub();
var stripeMethod42 = StripeResource.method;
var Settings = StripeResource.extend({
  retrieve: stripeMethod42({ method: "GET", fullPath: "/v1/tax/settings" }),
  update: stripeMethod42({ method: "POST", fullPath: "/v1/tax/settings" })
});

// node_modules/stripe/esm/resources/Climate/Suppliers.js
init_modules_watch_stub();
var stripeMethod43 = StripeResource.method;
var Suppliers = StripeResource.extend({
  retrieve: stripeMethod43({
    method: "GET",
    fullPath: "/v1/climate/suppliers/{supplier}"
  }),
  list: stripeMethod43({
    method: "GET",
    fullPath: "/v1/climate/suppliers",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/TestClocks.js
init_modules_watch_stub();
var stripeMethod44 = StripeResource.method;
var TestClocks = StripeResource.extend({
  create: stripeMethod44({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks"
  }),
  retrieve: stripeMethod44({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  list: stripeMethod44({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks",
    methodType: "list"
  }),
  del: stripeMethod44({
    method: "DELETE",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  advance: stripeMethod44({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}/advance"
  })
});

// node_modules/stripe/esm/resources/Issuing/Tokens.js
init_modules_watch_stub();
var stripeMethod45 = StripeResource.method;
var Tokens = StripeResource.extend({
  retrieve: stripeMethod45({
    method: "GET",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  update: stripeMethod45({
    method: "POST",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  list: stripeMethod45({
    method: "GET",
    fullPath: "/v1/issuing/tokens",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/TransactionEntries.js
init_modules_watch_stub();
var stripeMethod46 = StripeResource.method;
var TransactionEntries = StripeResource.extend({
  retrieve: stripeMethod46({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries/{id}"
  }),
  list: stripeMethod46({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Transactions.js
init_modules_watch_stub();
var stripeMethod47 = StripeResource.method;
var Transactions = StripeResource.extend({
  createForceCapture: stripeMethod47({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_force_capture"
  }),
  createUnlinkedRefund: stripeMethod47({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_unlinked_refund"
  }),
  refund: stripeMethod47({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/{transaction}/refund"
  })
});

// node_modules/stripe/esm/resources/FinancialConnections/Transactions.js
init_modules_watch_stub();
var stripeMethod48 = StripeResource.method;
var Transactions2 = StripeResource.extend({
  retrieve: stripeMethod48({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions/{transaction}"
  }),
  list: stripeMethod48({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Transactions.js
init_modules_watch_stub();
var stripeMethod49 = StripeResource.method;
var Transactions3 = StripeResource.extend({
  retrieve: stripeMethod49({
    method: "GET",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  update: stripeMethod49({
    method: "POST",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  list: stripeMethod49({
    method: "GET",
    fullPath: "/v1/issuing/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Tax/Transactions.js
init_modules_watch_stub();
var stripeMethod50 = StripeResource.method;
var Transactions4 = StripeResource.extend({
  retrieve: stripeMethod50({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}"
  }),
  createFromCalculation: stripeMethod50({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_from_calculation"
  }),
  createReversal: stripeMethod50({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_reversal"
  }),
  listLineItems: stripeMethod50({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/Transactions.js
init_modules_watch_stub();
var stripeMethod51 = StripeResource.method;
var Transactions5 = StripeResource.extend({
  retrieve: stripeMethod51({
    method: "GET",
    fullPath: "/v1/treasury/transactions/{id}"
  }),
  list: stripeMethod51({
    method: "GET",
    fullPath: "/v1/treasury/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Radar/ValueListItems.js
init_modules_watch_stub();
var stripeMethod52 = StripeResource.method;
var ValueListItems = StripeResource.extend({
  create: stripeMethod52({
    method: "POST",
    fullPath: "/v1/radar/value_list_items"
  }),
  retrieve: stripeMethod52({
    method: "GET",
    fullPath: "/v1/radar/value_list_items/{item}"
  }),
  list: stripeMethod52({
    method: "GET",
    fullPath: "/v1/radar/value_list_items",
    methodType: "list"
  }),
  del: stripeMethod52({
    method: "DELETE",
    fullPath: "/v1/radar/value_list_items/{item}"
  })
});

// node_modules/stripe/esm/resources/Radar/ValueLists.js
init_modules_watch_stub();
var stripeMethod53 = StripeResource.method;
var ValueLists = StripeResource.extend({
  create: stripeMethod53({ method: "POST", fullPath: "/v1/radar/value_lists" }),
  retrieve: stripeMethod53({
    method: "GET",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  update: stripeMethod53({
    method: "POST",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  list: stripeMethod53({
    method: "GET",
    fullPath: "/v1/radar/value_lists",
    methodType: "list"
  }),
  del: stripeMethod53({
    method: "DELETE",
    fullPath: "/v1/radar/value_lists/{value_list}"
  })
});

// node_modules/stripe/esm/resources/Identity/VerificationReports.js
init_modules_watch_stub();
var stripeMethod54 = StripeResource.method;
var VerificationReports = StripeResource.extend({
  retrieve: stripeMethod54({
    method: "GET",
    fullPath: "/v1/identity/verification_reports/{report}"
  }),
  list: stripeMethod54({
    method: "GET",
    fullPath: "/v1/identity/verification_reports",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Identity/VerificationSessions.js
init_modules_watch_stub();
var stripeMethod55 = StripeResource.method;
var VerificationSessions = StripeResource.extend({
  create: stripeMethod55({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions"
  }),
  retrieve: stripeMethod55({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  update: stripeMethod55({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  list: stripeMethod55({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions",
    methodType: "list"
  }),
  cancel: stripeMethod55({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/cancel"
  }),
  redact: stripeMethod55({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/redact"
  })
});

// node_modules/stripe/esm/resources/Accounts.js
init_modules_watch_stub();
var stripeMethod56 = StripeResource.method;
var Accounts2 = StripeResource.extend({
  create: stripeMethod56({ method: "POST", fullPath: "/v1/accounts" }),
  retrieve(id, ...args) {
    if (typeof id === "string") {
      return stripeMethod56({
        method: "GET",
        fullPath: "/v1/accounts/{id}"
      }).apply(this, [id, ...args]);
    } else {
      if (id === null || id === void 0) {
        [].shift.apply([id, ...args]);
      }
      return stripeMethod56({
        method: "GET",
        fullPath: "/v1/account"
      }).apply(this, [id, ...args]);
    }
  },
  update: stripeMethod56({ method: "POST", fullPath: "/v1/accounts/{account}" }),
  list: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts",
    methodType: "list"
  }),
  del: stripeMethod56({ method: "DELETE", fullPath: "/v1/accounts/{account}" }),
  createExternalAccount: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts"
  }),
  createLoginLink: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/login_links"
  }),
  createPerson: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons"
  }),
  deleteExternalAccount: stripeMethod56({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  deletePerson: stripeMethod56({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  listCapabilities: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities",
    methodType: "list"
  }),
  listExternalAccounts: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts",
    methodType: "list"
  }),
  listPersons: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons",
    methodType: "list"
  }),
  reject: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/reject"
  }),
  retrieveCapability: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  retrieveExternalAccount: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  retrievePerson: stripeMethod56({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  updateCapability: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  updateExternalAccount: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  updatePerson: stripeMethod56({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  })
});

// node_modules/stripe/esm/resources/AccountLinks.js
init_modules_watch_stub();
var stripeMethod57 = StripeResource.method;
var AccountLinks = StripeResource.extend({
  create: stripeMethod57({ method: "POST", fullPath: "/v1/account_links" })
});

// node_modules/stripe/esm/resources/AccountSessions.js
init_modules_watch_stub();
var stripeMethod58 = StripeResource.method;
var AccountSessions = StripeResource.extend({
  create: stripeMethod58({ method: "POST", fullPath: "/v1/account_sessions" })
});

// node_modules/stripe/esm/resources/ApplePayDomains.js
init_modules_watch_stub();
var stripeMethod59 = StripeResource.method;
var ApplePayDomains = StripeResource.extend({
  create: stripeMethod59({ method: "POST", fullPath: "/v1/apple_pay/domains" }),
  retrieve: stripeMethod59({
    method: "GET",
    fullPath: "/v1/apple_pay/domains/{domain}"
  }),
  list: stripeMethod59({
    method: "GET",
    fullPath: "/v1/apple_pay/domains",
    methodType: "list"
  }),
  del: stripeMethod59({
    method: "DELETE",
    fullPath: "/v1/apple_pay/domains/{domain}"
  })
});

// node_modules/stripe/esm/resources/ApplicationFees.js
init_modules_watch_stub();
var stripeMethod60 = StripeResource.method;
var ApplicationFees = StripeResource.extend({
  retrieve: stripeMethod60({
    method: "GET",
    fullPath: "/v1/application_fees/{id}"
  }),
  list: stripeMethod60({
    method: "GET",
    fullPath: "/v1/application_fees",
    methodType: "list"
  }),
  createRefund: stripeMethod60({
    method: "POST",
    fullPath: "/v1/application_fees/{id}/refunds"
  }),
  listRefunds: stripeMethod60({
    method: "GET",
    fullPath: "/v1/application_fees/{id}/refunds",
    methodType: "list"
  }),
  retrieveRefund: stripeMethod60({
    method: "GET",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  }),
  updateRefund: stripeMethod60({
    method: "POST",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  })
});

// node_modules/stripe/esm/resources/Balance.js
init_modules_watch_stub();
var stripeMethod61 = StripeResource.method;
var Balance = StripeResource.extend({
  retrieve: stripeMethod61({ method: "GET", fullPath: "/v1/balance" })
});

// node_modules/stripe/esm/resources/BalanceTransactions.js
init_modules_watch_stub();
var stripeMethod62 = StripeResource.method;
var BalanceTransactions = StripeResource.extend({
  retrieve: stripeMethod62({
    method: "GET",
    fullPath: "/v1/balance_transactions/{id}"
  }),
  list: stripeMethod62({
    method: "GET",
    fullPath: "/v1/balance_transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Charges.js
init_modules_watch_stub();
var stripeMethod63 = StripeResource.method;
var Charges = StripeResource.extend({
  create: stripeMethod63({ method: "POST", fullPath: "/v1/charges" }),
  retrieve: stripeMethod63({ method: "GET", fullPath: "/v1/charges/{charge}" }),
  update: stripeMethod63({ method: "POST", fullPath: "/v1/charges/{charge}" }),
  list: stripeMethod63({
    method: "GET",
    fullPath: "/v1/charges",
    methodType: "list"
  }),
  capture: stripeMethod63({
    method: "POST",
    fullPath: "/v1/charges/{charge}/capture"
  }),
  search: stripeMethod63({
    method: "GET",
    fullPath: "/v1/charges/search",
    methodType: "search"
  })
});

// node_modules/stripe/esm/resources/CountrySpecs.js
init_modules_watch_stub();
var stripeMethod64 = StripeResource.method;
var CountrySpecs = StripeResource.extend({
  retrieve: stripeMethod64({
    method: "GET",
    fullPath: "/v1/country_specs/{country}"
  }),
  list: stripeMethod64({
    method: "GET",
    fullPath: "/v1/country_specs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Coupons.js
init_modules_watch_stub();
var stripeMethod65 = StripeResource.method;
var Coupons = StripeResource.extend({
  create: stripeMethod65({ method: "POST", fullPath: "/v1/coupons" }),
  retrieve: stripeMethod65({ method: "GET", fullPath: "/v1/coupons/{coupon}" }),
  update: stripeMethod65({ method: "POST", fullPath: "/v1/coupons/{coupon}" }),
  list: stripeMethod65({
    method: "GET",
    fullPath: "/v1/coupons",
    methodType: "list"
  }),
  del: stripeMethod65({ method: "DELETE", fullPath: "/v1/coupons/{coupon}" })
});

// node_modules/stripe/esm/resources/CreditNotes.js
init_modules_watch_stub();
var stripeMethod66 = StripeResource.method;
var CreditNotes = StripeResource.extend({
  create: stripeMethod66({ method: "POST", fullPath: "/v1/credit_notes" }),
  retrieve: stripeMethod66({ method: "GET", fullPath: "/v1/credit_notes/{id}" }),
  update: stripeMethod66({ method: "POST", fullPath: "/v1/credit_notes/{id}" }),
  list: stripeMethod66({
    method: "GET",
    fullPath: "/v1/credit_notes",
    methodType: "list"
  }),
  listLineItems: stripeMethod66({
    method: "GET",
    fullPath: "/v1/credit_notes/{credit_note}/lines",
    methodType: "list"
  }),
  listPreviewLineItems: stripeMethod66({
    method: "GET",
    fullPath: "/v1/credit_notes/preview/lines",
    methodType: "list"
  }),
  preview: stripeMethod66({ method: "GET", fullPath: "/v1/credit_notes/preview" }),
  voidCreditNote: stripeMethod66({
    method: "POST",
    fullPath: "/v1/credit_notes/{id}/void"
  })
});

// node_modules/stripe/esm/resources/CustomerSessions.js
init_modules_watch_stub();
var stripeMethod67 = StripeResource.method;
var CustomerSessions = StripeResource.extend({
  create: stripeMethod67({ method: "POST", fullPath: "/v1/customer_sessions" })
});

// node_modules/stripe/esm/resources/Customers.js
init_modules_watch_stub();
var stripeMethod68 = StripeResource.method;
var Customers2 = StripeResource.extend({
  create: stripeMethod68({ method: "POST", fullPath: "/v1/customers" }),
  retrieve: stripeMethod68({ method: "GET", fullPath: "/v1/customers/{customer}" }),
  update: stripeMethod68({ method: "POST", fullPath: "/v1/customers/{customer}" }),
  list: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers",
    methodType: "list"
  }),
  del: stripeMethod68({ method: "DELETE", fullPath: "/v1/customers/{customer}" }),
  createFundingInstructions: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/funding_instructions"
  }),
  createBalanceTransaction: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions"
  }),
  createSource: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources"
  }),
  createTaxId: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/tax_ids"
  }),
  deleteDiscount: stripeMethod68({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/discount"
  }),
  deleteSource: stripeMethod68({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  deleteTaxId: stripeMethod68({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  listPaymentMethods: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods",
    methodType: "list"
  }),
  listBalanceTransactions: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions",
    methodType: "list"
  }),
  listCashBalanceTransactions: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions",
    methodType: "list"
  }),
  listSources: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources",
    methodType: "list"
  }),
  listTaxIds: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids",
    methodType: "list"
  }),
  retrievePaymentMethod: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods/{payment_method}"
  }),
  retrieveBalanceTransaction: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  retrieveCashBalance: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  retrieveCashBalanceTransaction: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions/{transaction}"
  }),
  retrieveSource: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  retrieveTaxId: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  search: stripeMethod68({
    method: "GET",
    fullPath: "/v1/customers/search",
    methodType: "search"
  }),
  updateBalanceTransaction: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  updateCashBalance: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  updateSource: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  verifySource: stripeMethod68({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}/verify"
  })
});

// node_modules/stripe/esm/resources/Disputes.js
init_modules_watch_stub();
var stripeMethod69 = StripeResource.method;
var Disputes2 = StripeResource.extend({
  retrieve: stripeMethod69({ method: "GET", fullPath: "/v1/disputes/{dispute}" }),
  update: stripeMethod69({ method: "POST", fullPath: "/v1/disputes/{dispute}" }),
  list: stripeMethod69({
    method: "GET",
    fullPath: "/v1/disputes",
    methodType: "list"
  }),
  close: stripeMethod69({
    method: "POST",
    fullPath: "/v1/disputes/{dispute}/close"
  })
});

// node_modules/stripe/esm/resources/EphemeralKeys.js
init_modules_watch_stub();
var stripeMethod70 = StripeResource.method;
var EphemeralKeys = StripeResource.extend({
  create: stripeMethod70({
    method: "POST",
    fullPath: "/v1/ephemeral_keys",
    validator: (data, options) => {
      if (!options.headers || !options.headers["Stripe-Version"]) {
        throw new Error("Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node");
      }
    }
  }),
  del: stripeMethod70({ method: "DELETE", fullPath: "/v1/ephemeral_keys/{key}" })
});

// node_modules/stripe/esm/resources/Events.js
init_modules_watch_stub();
var stripeMethod71 = StripeResource.method;
var Events = StripeResource.extend({
  retrieve: stripeMethod71({ method: "GET", fullPath: "/v1/events/{id}" }),
  list: stripeMethod71({
    method: "GET",
    fullPath: "/v1/events",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/ExchangeRates.js
init_modules_watch_stub();
var stripeMethod72 = StripeResource.method;
var ExchangeRates = StripeResource.extend({
  retrieve: stripeMethod72({
    method: "GET",
    fullPath: "/v1/exchange_rates/{rate_id}"
  }),
  list: stripeMethod72({
    method: "GET",
    fullPath: "/v1/exchange_rates",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/FileLinks.js
init_modules_watch_stub();
var stripeMethod73 = StripeResource.method;
var FileLinks = StripeResource.extend({
  create: stripeMethod73({ method: "POST", fullPath: "/v1/file_links" }),
  retrieve: stripeMethod73({ method: "GET", fullPath: "/v1/file_links/{link}" }),
  update: stripeMethod73({ method: "POST", fullPath: "/v1/file_links/{link}" }),
  list: stripeMethod73({
    method: "GET",
    fullPath: "/v1/file_links",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Files.js
init_modules_watch_stub();

// node_modules/stripe/esm/multipart.js
init_modules_watch_stub();
var multipartDataGenerator = (method, data, headers) => {
  const segno = (Math.round(Math.random() * 1e16) + Math.round(Math.random() * 1e16)).toString();
  headers["Content-Type"] = `multipart/form-data; boundary=${segno}`;
  const textEncoder = new TextEncoder();
  let buffer = new Uint8Array(0);
  const endBuffer = textEncoder.encode("\r\n");
  function push(l3) {
    const prevBuffer = buffer;
    const newBuffer = l3 instanceof Uint8Array ? l3 : new Uint8Array(textEncoder.encode(l3));
    buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
    buffer.set(prevBuffer);
    buffer.set(newBuffer, prevBuffer.length);
    buffer.set(endBuffer, buffer.length - 2);
  }
  function q2(s2) {
    return `"${s2.replace(/"|"/g, "%22").replace(/\r\n|\r|\n/g, " ")}"`;
  }
  const flattenedData = flattenAndStringify(data);
  for (const k2 in flattenedData) {
    const v3 = flattenedData[k2];
    push(`--${segno}`);
    if (Object.prototype.hasOwnProperty.call(v3, "data")) {
      const typedEntry = v3;
      push(`Content-Disposition: form-data; name=${q2(k2)}; filename=${q2(typedEntry.name || "blob")}`);
      push(`Content-Type: ${typedEntry.type || "application/octet-stream"}`);
      push("");
      push(typedEntry.data);
    } else {
      push(`Content-Disposition: form-data; name=${q2(k2)}`);
      push("");
      push(v3);
    }
  }
  push(`--${segno}--`);
  return buffer;
};
function multipartRequestDataProcessor(method, data, headers, callback) {
  data = data || {};
  if (method !== "POST") {
    return callback(null, stringifyRequestData(data));
  }
  this._stripe._platformFunctions.tryBufferData(data).then((bufferedData) => {
    const buffer = multipartDataGenerator(method, bufferedData, headers);
    return callback(null, buffer);
  }).catch((err) => callback(err, null));
}

// node_modules/stripe/esm/resources/Files.js
var stripeMethod74 = StripeResource.method;
var Files = StripeResource.extend({
  create: stripeMethod74({
    method: "POST",
    fullPath: "/v1/files",
    headers: {
      "Content-Type": "multipart/form-data"
    },
    host: "files.stripe.com"
  }),
  retrieve: stripeMethod74({ method: "GET", fullPath: "/v1/files/{file}" }),
  list: stripeMethod74({
    method: "GET",
    fullPath: "/v1/files",
    methodType: "list"
  }),
  requestDataProcessor: multipartRequestDataProcessor
});

// node_modules/stripe/esm/resources/InvoiceItems.js
init_modules_watch_stub();
var stripeMethod75 = StripeResource.method;
var InvoiceItems = StripeResource.extend({
  create: stripeMethod75({ method: "POST", fullPath: "/v1/invoiceitems" }),
  retrieve: stripeMethod75({
    method: "GET",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  update: stripeMethod75({
    method: "POST",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  list: stripeMethod75({
    method: "GET",
    fullPath: "/v1/invoiceitems",
    methodType: "list"
  }),
  del: stripeMethod75({
    method: "DELETE",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  })
});

// node_modules/stripe/esm/resources/Invoices.js
init_modules_watch_stub();
var stripeMethod76 = StripeResource.method;
var Invoices = StripeResource.extend({
  create: stripeMethod76({ method: "POST", fullPath: "/v1/invoices" }),
  retrieve: stripeMethod76({ method: "GET", fullPath: "/v1/invoices/{invoice}" }),
  update: stripeMethod76({ method: "POST", fullPath: "/v1/invoices/{invoice}" }),
  list: stripeMethod76({
    method: "GET",
    fullPath: "/v1/invoices",
    methodType: "list"
  }),
  del: stripeMethod76({ method: "DELETE", fullPath: "/v1/invoices/{invoice}" }),
  finalizeInvoice: stripeMethod76({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/finalize"
  }),
  listLineItems: stripeMethod76({
    method: "GET",
    fullPath: "/v1/invoices/{invoice}/lines",
    methodType: "list"
  }),
  listUpcomingLines: stripeMethod76({
    method: "GET",
    fullPath: "/v1/invoices/upcoming/lines",
    methodType: "list"
  }),
  markUncollectible: stripeMethod76({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/mark_uncollectible"
  }),
  pay: stripeMethod76({ method: "POST", fullPath: "/v1/invoices/{invoice}/pay" }),
  retrieveUpcoming: stripeMethod76({
    method: "GET",
    fullPath: "/v1/invoices/upcoming"
  }),
  search: stripeMethod76({
    method: "GET",
    fullPath: "/v1/invoices/search",
    methodType: "search"
  }),
  sendInvoice: stripeMethod76({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/send"
  }),
  voidInvoice: stripeMethod76({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/void"
  })
});

// node_modules/stripe/esm/resources/Mandates.js
init_modules_watch_stub();
var stripeMethod77 = StripeResource.method;
var Mandates = StripeResource.extend({
  retrieve: stripeMethod77({ method: "GET", fullPath: "/v1/mandates/{mandate}" })
});

// node_modules/stripe/esm/resources/OAuth.js
init_modules_watch_stub();
var stripeMethod78 = StripeResource.method;
var oAuthHost = "connect.stripe.com";
var OAuth = StripeResource.extend({
  basePath: "/",
  authorizeUrl(params, options) {
    params = params || {};
    options = options || {};
    let path = "oauth/authorize";
    if (options.express) {
      path = `express/${path}`;
    }
    if (!params.response_type) {
      params.response_type = "code";
    }
    if (!params.client_id) {
      params.client_id = this._stripe.getClientId();
    }
    if (!params.scope) {
      params.scope = "read_write";
    }
    return `https://${oAuthHost}/${path}?${stringifyRequestData(params)}`;
  },
  token: stripeMethod78({
    method: "POST",
    path: "oauth/token",
    host: oAuthHost
  }),
  deauthorize(spec, ...args) {
    if (!spec.client_id) {
      spec.client_id = this._stripe.getClientId();
    }
    return stripeMethod78({
      method: "POST",
      path: "oauth/deauthorize",
      host: oAuthHost
    }).apply(this, [spec, ...args]);
  }
});

// node_modules/stripe/esm/resources/PaymentIntents.js
init_modules_watch_stub();
var stripeMethod79 = StripeResource.method;
var PaymentIntents = StripeResource.extend({
  create: stripeMethod79({ method: "POST", fullPath: "/v1/payment_intents" }),
  retrieve: stripeMethod79({
    method: "GET",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  update: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  list: stripeMethod79({
    method: "GET",
    fullPath: "/v1/payment_intents",
    methodType: "list"
  }),
  applyCustomerBalance: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/apply_customer_balance"
  }),
  cancel: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/cancel"
  }),
  capture: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/capture"
  }),
  confirm: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/confirm"
  }),
  incrementAuthorization: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/increment_authorization"
  }),
  search: stripeMethod79({
    method: "GET",
    fullPath: "/v1/payment_intents/search",
    methodType: "search"
  }),
  verifyMicrodeposits: stripeMethod79({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/verify_microdeposits"
  })
});

// node_modules/stripe/esm/resources/PaymentLinks.js
init_modules_watch_stub();
var stripeMethod80 = StripeResource.method;
var PaymentLinks = StripeResource.extend({
  create: stripeMethod80({ method: "POST", fullPath: "/v1/payment_links" }),
  retrieve: stripeMethod80({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  update: stripeMethod80({
    method: "POST",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  list: stripeMethod80({
    method: "GET",
    fullPath: "/v1/payment_links",
    methodType: "list"
  }),
  listLineItems: stripeMethod80({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/PaymentMethodConfigurations.js
init_modules_watch_stub();
var stripeMethod81 = StripeResource.method;
var PaymentMethodConfigurations = StripeResource.extend({
  create: stripeMethod81({
    method: "POST",
    fullPath: "/v1/payment_method_configurations"
  }),
  retrieve: stripeMethod81({
    method: "GET",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  update: stripeMethod81({
    method: "POST",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  list: stripeMethod81({
    method: "GET",
    fullPath: "/v1/payment_method_configurations",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/PaymentMethodDomains.js
init_modules_watch_stub();
var stripeMethod82 = StripeResource.method;
var PaymentMethodDomains = StripeResource.extend({
  create: stripeMethod82({
    method: "POST",
    fullPath: "/v1/payment_method_domains"
  }),
  retrieve: stripeMethod82({
    method: "GET",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  update: stripeMethod82({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  list: stripeMethod82({
    method: "GET",
    fullPath: "/v1/payment_method_domains",
    methodType: "list"
  }),
  validate: stripeMethod82({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}/validate"
  })
});

// node_modules/stripe/esm/resources/PaymentMethods.js
init_modules_watch_stub();
var stripeMethod83 = StripeResource.method;
var PaymentMethods = StripeResource.extend({
  create: stripeMethod83({ method: "POST", fullPath: "/v1/payment_methods" }),
  retrieve: stripeMethod83({
    method: "GET",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  update: stripeMethod83({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  list: stripeMethod83({
    method: "GET",
    fullPath: "/v1/payment_methods",
    methodType: "list"
  }),
  attach: stripeMethod83({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/attach"
  }),
  detach: stripeMethod83({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/detach"
  })
});

// node_modules/stripe/esm/resources/Payouts.js
init_modules_watch_stub();
var stripeMethod84 = StripeResource.method;
var Payouts = StripeResource.extend({
  create: stripeMethod84({ method: "POST", fullPath: "/v1/payouts" }),
  retrieve: stripeMethod84({ method: "GET", fullPath: "/v1/payouts/{payout}" }),
  update: stripeMethod84({ method: "POST", fullPath: "/v1/payouts/{payout}" }),
  list: stripeMethod84({
    method: "GET",
    fullPath: "/v1/payouts",
    methodType: "list"
  }),
  cancel: stripeMethod84({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/cancel"
  }),
  reverse: stripeMethod84({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/reverse"
  })
});

// node_modules/stripe/esm/resources/Plans.js
init_modules_watch_stub();
var stripeMethod85 = StripeResource.method;
var Plans = StripeResource.extend({
  create: stripeMethod85({ method: "POST", fullPath: "/v1/plans" }),
  retrieve: stripeMethod85({ method: "GET", fullPath: "/v1/plans/{plan}" }),
  update: stripeMethod85({ method: "POST", fullPath: "/v1/plans/{plan}" }),
  list: stripeMethod85({
    method: "GET",
    fullPath: "/v1/plans",
    methodType: "list"
  }),
  del: stripeMethod85({ method: "DELETE", fullPath: "/v1/plans/{plan}" })
});

// node_modules/stripe/esm/resources/Prices.js
init_modules_watch_stub();
var stripeMethod86 = StripeResource.method;
var Prices = StripeResource.extend({
  create: stripeMethod86({ method: "POST", fullPath: "/v1/prices" }),
  retrieve: stripeMethod86({ method: "GET", fullPath: "/v1/prices/{price}" }),
  update: stripeMethod86({ method: "POST", fullPath: "/v1/prices/{price}" }),
  list: stripeMethod86({
    method: "GET",
    fullPath: "/v1/prices",
    methodType: "list"
  }),
  search: stripeMethod86({
    method: "GET",
    fullPath: "/v1/prices/search",
    methodType: "search"
  })
});

// node_modules/stripe/esm/resources/Products.js
init_modules_watch_stub();
var stripeMethod87 = StripeResource.method;
var Products2 = StripeResource.extend({
  create: stripeMethod87({ method: "POST", fullPath: "/v1/products" }),
  retrieve: stripeMethod87({ method: "GET", fullPath: "/v1/products/{id}" }),
  update: stripeMethod87({ method: "POST", fullPath: "/v1/products/{id}" }),
  list: stripeMethod87({
    method: "GET",
    fullPath: "/v1/products",
    methodType: "list"
  }),
  del: stripeMethod87({ method: "DELETE", fullPath: "/v1/products/{id}" }),
  search: stripeMethod87({
    method: "GET",
    fullPath: "/v1/products/search",
    methodType: "search"
  })
});

// node_modules/stripe/esm/resources/PromotionCodes.js
init_modules_watch_stub();
var stripeMethod88 = StripeResource.method;
var PromotionCodes = StripeResource.extend({
  create: stripeMethod88({ method: "POST", fullPath: "/v1/promotion_codes" }),
  retrieve: stripeMethod88({
    method: "GET",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  update: stripeMethod88({
    method: "POST",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  list: stripeMethod88({
    method: "GET",
    fullPath: "/v1/promotion_codes",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Quotes.js
init_modules_watch_stub();
var stripeMethod89 = StripeResource.method;
var Quotes = StripeResource.extend({
  create: stripeMethod89({ method: "POST", fullPath: "/v1/quotes" }),
  retrieve: stripeMethod89({ method: "GET", fullPath: "/v1/quotes/{quote}" }),
  update: stripeMethod89({ method: "POST", fullPath: "/v1/quotes/{quote}" }),
  list: stripeMethod89({
    method: "GET",
    fullPath: "/v1/quotes",
    methodType: "list"
  }),
  accept: stripeMethod89({ method: "POST", fullPath: "/v1/quotes/{quote}/accept" }),
  cancel: stripeMethod89({ method: "POST", fullPath: "/v1/quotes/{quote}/cancel" }),
  finalizeQuote: stripeMethod89({
    method: "POST",
    fullPath: "/v1/quotes/{quote}/finalize"
  }),
  listComputedUpfrontLineItems: stripeMethod89({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/computed_upfront_line_items",
    methodType: "list"
  }),
  listLineItems: stripeMethod89({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/line_items",
    methodType: "list"
  }),
  pdf: stripeMethod89({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/pdf",
    host: "files.stripe.com",
    streaming: true
  })
});

// node_modules/stripe/esm/resources/Refunds.js
init_modules_watch_stub();
var stripeMethod90 = StripeResource.method;
var Refunds2 = StripeResource.extend({
  create: stripeMethod90({ method: "POST", fullPath: "/v1/refunds" }),
  retrieve: stripeMethod90({ method: "GET", fullPath: "/v1/refunds/{refund}" }),
  update: stripeMethod90({ method: "POST", fullPath: "/v1/refunds/{refund}" }),
  list: stripeMethod90({
    method: "GET",
    fullPath: "/v1/refunds",
    methodType: "list"
  }),
  cancel: stripeMethod90({
    method: "POST",
    fullPath: "/v1/refunds/{refund}/cancel"
  })
});

// node_modules/stripe/esm/resources/Reviews.js
init_modules_watch_stub();
var stripeMethod91 = StripeResource.method;
var Reviews = StripeResource.extend({
  retrieve: stripeMethod91({ method: "GET", fullPath: "/v1/reviews/{review}" }),
  list: stripeMethod91({
    method: "GET",
    fullPath: "/v1/reviews",
    methodType: "list"
  }),
  approve: stripeMethod91({
    method: "POST",
    fullPath: "/v1/reviews/{review}/approve"
  })
});

// node_modules/stripe/esm/resources/SetupAttempts.js
init_modules_watch_stub();
var stripeMethod92 = StripeResource.method;
var SetupAttempts = StripeResource.extend({
  list: stripeMethod92({
    method: "GET",
    fullPath: "/v1/setup_attempts",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/SetupIntents.js
init_modules_watch_stub();
var stripeMethod93 = StripeResource.method;
var SetupIntents = StripeResource.extend({
  create: stripeMethod93({ method: "POST", fullPath: "/v1/setup_intents" }),
  retrieve: stripeMethod93({
    method: "GET",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  update: stripeMethod93({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  list: stripeMethod93({
    method: "GET",
    fullPath: "/v1/setup_intents",
    methodType: "list"
  }),
  cancel: stripeMethod93({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/cancel"
  }),
  confirm: stripeMethod93({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/confirm"
  }),
  verifyMicrodeposits: stripeMethod93({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/verify_microdeposits"
  })
});

// node_modules/stripe/esm/resources/ShippingRates.js
init_modules_watch_stub();
var stripeMethod94 = StripeResource.method;
var ShippingRates = StripeResource.extend({
  create: stripeMethod94({ method: "POST", fullPath: "/v1/shipping_rates" }),
  retrieve: stripeMethod94({
    method: "GET",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  update: stripeMethod94({
    method: "POST",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  list: stripeMethod94({
    method: "GET",
    fullPath: "/v1/shipping_rates",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Sources.js
init_modules_watch_stub();
var stripeMethod95 = StripeResource.method;
var Sources = StripeResource.extend({
  create: stripeMethod95({ method: "POST", fullPath: "/v1/sources" }),
  retrieve: stripeMethod95({ method: "GET", fullPath: "/v1/sources/{source}" }),
  update: stripeMethod95({ method: "POST", fullPath: "/v1/sources/{source}" }),
  listSourceTransactions: stripeMethod95({
    method: "GET",
    fullPath: "/v1/sources/{source}/source_transactions",
    methodType: "list"
  }),
  verify: stripeMethod95({
    method: "POST",
    fullPath: "/v1/sources/{source}/verify"
  })
});

// node_modules/stripe/esm/resources/SubscriptionItems.js
init_modules_watch_stub();
var stripeMethod96 = StripeResource.method;
var SubscriptionItems = StripeResource.extend({
  create: stripeMethod96({ method: "POST", fullPath: "/v1/subscription_items" }),
  retrieve: stripeMethod96({
    method: "GET",
    fullPath: "/v1/subscription_items/{item}"
  }),
  update: stripeMethod96({
    method: "POST",
    fullPath: "/v1/subscription_items/{item}"
  }),
  list: stripeMethod96({
    method: "GET",
    fullPath: "/v1/subscription_items",
    methodType: "list"
  }),
  del: stripeMethod96({
    method: "DELETE",
    fullPath: "/v1/subscription_items/{item}"
  }),
  createUsageRecord: stripeMethod96({
    method: "POST",
    fullPath: "/v1/subscription_items/{subscription_item}/usage_records"
  }),
  listUsageRecordSummaries: stripeMethod96({
    method: "GET",
    fullPath: "/v1/subscription_items/{subscription_item}/usage_record_summaries",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/SubscriptionSchedules.js
init_modules_watch_stub();
var stripeMethod97 = StripeResource.method;
var SubscriptionSchedules = StripeResource.extend({
  create: stripeMethod97({
    method: "POST",
    fullPath: "/v1/subscription_schedules"
  }),
  retrieve: stripeMethod97({
    method: "GET",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  update: stripeMethod97({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  list: stripeMethod97({
    method: "GET",
    fullPath: "/v1/subscription_schedules",
    methodType: "list"
  }),
  cancel: stripeMethod97({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/cancel"
  }),
  release: stripeMethod97({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/release"
  })
});

// node_modules/stripe/esm/resources/Subscriptions.js
init_modules_watch_stub();
var stripeMethod98 = StripeResource.method;
var Subscriptions = StripeResource.extend({
  create: stripeMethod98({ method: "POST", fullPath: "/v1/subscriptions" }),
  retrieve: stripeMethod98({
    method: "GET",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  update: stripeMethod98({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  list: stripeMethod98({
    method: "GET",
    fullPath: "/v1/subscriptions",
    methodType: "list"
  }),
  cancel: stripeMethod98({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  deleteDiscount: stripeMethod98({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}/discount"
  }),
  resume: stripeMethod98({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription}/resume"
  }),
  search: stripeMethod98({
    method: "GET",
    fullPath: "/v1/subscriptions/search",
    methodType: "search"
  })
});

// node_modules/stripe/esm/resources/TaxCodes.js
init_modules_watch_stub();
var stripeMethod99 = StripeResource.method;
var TaxCodes = StripeResource.extend({
  retrieve: stripeMethod99({ method: "GET", fullPath: "/v1/tax_codes/{id}" }),
  list: stripeMethod99({
    method: "GET",
    fullPath: "/v1/tax_codes",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TaxRates.js
init_modules_watch_stub();
var stripeMethod100 = StripeResource.method;
var TaxRates = StripeResource.extend({
  create: stripeMethod100({ method: "POST", fullPath: "/v1/tax_rates" }),
  retrieve: stripeMethod100({ method: "GET", fullPath: "/v1/tax_rates/{tax_rate}" }),
  update: stripeMethod100({ method: "POST", fullPath: "/v1/tax_rates/{tax_rate}" }),
  list: stripeMethod100({
    method: "GET",
    fullPath: "/v1/tax_rates",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Tokens.js
init_modules_watch_stub();
var stripeMethod101 = StripeResource.method;
var Tokens2 = StripeResource.extend({
  create: stripeMethod101({ method: "POST", fullPath: "/v1/tokens" }),
  retrieve: stripeMethod101({ method: "GET", fullPath: "/v1/tokens/{token}" })
});

// node_modules/stripe/esm/resources/Topups.js
init_modules_watch_stub();
var stripeMethod102 = StripeResource.method;
var Topups = StripeResource.extend({
  create: stripeMethod102({ method: "POST", fullPath: "/v1/topups" }),
  retrieve: stripeMethod102({ method: "GET", fullPath: "/v1/topups/{topup}" }),
  update: stripeMethod102({ method: "POST", fullPath: "/v1/topups/{topup}" }),
  list: stripeMethod102({
    method: "GET",
    fullPath: "/v1/topups",
    methodType: "list"
  }),
  cancel: stripeMethod102({ method: "POST", fullPath: "/v1/topups/{topup}/cancel" })
});

// node_modules/stripe/esm/resources/Transfers.js
init_modules_watch_stub();
var stripeMethod103 = StripeResource.method;
var Transfers = StripeResource.extend({
  create: stripeMethod103({ method: "POST", fullPath: "/v1/transfers" }),
  retrieve: stripeMethod103({ method: "GET", fullPath: "/v1/transfers/{transfer}" }),
  update: stripeMethod103({ method: "POST", fullPath: "/v1/transfers/{transfer}" }),
  list: stripeMethod103({
    method: "GET",
    fullPath: "/v1/transfers",
    methodType: "list"
  }),
  createReversal: stripeMethod103({
    method: "POST",
    fullPath: "/v1/transfers/{id}/reversals"
  }),
  listReversals: stripeMethod103({
    method: "GET",
    fullPath: "/v1/transfers/{id}/reversals",
    methodType: "list"
  }),
  retrieveReversal: stripeMethod103({
    method: "GET",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  }),
  updateReversal: stripeMethod103({
    method: "POST",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  })
});

// node_modules/stripe/esm/resources/WebhookEndpoints.js
init_modules_watch_stub();
var stripeMethod104 = StripeResource.method;
var WebhookEndpoints = StripeResource.extend({
  create: stripeMethod104({ method: "POST", fullPath: "/v1/webhook_endpoints" }),
  retrieve: stripeMethod104({
    method: "GET",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  update: stripeMethod104({
    method: "POST",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  list: stripeMethod104({
    method: "GET",
    fullPath: "/v1/webhook_endpoints",
    methodType: "list"
  }),
  del: stripeMethod104({
    method: "DELETE",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  })
});

// node_modules/stripe/esm/resources.js
var Apps = resourceNamespace("apps", { Secrets });
var BillingPortal = resourceNamespace("billingPortal", {
  Configurations,
  Sessions
});
var Checkout = resourceNamespace("checkout", {
  Sessions: Sessions2
});
var Climate = resourceNamespace("climate", {
  Orders,
  Products,
  Suppliers
});
var FinancialConnections = resourceNamespace("financialConnections", {
  Accounts,
  Sessions: Sessions3,
  Transactions: Transactions2
});
var Identity = resourceNamespace("identity", {
  VerificationReports,
  VerificationSessions
});
var Issuing = resourceNamespace("issuing", {
  Authorizations: Authorizations2,
  Cardholders,
  Cards: Cards2,
  Disputes,
  Tokens,
  Transactions: Transactions3
});
var Radar = resourceNamespace("radar", {
  EarlyFraudWarnings,
  ValueListItems,
  ValueLists
});
var Reporting = resourceNamespace("reporting", {
  ReportRuns,
  ReportTypes
});
var Sigma = resourceNamespace("sigma", {
  ScheduledQueryRuns
});
var Tax = resourceNamespace("tax", {
  Calculations,
  Registrations,
  Settings,
  Transactions: Transactions4
});
var Terminal = resourceNamespace("terminal", {
  Configurations: Configurations2,
  ConnectionTokens,
  Locations,
  Readers: Readers2
});
var TestHelpers = resourceNamespace("testHelpers", {
  Customers,
  Refunds,
  TestClocks,
  Issuing: resourceNamespace("issuing", {
    Authorizations,
    Cards,
    Transactions
  }),
  Terminal: resourceNamespace("terminal", {
    Readers
  }),
  Treasury: resourceNamespace("treasury", {
    InboundTransfers,
    OutboundPayments,
    OutboundTransfers,
    ReceivedCredits,
    ReceivedDebits
  })
});
var Treasury = resourceNamespace("treasury", {
  CreditReversals,
  DebitReversals,
  FinancialAccounts,
  InboundTransfers: InboundTransfers2,
  OutboundPayments: OutboundPayments2,
  OutboundTransfers: OutboundTransfers2,
  ReceivedCredits: ReceivedCredits2,
  ReceivedDebits: ReceivedDebits2,
  TransactionEntries,
  Transactions: Transactions5
});

// node_modules/stripe/esm/RequestSender.js
init_modules_watch_stub();
var MAX_RETRY_AFTER_WAIT = 60;
var RequestSender = class {
  constructor(stripe, maxBufferedRequestMetric) {
    this._stripe = stripe;
    this._maxBufferedRequestMetric = maxBufferedRequestMetric;
  }
  _addHeadersDirectlyToObject(obj, headers) {
    obj.requestId = headers["request-id"];
    obj.stripeAccount = obj.stripeAccount || headers["stripe-account"];
    obj.apiVersion = obj.apiVersion || headers["stripe-version"];
    obj.idempotencyKey = obj.idempotencyKey || headers["idempotency-key"];
  }
  _makeResponseEvent(requestEvent, statusCode, headers) {
    const requestEndTime = Date.now();
    const requestDurationMs = requestEndTime - requestEvent.request_start_time;
    return removeNullish({
      api_version: headers["stripe-version"],
      account: headers["stripe-account"],
      idempotency_key: headers["idempotency-key"],
      method: requestEvent.method,
      path: requestEvent.path,
      status: statusCode,
      request_id: this._getRequestId(headers),
      elapsed: requestDurationMs,
      request_start_time: requestEvent.request_start_time,
      request_end_time: requestEndTime
    });
  }
  _getRequestId(headers) {
    return headers["request-id"];
  }
  /**
   * Used by methods with spec.streaming === true. For these methods, we do not
   * buffer successful responses into memory or do parse them into stripe
   * objects, we delegate that all of that to the user and pass back the raw
   * http.Response object to the callback.
   *
   * (Unsuccessful responses shouldn't make it here, they should
   * still be buffered/parsed and handled by _jsonResponseHandler -- see
   * makeRequest)
   */
  _streamingResponseHandler(requestEvent, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const streamCompleteCallback = () => {
        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
        this._stripe._emitter.emit("response", responseEvent);
        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);
      };
      const stream = res.toStream(streamCompleteCallback);
      this._addHeadersDirectlyToObject(stream, headers);
      return callback(null, stream);
    };
  }
  /**
   * Default handler for Stripe responses. Buffers the response into memory,
   * parses the JSON and returns it (i.e. passes it to the callback) if there
   * is no "error" field. Otherwise constructs/passes an appropriate Error.
   */
  _jsonResponseHandler(requestEvent, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const requestId = this._getRequestId(headers);
      const statusCode = res.getStatusCode();
      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);
      this._stripe._emitter.emit("response", responseEvent);
      res.toJSON().then((jsonResponse) => {
        if (jsonResponse.error) {
          let err;
          if (typeof jsonResponse.error === "string") {
            jsonResponse.error = {
              type: jsonResponse.error,
              message: jsonResponse.error_description
            };
          }
          jsonResponse.error.headers = headers;
          jsonResponse.error.statusCode = statusCode;
          jsonResponse.error.requestId = requestId;
          if (statusCode === 401) {
            err = new StripeAuthenticationError(jsonResponse.error);
          } else if (statusCode === 403) {
            err = new StripePermissionError(jsonResponse.error);
          } else if (statusCode === 429) {
            err = new StripeRateLimitError(jsonResponse.error);
          } else {
            err = StripeError.generate(jsonResponse.error);
          }
          throw err;
        }
        return jsonResponse;
      }, (e3) => {
        throw new StripeAPIError({
          message: "Invalid JSON received from the Stripe API",
          exception: e3,
          requestId: headers["request-id"]
        });
      }).then((jsonResponse) => {
        this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);
        const rawResponse = res.getRawResponse();
        this._addHeadersDirectlyToObject(rawResponse, headers);
        Object.defineProperty(jsonResponse, "lastResponse", {
          enumerable: false,
          writable: false,
          value: rawResponse
        });
        callback(null, jsonResponse);
      }, (e3) => callback(e3, null));
    };
  }
  static _generateConnectionErrorMessage(requestRetries) {
    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ""}`;
  }
  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency
  static _shouldRetry(res, numRetries, maxRetries, error) {
    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {
      return true;
    }
    if (numRetries >= maxRetries) {
      return false;
    }
    if (!res) {
      return true;
    }
    if (res.getHeaders()["stripe-should-retry"] === "false") {
      return false;
    }
    if (res.getHeaders()["stripe-should-retry"] === "true") {
      return true;
    }
    if (res.getStatusCode() === 409) {
      return true;
    }
    if (res.getStatusCode() >= 500) {
      return true;
    }
    return false;
  }
  _getSleepTimeInMS(numRetries, retryAfter = null) {
    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);
    sleepSeconds *= 0.5 * (1 + Math.random());
    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
      sleepSeconds = Math.max(sleepSeconds, retryAfter);
    }
    return sleepSeconds * 1e3;
  }
  // Max retries can be set on a per request basis. Favor those over the global setting
  _getMaxNetworkRetries(settings = {}) {
    return settings.maxNetworkRetries !== void 0 && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();
  }
  _defaultIdempotencyKey(method, settings) {
    const maxRetries = this._getMaxNetworkRetries(settings);
    if (method === "POST" && maxRetries > 0) {
      return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;
    }
    return null;
  }
  _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {
    const defaultHeaders = {
      // Use specified auth token or use default from this stripe instance:
      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField("auth"),
      Accept: "application/json",
      "Content-Type": "application/x-www-form-urlencoded",
      "User-Agent": this._getUserAgentString(),
      "X-Stripe-Client-User-Agent": clientUserAgent,
      "X-Stripe-Client-Telemetry": this._getTelemetryHeader(),
      "Stripe-Version": apiVersion,
      "Stripe-Account": this._stripe.getApiField("stripeAccount"),
      "Idempotency-Key": this._defaultIdempotencyKey(method, userSuppliedSettings)
    };
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    if (methodHasPayload || contentLength) {
      if (!methodHasPayload) {
        emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);
      }
      defaultHeaders["Content-Length"] = contentLength;
    }
    return Object.assign(
      removeNullish(defaultHeaders),
      // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.
      normalizeHeaders(userSuppliedHeaders)
    );
  }
  _getUserAgentString() {
    const packageVersion = this._stripe.getConstant("PACKAGE_VERSION");
    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : "";
    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();
  }
  _getTelemetryHeader() {
    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {
      const metrics = this._stripe._prevRequestMetrics.shift();
      return JSON.stringify({
        last_request_metrics: metrics
      });
    }
  }
  _recordRequestMetrics(requestId, requestDurationMs, usage) {
    if (this._stripe.getTelemetryEnabled() && requestId) {
      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
        emitWarning("Request metrics buffer is full, dropping telemetry message.");
      } else {
        const m3 = {
          request_id: requestId,
          request_duration_ms: requestDurationMs
        };
        if (usage && usage.length > 0) {
          m3.usage = usage;
        }
        this._stripe._prevRequestMetrics.push(m3);
      }
    }
  }
  _request(method, host, path, data, auth, options = {}, usage = [], callback, requestDataProcessor = null) {
    let requestData;
    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {
      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
    };
    const makeRequest = (apiVersion, headers, numRetries) => {
      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField("timeout");
      const req = this._stripe.getApiField("httpClient").makeRequest(host || this._stripe.getApiField("host"), this._stripe.getApiField("port"), path, method, headers, requestData, this._stripe.getApiField("protocol"), timeout);
      const requestStartTime = Date.now();
      const requestEvent = removeNullish({
        api_version: apiVersion,
        account: headers["Stripe-Account"],
        idempotency_key: headers["Idempotency-Key"],
        method,
        path,
        request_start_time: requestStartTime
      });
      const requestRetries = numRetries || 0;
      const maxRetries = this._getMaxNetworkRetries(options.settings || {});
      this._stripe._emitter.emit("request", requestEvent);
      req.then((res) => {
        if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
          return retryRequest(
            makeRequest,
            apiVersion,
            headers,
            requestRetries,
            // @ts-ignore
            res.getHeaders()["retry-after"]
          );
        } else if (options.streaming && res.getStatusCode() < 400) {
          return this._streamingResponseHandler(requestEvent, usage, callback)(res);
        } else {
          return this._jsonResponseHandler(requestEvent, usage, callback)(res);
        }
      }).catch((error) => {
        if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {
          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
        } else {
          const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;
          return callback(new StripeConnectionError({
            message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),
            // @ts-ignore
            detail: error
          }));
        }
      });
    };
    const prepareAndMakeRequest = (error, data2) => {
      if (error) {
        return callback(error);
      }
      requestData = data2;
      this._stripe.getClientUserAgent((clientUserAgent) => {
        var _a90, _b;
        const apiVersion = this._stripe.getApiField("version");
        const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a90 = options.headers) !== null && _a90 !== void 0 ? _a90 : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});
        makeRequest(apiVersion, headers, 0);
      });
    };
    if (requestDataProcessor) {
      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
    } else {
      prepareAndMakeRequest(null, stringifyRequestData(data || {}));
    }
  }
};

// node_modules/stripe/esm/Webhooks.js
init_modules_watch_stub();
function createWebhooks(platformFunctions) {
  const Webhook = {
    DEFAULT_TOLERANCE: 300,
    // @ts-ignore
    signature: null,
    constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      try {
        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      } catch (e3) {
        if (e3 instanceof CryptoProviderOnlySupportsAsyncError) {
          e3.message += "\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`";
        }
        throw e3;
      }
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    /**
     * Generates a header to be used for webhook mocking
     *
     * @typedef {object} opts
     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()
     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters
     * @property {string} secret - Stripe webhook secret 'whsec_...'
     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.
     * @property {string} signature - Computed webhook signature
     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.
     */
    generateTestHeaderString: function(opts) {
      if (!opts) {
        throw new StripeError({
          message: "Options are required"
        });
      }
      opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1e3);
      opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;
      opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();
      opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + "." + opts.payload, opts.secret);
      const generatedHeader = [
        "t=" + opts.timestamp,
        opts.scheme + "=" + opts.signature
      ].join(",");
      return generatedHeader;
    }
  };
  const signature = {
    EXPECTED_SCHEME: "v1",
    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
      return true;
    },
    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);
      return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
    }
  };
  function makeHMACContent(payload, details) {
    return `${details.timestamp}.${payload}`;
  }
  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
    if (!encodedPayload) {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No webhook payload was provided."
      });
    }
    const suspectPayloadType = typeof encodedPayload != "string" && !(encodedPayload instanceof Uint8Array);
    const textDecoder = new TextDecoder("utf8");
    const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;
    if (Array.isArray(encodedHeader)) {
      throw new Error("Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.");
    }
    if (encodedHeader == null || encodedHeader == "") {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No stripe-signature header value was provided."
      });
    }
    const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;
    const details = parseHeader(decodedHeader, expectedScheme);
    if (!details || details.timestamp === -1) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "Unable to extract timestamp and signatures from header"
      });
    }
    if (!details.signatures.length) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "No signatures found with expected scheme"
      });
    }
    return {
      decodedPayload,
      decodedHeader,
      details,
      suspectPayloadType
    };
  }
  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {
    const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
    const docsLocation = "\nLearn more about webhook signing and explore webhook integration examples for various frameworks at https://github.com/stripe/stripe-node#webhook-signing";
    const whitespaceMessage = secretContainsWhitespace ? "\n\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value" : "";
    if (!signatureFound) {
      if (suspectPayloadType) {
        throw new StripeSignatureVerificationError(header, payload, {
          message: "Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.Payload was provided as a parsed JavaScript object instead. \nSignature verification is impossible without access to the original signed material. \n" + docsLocation + "\n" + whitespaceMessage
        });
      }
      throw new StripeSignatureVerificationError(header, payload, {
        message: "No signatures found matching the expected signature for payload. Are you passing the raw request body you received from Stripe? \n If a webhook request is being forwarded by a third-party tool, ensure that the exact request body, including JSON formatting and new line style, is preserved.\n" + docsLocation + "\n" + whitespaceMessage
      });
    }
    const timestampAge = Math.floor((typeof receivedAt === "number" ? receivedAt : Date.now()) / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new StripeSignatureVerificationError(header, payload, {
        message: "Timestamp outside the tolerance zone"
      });
    }
    return true;
  }
  function parseHeader(header, scheme) {
    if (typeof header !== "string") {
      return null;
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme) {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  let webhooksCryptoProviderInstance = null;
  function getCryptoProvider() {
    if (!webhooksCryptoProviderInstance) {
      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
    }
    return webhooksCryptoProviderInstance;
  }
  Webhook.signature = signature;
  return Webhook;
}

// node_modules/stripe/esm/stripe.core.js
var DEFAULT_HOST = "api.stripe.com";
var DEFAULT_PORT = "443";
var DEFAULT_BASE_PATH = "/v1/";
var DEFAULT_API_VERSION = ApiVersion;
var DEFAULT_TIMEOUT = 8e4;
var MAX_NETWORK_RETRY_DELAY_SEC = 2;
var INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
var APP_INFO_PROPERTIES = ["name", "version", "url", "partner_id"];
var ALLOWED_CONFIG_PROPERTIES = [
  "apiVersion",
  "typescript",
  "maxNetworkRetries",
  "httpAgent",
  "httpClient",
  "timeout",
  "host",
  "port",
  "protocol",
  "telemetry",
  "appInfo",
  "stripeAccount"
];
var defaultRequestSenderFactory = (stripe) => new RequestSender(stripe, StripeResource.MAX_BUFFERED_REQUEST_METRICS);
function createStripe(platformFunctions, requestSender = defaultRequestSenderFactory) {
  Stripe2.PACKAGE_VERSION = "14.16.0";
  Stripe2.USER_AGENT = Object.assign({ bindings_version: Stripe2.PACKAGE_VERSION, lang: "node", publisher: "stripe", uname: null, typescript: false }, determineProcessUserAgentProperties());
  Stripe2.StripeResource = StripeResource;
  Stripe2.resources = resources_exports;
  Stripe2.HttpClient = HttpClient;
  Stripe2.HttpClientResponse = HttpClientResponse;
  Stripe2.CryptoProvider = CryptoProvider;
  function createWebhooksDefault(fns = platformFunctions) {
    return createWebhooks(fns);
  }
  Stripe2.webhooks = Object.assign(createWebhooksDefault, createWebhooks(platformFunctions));
  function Stripe2(key, config = {}) {
    if (!(this instanceof Stripe2)) {
      return new Stripe2(key, config);
    }
    const props = this._getPropsFromConfig(config);
    this._platformFunctions = platformFunctions;
    Object.defineProperty(this, "_emitter", {
      value: this._platformFunctions.createEmitter(),
      enumerable: false,
      configurable: false,
      writable: false
    });
    this.VERSION = Stripe2.PACKAGE_VERSION;
    this.on = this._emitter.on.bind(this._emitter);
    this.once = this._emitter.once.bind(this._emitter);
    this.off = this._emitter.removeListener.bind(this._emitter);
    const agent = props.httpAgent || null;
    this._api = {
      auth: null,
      host: props.host || DEFAULT_HOST,
      port: props.port || DEFAULT_PORT,
      protocol: props.protocol || "https",
      basePath: DEFAULT_BASE_PATH,
      version: props.apiVersion || DEFAULT_API_VERSION,
      timeout: validateInteger("timeout", props.timeout, DEFAULT_TIMEOUT),
      maxNetworkRetries: validateInteger("maxNetworkRetries", props.maxNetworkRetries, 1),
      agent,
      httpClient: props.httpClient || (agent ? this._platformFunctions.createNodeHttpClient(agent) : this._platformFunctions.createDefaultHttpClient()),
      dev: false,
      stripeAccount: props.stripeAccount || null
    };
    const typescript = props.typescript || false;
    if (typescript !== Stripe2.USER_AGENT.typescript) {
      Stripe2.USER_AGENT.typescript = typescript;
    }
    if (props.appInfo) {
      this._setAppInfo(props.appInfo);
    }
    this._prepResources();
    this._setApiKey(key);
    this.errors = Error_exports;
    this.webhooks = createWebhooksDefault();
    this._prevRequestMetrics = [];
    this._enableTelemetry = props.telemetry !== false;
    this._requestSender = requestSender(this);
    this.StripeResource = Stripe2.StripeResource;
  }
  Stripe2.errors = Error_exports;
  Stripe2.createNodeHttpClient = platformFunctions.createNodeHttpClient;
  Stripe2.createFetchHttpClient = platformFunctions.createFetchHttpClient;
  Stripe2.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
  Stripe2.createSubtleCryptoProvider = platformFunctions.createSubtleCryptoProvider;
  Stripe2.prototype = {
    // Properties are set in the constructor above
    _appInfo: void 0,
    on: null,
    off: null,
    once: null,
    VERSION: null,
    StripeResource: null,
    webhooks: null,
    errors: null,
    _api: null,
    _prevRequestMetrics: null,
    _emitter: null,
    _enableTelemetry: null,
    _requestSender: null,
    _platformFunctions: null,
    /**
     * @private
     */
    _setApiKey(key) {
      if (key) {
        this._setApiField("auth", `Bearer ${key}`);
      }
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setAppInfo(info) {
      if (info && typeof info !== "object") {
        throw new Error("AppInfo must be an object.");
      }
      if (info && !info.name) {
        throw new Error("AppInfo.name is required");
      }
      info = info || {};
      this._appInfo = APP_INFO_PROPERTIES.reduce(
        (accum, prop) => {
          if (typeof info[prop] == "string") {
            accum = accum || {};
            accum[prop] = info[prop];
          }
          return accum;
        },
        // @ts-ignore
        void 0
      );
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiField(key, value) {
      this._api[key] = value;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getApiField(key) {
      return this._api[key];
    },
    setClientId(clientId) {
      this._clientId = clientId;
    },
    getClientId() {
      return this._clientId;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getConstant: (c3) => {
      switch (c3) {
        case "DEFAULT_HOST":
          return DEFAULT_HOST;
        case "DEFAULT_PORT":
          return DEFAULT_PORT;
        case "DEFAULT_BASE_PATH":
          return DEFAULT_BASE_PATH;
        case "DEFAULT_API_VERSION":
          return DEFAULT_API_VERSION;
        case "DEFAULT_TIMEOUT":
          return DEFAULT_TIMEOUT;
        case "MAX_NETWORK_RETRY_DELAY_SEC":
          return MAX_NETWORK_RETRY_DELAY_SEC;
        case "INITIAL_NETWORK_RETRY_DELAY_SEC":
          return INITIAL_NETWORK_RETRY_DELAY_SEC;
      }
      return Stripe2[c3];
    },
    getMaxNetworkRetries() {
      return this.getApiField("maxNetworkRetries");
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiNumberField(prop, n2, defaultVal) {
      const val = validateInteger(prop, n2, defaultVal);
      this._setApiField(prop, val);
    },
    getMaxNetworkRetryDelay() {
      return MAX_NETWORK_RETRY_DELAY_SEC;
    },
    getInitialNetworkRetryDelay() {
      return INITIAL_NETWORK_RETRY_DELAY_SEC;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent and uses a cached version for a slight
     * speed advantage.
     */
    getClientUserAgent(cb) {
      return this.getClientUserAgentSeeded(Stripe2.USER_AGENT, cb);
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent by encoding a seeded object and
     * fetching a uname from the system.
     */
    getClientUserAgentSeeded(seed, cb) {
      this._platformFunctions.getUname().then((uname) => {
        var _a90;
        const userAgent = {};
        for (const field in seed) {
          userAgent[field] = encodeURIComponent((_a90 = seed[field]) !== null && _a90 !== void 0 ? _a90 : "null");
        }
        userAgent.uname = encodeURIComponent(uname || "UNKNOWN");
        const client = this.getApiField("httpClient");
        if (client) {
          userAgent.httplib = encodeURIComponent(client.getClientName());
        }
        if (this._appInfo) {
          userAgent.application = this._appInfo;
        }
        cb(JSON.stringify(userAgent));
      });
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getAppInfoAsString() {
      if (!this._appInfo) {
        return "";
      }
      let formatted = this._appInfo.name;
      if (this._appInfo.version) {
        formatted += `/${this._appInfo.version}`;
      }
      if (this._appInfo.url) {
        formatted += ` (${this._appInfo.url})`;
      }
      return formatted;
    },
    getTelemetryEnabled() {
      return this._enableTelemetry;
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _prepResources() {
      for (const name in resources_exports) {
        this[pascalToCamelCase(name)] = new resources_exports[name](this);
      }
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _getPropsFromConfig(config) {
      if (!config) {
        return {};
      }
      const isString = typeof config === "string";
      const isObject2 = config === Object(config) && !Array.isArray(config);
      if (!isObject2 && !isString) {
        throw new Error("Config must either be an object or a string");
      }
      if (isString) {
        return {
          apiVersion: config
        };
      }
      const values = Object.keys(config).filter((value) => !ALLOWED_CONFIG_PROPERTIES.includes(value));
      if (values.length > 0) {
        throw new Error(`Config object may only contain the following: ${ALLOWED_CONFIG_PROPERTIES.join(", ")}`);
      }
      return config;
    }
  };
  return Stripe2;
}

// node_modules/stripe/esm/stripe.esm.worker.js
var Stripe = createStripe(new WebPlatformFunctions());
var stripe_esm_worker_default = Stripe;

// lib/posthog.ts
init_modules_watch_stub();

// ../node_modules/posthog-node/lib/index.esm.js
init_modules_watch_stub();
var import_rusha = __toESM(require_rusha());
var version2 = "4.0.0";
var PostHogPersistedProperty;
(function(PostHogPersistedProperty2) {
  PostHogPersistedProperty2["AnonymousId"] = "anonymous_id";
  PostHogPersistedProperty2["DistinctId"] = "distinct_id";
  PostHogPersistedProperty2["Props"] = "props";
  PostHogPersistedProperty2["FeatureFlags"] = "feature_flags";
  PostHogPersistedProperty2["FeatureFlagPayloads"] = "feature_flag_payloads";
  PostHogPersistedProperty2["OverrideFeatureFlags"] = "override_feature_flags";
  PostHogPersistedProperty2["Queue"] = "queue";
  PostHogPersistedProperty2["OptedOut"] = "opted_out";
  PostHogPersistedProperty2["SessionId"] = "session_id";
  PostHogPersistedProperty2["SessionLastTimestamp"] = "session_timestamp";
  PostHogPersistedProperty2["PersonProperties"] = "person_properties";
  PostHogPersistedProperty2["GroupProperties"] = "group_properties";
  PostHogPersistedProperty2["InstalledAppBuild"] = "installed_app_build";
  PostHogPersistedProperty2["InstalledAppVersion"] = "installed_app_version";
})(PostHogPersistedProperty || (PostHogPersistedProperty = {}));
function assert(truthyValue, message2) {
  if (!truthyValue) {
    throw new Error(message2);
  }
}
function removeTrailingSlash(url) {
  return url?.replace(/\/+$/, "");
}
async function retriable(fn, props) {
  let lastError = null;
  for (let i2 = 0; i2 < props.retryCount + 1; i2++) {
    if (i2 > 0) {
      await new Promise((r2) => setTimeout(r2, props.retryDelay));
    }
    try {
      const res = await fn();
      return res;
    } catch (e3) {
      lastError = e3;
      if (!props.retryCheck(e3)) {
        throw e3;
      }
    }
  }
  throw lastError;
}
function currentTimestamp() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function currentISOTime() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function safeSetTimeout(fn, timeout) {
  const t2 = setTimeout(fn, timeout);
  t2?.unref && t2?.unref();
  return t2;
}
var f2 = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var baseReverseDic = {};
function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
    }
  }
  return baseReverseDic[alphabet][character];
}
var LZString = {
  compressToBase64: function(input) {
    if (input == null) {
      return "";
    }
    const res = LZString._compress(input, 6, function(a2) {
      return keyStrBase64.charAt(a2);
    });
    switch (res.length % 4) {
      default:
      case 0:
        return res;
      case 1:
        return res + "===";
      case 2:
        return res + "==";
      case 3:
        return res + "=";
    }
  },
  decompressFromBase64: function(input) {
    if (input == null) {
      return "";
    }
    if (input == "") {
      return null;
    }
    return LZString._decompress(input.length, 32, function(index2) {
      return getBaseValue(keyStrBase64, input.charAt(index2));
    });
  },
  compress: function(uncompressed) {
    return LZString._compress(uncompressed, 16, function(a2) {
      return f2(a2);
    });
  },
  _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) {
      return "";
    }
    const context_dictionary = {}, context_dictionaryToCreate = {}, context_data = [];
    let i2, value, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data_val = 0, context_data_position = 0, ii;
    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }
      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i2 = 0; i2 < 8; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1 | value;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i2 = 0; i2 < 16; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i2 = 0; i2 < 8; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1 | value;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i2 = 0; i2 < 16; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i2 = 0; i2 < context_numBits; i2++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }
    value = 2;
    for (i2 = 0; i2 < context_numBits; i2++) {
      context_data_val = context_data_val << 1 | value & 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }
    while (true) {
      context_data_val = context_data_val << 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      } else {
        context_data_position++;
      }
    }
    return context_data.join("");
  },
  decompress: function(compressed) {
    if (compressed == null) {
      return "";
    }
    if (compressed == "") {
      return null;
    }
    return LZString._decompress(compressed.length, 32768, function(index2) {
      return compressed.charCodeAt(index2);
    });
  },
  _decompress: function(length, resetValue, getNextValue) {
    const dictionary = [], result = [], data = { val: getNextValue(0), position: resetValue, index: 1 };
    let enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", i2, w3, bits, resb, maxpower, power, c3;
    for (i2 = 0; i2 < 3; i2 += 1) {
      dictionary[i2] = i2;
    }
    bits = 0;
    maxpower = Math.pow(2, 2);
    power = 1;
    while (power != maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb > 0 ? 1 : 0) * power;
      power <<= 1;
    }
    switch (bits) {
      case 0:
        bits = 0;
        maxpower = Math.pow(2, 8);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c3 = f2(bits);
        break;
      case 1:
        bits = 0;
        maxpower = Math.pow(2, 16);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c3 = f2(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c3;
    w3 = c3;
    result.push(c3);
    while (true) {
      if (data.index > length) {
        return "";
      }
      bits = 0;
      maxpower = Math.pow(2, numBits);
      power = 1;
      while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }
      switch (c3 = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f2(bits);
          c3 = dictSize - 1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f2(bits);
          c3 = dictSize - 1;
          enlargeIn--;
          break;
        case 2:
          return result.join("");
      }
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
      if (dictionary[c3]) {
        entry = dictionary[c3];
      } else {
        if (c3 === dictSize) {
          entry = w3 + w3.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);
      dictionary[dictSize++] = w3 + entry.charAt(0);
      enlargeIn--;
      w3 = entry;
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
  }
};
var SimpleEventEmitter = class {
  constructor() {
    this.events = {};
    this.events = {};
  }
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return () => {
      this.events[event] = this.events[event].filter((x2) => x2 !== listener);
    };
  }
  emit(event, payload) {
    for (const listener of this.events[event] || []) {
      listener(payload);
    }
    for (const listener of this.events["*"] || []) {
      listener(event, payload);
    }
  }
};
var DIGITS = "0123456789abcdef";
var UUID = class {
  /** @param bytes - The 16-byte byte array representation. */
  constructor(bytes) {
    this.bytes = bytes;
  }
  /**
   * Creates an object from the internal representation, a 16-byte byte array
   * containing the binary UUID representation in the big-endian byte order.
   *
   * This method does NOT shallow-copy the argument, and thus the created object
   * holds the reference to the underlying buffer.
   *
   * @throws TypeError if the length of the argument is not 16.
   */
  static ofInner(bytes) {
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    } else {
      return new UUID(bytes);
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   * @throws RangeError if any field value is out of the specified range.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / 2 ** 40;
    bytes[1] = unixTsMs / 2 ** 32;
    bytes[2] = unixTsMs / 2 ** 24;
    bytes[3] = unixTsMs / 2 ** 16;
    bytes[4] = unixTsMs / 2 ** 8;
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new UUID(bytes);
  }
  /**
   * Builds a byte array from a string representation.
   *
   * This method accepts the following formats:
   *
   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
   * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
   *
   * Leading and trailing whitespaces represents an error.
   *
   * @throws SyntaxError if the argument could not parse as a valid UUID string.
   */
  static parse(uuid2) {
    let hex = void 0;
    switch (uuid2.length) {
      case 32:
        hex = /^[0-9a-f]{32}$/i.exec(uuid2)?.[0];
        break;
      case 36:
        hex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid2)?.slice(1, 6).join("");
        break;
      case 38:
        hex = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid2)?.slice(1, 6).join("");
        break;
      case 45:
        hex = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid2)?.slice(1, 6).join("");
        break;
    }
    if (hex) {
      const inner = new Uint8Array(16);
      for (let i2 = 0; i2 < 16; i2 += 4) {
        const n2 = parseInt(hex.substring(2 * i2, 2 * i2 + 8), 16);
        inner[i2 + 0] = n2 >>> 24;
        inner[i2 + 1] = n2 >>> 16;
        inner[i2 + 2] = n2 >>> 8;
        inner[i2 + 3] = n2;
      }
      return new UUID(inner);
    } else {
      throw new SyntaxError("could not parse UUID string");
    }
  }
  /**
   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
   */
  toString() {
    let text2 = "";
    for (let i2 = 0; i2 < this.bytes.length; i2++) {
      text2 += DIGITS.charAt(this.bytes[i2] >>> 4);
      text2 += DIGITS.charAt(this.bytes[i2] & 15);
      if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
        text2 += "-";
      }
    }
    return text2;
  }
  /**
   * @returns The 32-digit hexadecimal representation without hyphens
   * (`0189dcd553117d408db09496a2eef37b`).
   */
  toHex() {
    let text2 = "";
    for (let i2 = 0; i2 < this.bytes.length; i2++) {
      text2 += DIGITS.charAt(this.bytes[i2] >>> 4);
      text2 += DIGITS.charAt(this.bytes[i2] & 15);
    }
    return text2;
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toJSON() {
    return this.toString();
  }
  /**
   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
   * "MAX".
   *
   * For convenience, this method reports "NIL" or "MAX" if `this` represents
   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
   * subsumed under the variants `0b0` and `0b111`, respectively.
   */
  getVariant() {
    const n2 = this.bytes[8] >>> 4;
    if (n2 < 0) {
      throw new Error("unreachable");
    } else if (n2 <= 7) {
      return this.bytes.every((e3) => e3 === 0) ? "NIL" : "VAR_0";
    } else if (n2 <= 11) {
      return "VAR_10";
    } else if (n2 <= 13) {
      return "VAR_110";
    } else if (n2 <= 15) {
      return this.bytes.every((e3) => e3 === 255) ? "MAX" : "VAR_RESERVED";
    } else {
      throw new Error("unreachable");
    }
  }
  /**
   * Returns the version field value of the UUID or `undefined` if the UUID does
   * not have the variant field value of `0b10`.
   */
  getVersion() {
    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
  }
  /** Creates an object from `this`. */
  clone() {
    return new UUID(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i2 = 0; i2 < 16; i2++) {
      const diff = this.bytes[i2] - other.bytes[i2];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
};
var V7Generator = class {
  /**
   * Creates a generator object with the default random number generator, or
   * with the specified one if passed as an argument. The specified random
   * number generator should be cryptographically strong and securely seeded.
   */
  constructor(randomNumberGenerator) {
    this.timestamp = 0;
    this.counter = 0;
    this.random = randomNumberGenerator ?? getDefaultRandom();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method resets the
   * generator and returns a new UUID based on the given timestamp, breaking the
   * increasing order of UUIDs.
   *
   * See {@link generateOrAbort} for the other mode of generation and
   * {@link generateOrResetCore} for the low-level primitive.
   */
  generate() {
    return this.generateOrResetCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method aborts and
   * returns `undefined` immediately.
   *
   * See {@link generate} for the other mode of generation and
   * {@link generateOrAbortCore} for the low-level primitive.
   */
  generateOrAbort() {
    return this.generateOrAbortCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generate} except that it takes a custom
   * timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrResetCore(unixTsMs, rollbackAllowance) {
    let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    if (value === void 0) {
      this.timestamp = 0;
      value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    }
    return value;
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generateOrAbort} except that it takes a
   * custom timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrAbortCore(unixTsMs, rollbackAllowance) {
    const MAX_COUNTER = 4398046511103;
    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
      throw new RangeError("`rollbackAllowance` out of reasonable range");
    }
    if (unixTsMs > this.timestamp) {
      this.timestamp = unixTsMs;
      this.resetCounter();
    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & 2 ** 30 - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
  /**
   * Generates a new UUIDv4 object utilizing the random number generator inside.
   *
   * @internal
   */
  generateV4() {
    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
    bytes[6] = 64 | bytes[6] >>> 4;
    bytes[8] = 128 | bytes[8] >>> 2;
    return UUID.ofInner(bytes);
  }
};
var getDefaultRandom = () => {
  return {
    nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
  };
};
var defaultGenerator;
var uuidv7 = () => uuidv7obj().toString();
var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
var PostHogFetchHttpError = class extends Error {
  constructor(response) {
    super("HTTP error while fetching PostHog: " + response.status);
    this.response = response;
    this.name = "PostHogFetchHttpError";
  }
};
var PostHogFetchNetworkError = class extends Error {
  constructor(error) {
    super("Network error while fetching PostHog", error instanceof Error ? { cause: error } : {});
    this.error = error;
    this.name = "PostHogFetchNetworkError";
  }
};
function isPostHogFetchError(err) {
  return typeof err === "object" && (err instanceof PostHogFetchHttpError || err instanceof PostHogFetchNetworkError);
}
var PostHogCoreStateless = class {
  constructor(apiKey, options) {
    this.flushPromise = null;
    this.disableGeoip = true;
    this.disabled = false;
    this.defaultOptIn = true;
    this.pendingPromises = {};
    this._events = new SimpleEventEmitter();
    this._isInitialized = false;
    assert(apiKey, "You must pass your PostHog project's api key.");
    this.apiKey = apiKey;
    this.host = removeTrailingSlash(options?.host || "https://app.posthog.com");
    this.flushAt = options?.flushAt ? Math.max(options?.flushAt, 1) : 20;
    this.maxBatchSize = Math.max(this.flushAt, options?.maxBatchSize ?? 100);
    this.maxQueueSize = Math.max(this.flushAt, options?.maxQueueSize ?? 1e3);
    this.flushInterval = options?.flushInterval ?? 1e4;
    this.captureMode = options?.captureMode || "form";
    this.defaultOptIn = options?.defaultOptIn ?? true;
    this._retryOptions = {
      retryCount: options?.fetchRetryCount ?? 3,
      retryDelay: options?.fetchRetryDelay ?? 3e3,
      retryCheck: isPostHogFetchError
    };
    this.requestTimeout = options?.requestTimeout ?? 1e4;
    this.featureFlagsRequestTimeoutMs = options?.featureFlagsRequestTimeoutMs ?? 3e3;
    this.disableGeoip = options?.disableGeoip ?? true;
    this.disabled = options?.disabled ?? false;
    this._initPromise = Promise.resolve();
    this._isInitialized = true;
  }
  wrap(fn) {
    if (this.disabled) {
      if (this.isDebug) {
        console.warn("[PostHog] The client is disabled");
      }
      return;
    }
    if (this._isInitialized) {
      return fn();
    }
    this._initPromise.then(() => fn());
  }
  getCommonEventProperties() {
    return {
      $lib: this.getLibraryId(),
      $lib_version: this.getLibraryVersion()
    };
  }
  get optedOut() {
    return this.getPersistedProperty(PostHogPersistedProperty.OptedOut) ?? !this.defaultOptIn;
  }
  async optIn() {
    this.wrap(() => {
      this.setPersistedProperty(PostHogPersistedProperty.OptedOut, false);
    });
  }
  async optOut() {
    this.wrap(() => {
      this.setPersistedProperty(PostHogPersistedProperty.OptedOut, true);
    });
  }
  on(event, cb) {
    return this._events.on(event, cb);
  }
  debug(enabled = true) {
    this.removeDebugCallback?.();
    if (enabled) {
      const removeDebugCallback = this.on("*", (event, payload) => console.log("PostHog Debug", event, payload));
      this.removeDebugCallback = () => {
        removeDebugCallback();
        this.removeDebugCallback = void 0;
      };
    }
  }
  get isDebug() {
    return !!this.removeDebugCallback;
  }
  buildPayload(payload) {
    return {
      distinct_id: payload.distinct_id,
      event: payload.event,
      properties: {
        ...payload.properties || {},
        ...this.getCommonEventProperties()
        // Common PH props
      }
    };
  }
  addPendingPromise(promise) {
    const promiseUUID = uuidv7();
    this.pendingPromises[promiseUUID] = promise;
    promise.catch(() => {
    }).finally(() => {
      delete this.pendingPromises[promiseUUID];
    });
    return promise;
  }
  /***
   *** TRACKING
   ***/
  identifyStateless(distinctId, properties, options) {
    this.wrap(() => {
      const payload = {
        ...this.buildPayload({
          distinct_id: distinctId,
          event: "$identify",
          properties
        })
      };
      this.enqueue("identify", payload, options);
    });
  }
  captureStateless(distinctId, event, properties, options) {
    this.wrap(() => {
      const payload = this.buildPayload({ distinct_id: distinctId, event, properties });
      this.enqueue("capture", payload, options);
    });
  }
  aliasStateless(alias, distinctId, properties, options) {
    this.wrap(() => {
      const payload = this.buildPayload({
        event: "$create_alias",
        distinct_id: distinctId,
        properties: {
          ...properties || {},
          distinct_id: distinctId,
          alias
        }
      });
      this.enqueue("alias", payload, options);
    });
  }
  /***
   *** GROUPS
   ***/
  groupIdentifyStateless(groupType, groupKey, groupProperties, options, distinctId, eventProperties) {
    this.wrap(() => {
      const payload = this.buildPayload({
        distinct_id: distinctId || `$${groupType}_${groupKey}`,
        event: "$groupidentify",
        properties: {
          $group_type: groupType,
          $group_key: groupKey,
          $group_set: groupProperties || {},
          ...eventProperties || {}
        }
      });
      this.enqueue("capture", payload, options);
    });
  }
  /***
   *** FEATURE FLAGS
   ***/
  async getDecide(distinctId, groups = {}, personProperties = {}, groupProperties = {}, extraPayload = {}) {
    await this._initPromise;
    const url = `${this.host}/decide/?v=3`;
    const fetchOptions = {
      method: "POST",
      headers: { ...this.getCustomHeaders(), "Content-Type": "application/json" },
      body: JSON.stringify({
        token: this.apiKey,
        distinct_id: distinctId,
        groups,
        person_properties: personProperties,
        group_properties: groupProperties,
        ...extraPayload
      })
    };
    return this.fetchWithRetry(url, fetchOptions, { retryCount: 0 }, this.featureFlagsRequestTimeoutMs).then((response) => response.json()).catch((error) => {
      this._events.emit("error", error);
      return void 0;
    });
  }
  async getFeatureFlagStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {
    await this._initPromise;
    const featureFlags = await this.getFeatureFlagsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip);
    if (!featureFlags) {
      return void 0;
    }
    let response = featureFlags[key];
    if (response === void 0) {
      response = false;
    }
    return response;
  }
  async getFeatureFlagPayloadStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {
    await this._initPromise;
    const payloads = await this.getFeatureFlagPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip);
    if (!payloads) {
      return void 0;
    }
    const response = payloads[key];
    if (response === void 0) {
      return null;
    }
    return this._parsePayload(response);
  }
  async getFeatureFlagPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {
    await this._initPromise;
    const payloads = (await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)).payloads;
    if (payloads) {
      return Object.fromEntries(Object.entries(payloads).map(([k2, v3]) => [k2, this._parsePayload(v3)]));
    }
    return payloads;
  }
  _parsePayload(response) {
    try {
      return JSON.parse(response);
    } catch {
      return response;
    }
  }
  async getFeatureFlagsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {
    await this._initPromise;
    return (await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)).flags;
  }
  async getFeatureFlagsAndPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {
    await this._initPromise;
    const extraPayload = {};
    if (disableGeoip ?? this.disableGeoip) {
      extraPayload["geoip_disable"] = true;
    }
    const decideResponse = await this.getDecide(distinctId, groups, personProperties, groupProperties, extraPayload);
    const flags = decideResponse?.featureFlags;
    const payloads = decideResponse?.featureFlagPayloads;
    return {
      flags,
      payloads
    };
  }
  /***
   *** QUEUEING AND FLUSHING
   ***/
  enqueue(type, _message, options) {
    this.wrap(() => {
      if (this.optedOut) {
        this._events.emit(type, `Library is disabled. Not sending event. To re-enable, call posthog.optIn()`);
        return;
      }
      const message2 = {
        ..._message,
        type,
        library: this.getLibraryId(),
        library_version: this.getLibraryVersion(),
        timestamp: options?.timestamp ? options?.timestamp : currentISOTime(),
        uuid: options?.uuid ? options.uuid : uuidv7()
      };
      const addGeoipDisableProperty = options?.disableGeoip ?? this.disableGeoip;
      if (addGeoipDisableProperty) {
        if (!message2.properties) {
          message2.properties = {};
        }
        message2["properties"]["$geoip_disable"] = true;
      }
      if (message2.distinctId) {
        message2.distinct_id = message2.distinctId;
        delete message2.distinctId;
      }
      const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
      if (queue.length >= this.maxQueueSize) {
        queue.shift();
        console.info("Queue is full, the oldest event is dropped.");
      }
      queue.push({ message: message2 });
      this.setPersistedProperty(PostHogPersistedProperty.Queue, queue);
      this._events.emit(type, message2);
      if (queue.length >= this.flushAt) {
        this.flushBackground();
      }
      if (this.flushInterval && !this._flushTimer) {
        this._flushTimer = safeSetTimeout(() => this.flushBackground(), this.flushInterval);
      }
    });
  }
  clearFlushTimer() {
    if (this._flushTimer) {
      clearTimeout(this._flushTimer);
      this._flushTimer = void 0;
    }
  }
  /**
   * Helper for flushing the queue in the background
   * Avoids unnecessary promise errors
   */
  flushBackground() {
    void this.flush().catch(() => {
    });
  }
  async flush() {
    if (!this.flushPromise) {
      this.flushPromise = this._flush().finally(() => {
        this.flushPromise = null;
      });
      this.addPendingPromise(this.flushPromise);
    }
    return this.flushPromise;
  }
  getCustomHeaders() {
    const customUserAgent = this.getCustomUserAgent();
    const headers = {};
    if (customUserAgent && customUserAgent !== "") {
      headers["User-Agent"] = customUserAgent;
    }
    return headers;
  }
  async _flush() {
    this.clearFlushTimer();
    await this._initPromise;
    const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
    if (!queue.length) {
      return [];
    }
    const items = queue.slice(0, this.maxBatchSize);
    const messages = items.map((item) => item.message);
    const persistQueueChange = () => {
      const refreshedQueue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
      this.setPersistedProperty(PostHogPersistedProperty.Queue, refreshedQueue.slice(items.length));
    };
    const data = {
      api_key: this.apiKey,
      batch: messages,
      sent_at: currentISOTime()
    };
    const payload = JSON.stringify(data);
    const url = this.captureMode === "form" ? `${this.host}/e/?ip=1&_=${currentTimestamp()}&v=${this.getLibraryVersion()}` : `${this.host}/batch/`;
    const fetchOptions = this.captureMode === "form" ? {
      method: "POST",
      mode: "no-cors",
      credentials: "omit",
      headers: { ...this.getCustomHeaders(), "Content-Type": "application/x-www-form-urlencoded" },
      body: `data=${encodeURIComponent(LZString.compressToBase64(payload))}&compression=lz64`
    } : {
      method: "POST",
      headers: { ...this.getCustomHeaders(), "Content-Type": "application/json" },
      body: payload
    };
    try {
      await this.fetchWithRetry(url, fetchOptions);
    } catch (err) {
      if (!(err instanceof PostHogFetchNetworkError)) {
        persistQueueChange();
      }
      this._events.emit("error", err);
      throw err;
    }
    persistQueueChange();
    this._events.emit("flush", messages);
    return messages;
  }
  async fetchWithRetry(url, options, retryOptions, requestTimeout) {
    var _a90;
    (_a90 = AbortSignal).timeout ?? (_a90.timeout = function timeout(ms) {
      const ctrl = new AbortController();
      setTimeout(() => ctrl.abort(), ms);
      return ctrl.signal;
    });
    return await retriable(async () => {
      let res = null;
      try {
        res = await this.fetch(url, {
          signal: AbortSignal.timeout(requestTimeout ?? this.requestTimeout),
          ...options
        });
      } catch (e3) {
        throw new PostHogFetchNetworkError(e3);
      }
      const isNoCors = options.mode === "no-cors";
      if (!isNoCors && (res.status < 200 || res.status >= 400)) {
        throw new PostHogFetchHttpError(res);
      }
      return res;
    }, { ...this._retryOptions, ...retryOptions });
  }
  async shutdown(shutdownTimeoutMs = 3e4) {
    await this._initPromise;
    this.clearFlushTimer();
    try {
      await Promise.all(Object.values(this.pendingPromises));
      const startTimeWithDelay = Date.now() + shutdownTimeoutMs;
      while (true) {
        const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
        if (queue.length === 0) {
          break;
        }
        await this.flush();
        const now = Date.now();
        if (startTimeWithDelay < now) {
          break;
        }
      }
    } catch (e3) {
      if (!isPostHogFetchError(e3)) {
        throw e3;
      }
      console.error("Error while shutting down PostHog", e3);
    }
  }
};
var PostHogMemoryStorage = class {
  constructor() {
    this._memoryStorage = {};
  }
  getProperty(key) {
    return this._memoryStorage[key];
  }
  setProperty(key, value) {
    this._memoryStorage[key] = value !== null ? value : void 0;
  }
};
var _fetch = (
  // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error
  // @ts-ignore
  typeof fetch !== "undefined" ? fetch : typeof global.fetch !== "undefined" ? global.fetch : void 0
);
if (!_fetch) {
  const axios = require_axios();
  _fetch = async (url, options) => {
    const res = await axios.request({
      url,
      headers: options.headers,
      method: options.method.toLowerCase(),
      data: options.body,
      signal: options.signal,
      // fetch only throws on network errors, not on HTTP errors
      validateStatus: () => true
    });
    return {
      status: res.status,
      text: async () => res.data,
      json: async () => res.data
    };
  };
}
var fetch$1 = _fetch;
var LONG_SCALE = 1152921504606847e3;
var ClientError = class extends Error {
  constructor(message2) {
    super();
    Error.captureStackTrace(this, this.constructor);
    this.name = "ClientError";
    this.message = message2;
    Object.setPrototypeOf(this, ClientError.prototype);
  }
};
var InconclusiveMatchError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
    Object.setPrototypeOf(this, InconclusiveMatchError.prototype);
  }
};
var FeatureFlagsPoller = class {
  constructor({
    pollingInterval,
    personalApiKey,
    projectApiKey,
    timeout,
    host,
    customHeaders,
    ...options
  }) {
    this.debugMode = false;
    this.pollingInterval = pollingInterval;
    this.personalApiKey = personalApiKey;
    this.featureFlags = [];
    this.featureFlagsByKey = {};
    this.groupTypeMapping = {};
    this.cohorts = {};
    this.loadedSuccessfullyOnce = false;
    this.timeout = timeout;
    this.projectApiKey = projectApiKey;
    this.host = host;
    this.poller = void 0;
    this.fetch = options.fetch || fetch$1;
    this.onError = options.onError;
    this.customHeaders = customHeaders;
    void this.loadFeatureFlags();
  }
  debug(enabled = true) {
    this.debugMode = enabled;
  }
  async getFeatureFlag(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}) {
    await this.loadFeatureFlags();
    let response = void 0;
    let featureFlag = void 0;
    if (!this.loadedSuccessfullyOnce) {
      return response;
    }
    for (const flag of this.featureFlags) {
      if (key === flag.key) {
        featureFlag = flag;
        break;
      }
    }
    if (featureFlag !== void 0) {
      try {
        response = this.computeFlagLocally(featureFlag, distinctId, groups, personProperties, groupProperties);
        if (this.debugMode) {
          console.debug(`Successfully computed flag locally: ${key} -> ${response}`);
        }
      } catch (e3) {
        if (e3 instanceof InconclusiveMatchError) {
          if (this.debugMode) {
            console.debug(`InconclusiveMatchError when computing flag locally: ${key}: ${e3}`);
          }
        } else if (e3 instanceof Error) {
          this.onError?.(new Error(`Error computing flag locally: ${key}: ${e3}`));
        }
      }
    }
    return response;
  }
  async computeFeatureFlagPayloadLocally(key, matchValue) {
    await this.loadFeatureFlags();
    let response = void 0;
    if (!this.loadedSuccessfullyOnce) {
      return void 0;
    }
    if (typeof matchValue == "boolean") {
      response = this.featureFlagsByKey?.[key]?.filters?.payloads?.[matchValue.toString()];
    } else if (typeof matchValue == "string") {
      response = this.featureFlagsByKey?.[key]?.filters?.payloads?.[matchValue];
    }
    if (response === void 0) {
      return null;
    }
    return response;
  }
  async getAllFlagsAndPayloads(distinctId, groups = {}, personProperties = {}, groupProperties = {}) {
    await this.loadFeatureFlags();
    const response = {};
    const payloads = {};
    let fallbackToDecide = this.featureFlags.length == 0;
    this.featureFlags.map(async (flag) => {
      try {
        const matchValue = this.computeFlagLocally(flag, distinctId, groups, personProperties, groupProperties);
        response[flag.key] = matchValue;
        const matchPayload = await this.computeFeatureFlagPayloadLocally(flag.key, matchValue);
        if (matchPayload) {
          payloads[flag.key] = matchPayload;
        }
      } catch (e3) {
        if (e3 instanceof InconclusiveMatchError)
          ;
        else if (e3 instanceof Error) {
          this.onError?.(new Error(`Error computing flag locally: ${flag.key}: ${e3}`));
        }
        fallbackToDecide = true;
      }
    });
    return {
      response,
      payloads,
      fallbackToDecide
    };
  }
  computeFlagLocally(flag, distinctId, groups = {}, personProperties = {}, groupProperties = {}) {
    if (flag.ensure_experience_continuity) {
      throw new InconclusiveMatchError("Flag has experience continuity enabled");
    }
    if (!flag.active) {
      return false;
    }
    const flagFilters = flag.filters || {};
    const aggregation_group_type_index = flagFilters.aggregation_group_type_index;
    if (aggregation_group_type_index != void 0) {
      const groupName = this.groupTypeMapping[String(aggregation_group_type_index)];
      if (!groupName) {
        if (this.debugMode) {
          console.warn(`[FEATURE FLAGS] Unknown group type index ${aggregation_group_type_index} for feature flag ${flag.key}`);
        }
        throw new InconclusiveMatchError("Flag has unknown group type index");
      }
      if (!(groupName in groups)) {
        if (this.debugMode) {
          console.warn(`[FEATURE FLAGS] Can't compute group feature flag: ${flag.key} without group names passed in`);
        }
        return false;
      }
      const focusedGroupProperties = groupProperties[groupName];
      return this.matchFeatureFlagProperties(flag, groups[groupName], focusedGroupProperties);
    } else {
      return this.matchFeatureFlagProperties(flag, distinctId, personProperties);
    }
  }
  matchFeatureFlagProperties(flag, distinctId, properties) {
    const flagFilters = flag.filters || {};
    const flagConditions = flagFilters.groups || [];
    let isInconclusive = false;
    let result = void 0;
    const sortedFlagConditions = [...flagConditions].sort((conditionA, conditionB) => {
      const AHasVariantOverride = !!conditionA.variant;
      const BHasVariantOverride = !!conditionB.variant;
      if (AHasVariantOverride && BHasVariantOverride) {
        return 0;
      } else if (AHasVariantOverride) {
        return -1;
      } else if (BHasVariantOverride) {
        return 1;
      } else {
        return 0;
      }
    });
    for (const condition of sortedFlagConditions) {
      try {
        if (this.isConditionMatch(flag, distinctId, condition, properties)) {
          const variantOverride = condition.variant;
          const flagVariants = flagFilters.multivariate?.variants || [];
          if (variantOverride && flagVariants.some((variant) => variant.key === variantOverride)) {
            result = variantOverride;
          } else {
            result = this.getMatchingVariant(flag, distinctId) || true;
          }
          break;
        }
      } catch (e3) {
        if (e3 instanceof InconclusiveMatchError) {
          isInconclusive = true;
        } else {
          throw e3;
        }
      }
    }
    if (result !== void 0) {
      return result;
    } else if (isInconclusive) {
      throw new InconclusiveMatchError("Can't determine if feature flag is enabled or not with given properties");
    }
    return false;
  }
  isConditionMatch(flag, distinctId, condition, properties) {
    const rolloutPercentage = condition.rollout_percentage;
    if ((condition.properties || []).length > 0) {
      for (const prop of condition.properties) {
        const propertyType = prop.type;
        let matches = false;
        if (propertyType === "cohort") {
          matches = matchCohort(prop, properties, this.cohorts);
        } else {
          matches = matchProperty(prop, properties);
        }
        if (!matches) {
          return false;
        }
      }
      if (rolloutPercentage == void 0) {
        return true;
      }
    }
    if (rolloutPercentage != void 0 && _hash(flag.key, distinctId) > rolloutPercentage / 100) {
      return false;
    }
    return true;
  }
  getMatchingVariant(flag, distinctId) {
    const hashValue = _hash(flag.key, distinctId, "variant");
    const matchingVariant = this.variantLookupTable(flag).find((variant) => {
      return hashValue >= variant.valueMin && hashValue < variant.valueMax;
    });
    if (matchingVariant) {
      return matchingVariant.key;
    }
    return void 0;
  }
  variantLookupTable(flag) {
    const lookupTable = [];
    let valueMin = 0;
    let valueMax = 0;
    const flagFilters = flag.filters || {};
    const multivariates = flagFilters.multivariate?.variants || [];
    multivariates.forEach((variant) => {
      valueMax = valueMin + variant.rollout_percentage / 100;
      lookupTable.push({
        valueMin,
        valueMax,
        key: variant.key
      });
      valueMin = valueMax;
    });
    return lookupTable;
  }
  async loadFeatureFlags(forceReload = false) {
    if (!this.loadedSuccessfullyOnce || forceReload) {
      await this._loadFeatureFlags();
    }
  }
  async _loadFeatureFlags() {
    if (this.poller) {
      clearTimeout(this.poller);
      this.poller = void 0;
    }
    this.poller = setTimeout(() => this._loadFeatureFlags(), this.pollingInterval);
    try {
      const res = await this._requestFeatureFlagDefinitions();
      if (res && res.status === 401) {
        throw new ClientError(`Your personalApiKey is invalid. Are you sure you're not using your Project API key? More information: https://posthog.com/docs/api/overview`);
      }
      if (res && res.status !== 200) {
        return;
      }
      const responseJson = await res.json();
      if (!("flags" in responseJson)) {
        this.onError?.(new Error(`Invalid response when getting feature flags: ${JSON.stringify(responseJson)}`));
      }
      this.featureFlags = responseJson.flags || [];
      this.featureFlagsByKey = this.featureFlags.reduce((acc, curr) => (acc[curr.key] = curr, acc), {});
      this.groupTypeMapping = responseJson.group_type_mapping || {};
      this.cohorts = responseJson.cohorts || [];
      this.loadedSuccessfullyOnce = true;
    } catch (err) {
      if (err instanceof ClientError) {
        this.onError?.(err);
      }
    }
  }
  async _requestFeatureFlagDefinitions() {
    const url = `${this.host}/api/feature_flag/local_evaluation?token=${this.projectApiKey}&send_cohorts`;
    const options = {
      method: "GET",
      headers: {
        ...this.customHeaders,
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.personalApiKey}`
      }
    };
    let abortTimeout = null;
    if (this.timeout && typeof this.timeout === "number") {
      const controller = new AbortController();
      abortTimeout = safeSetTimeout(() => {
        controller.abort();
      }, this.timeout);
      options.signal = controller.signal;
    }
    try {
      return await this.fetch(url, options);
    } finally {
      clearTimeout(abortTimeout);
    }
  }
  stopPoller() {
    clearTimeout(this.poller);
  }
};
function _hash(key, distinctId, salt = "") {
  const sha1Hash = (0, import_rusha.createHash)();
  sha1Hash.update(`${key}.${distinctId}${salt}`);
  return parseInt(sha1Hash.digest("hex").slice(0, 15), 16) / LONG_SCALE;
}
function matchProperty(property, propertyValues) {
  const key = property.key;
  const value = property.value;
  const operator = property.operator || "exact";
  if (!(key in propertyValues)) {
    throw new InconclusiveMatchError(`Property ${key} not found in propertyValues`);
  } else if (operator === "is_not_set") {
    throw new InconclusiveMatchError(`Operator is_not_set is not supported`);
  }
  const overrideValue = propertyValues[key];
  function computeExactMatch(value2, overrideValue2) {
    if (Array.isArray(value2)) {
      return value2.map((val) => String(val).toLowerCase()).includes(String(overrideValue2).toLowerCase());
    }
    return String(value2).toLowerCase() === String(overrideValue2).toLowerCase();
  }
  function compare(lhs, rhs, operator2) {
    if (operator2 === "gt") {
      return lhs > rhs;
    } else if (operator2 === "gte") {
      return lhs >= rhs;
    } else if (operator2 === "lt") {
      return lhs < rhs;
    } else if (operator2 === "lte") {
      return lhs <= rhs;
    } else {
      throw new Error(`Invalid operator: ${operator2}`);
    }
  }
  switch (operator) {
    case "exact":
      return computeExactMatch(value, overrideValue);
    case "is_not":
      return !computeExactMatch(value, overrideValue);
    case "is_set":
      return key in propertyValues;
    case "icontains":
      return String(overrideValue).toLowerCase().includes(String(value).toLowerCase());
    case "not_icontains":
      return !String(overrideValue).toLowerCase().includes(String(value).toLowerCase());
    case "regex":
      return isValidRegex(String(value)) && String(overrideValue).match(String(value)) !== null;
    case "not_regex":
      return isValidRegex(String(value)) && String(overrideValue).match(String(value)) === null;
    case "gt":
    case "gte":
    case "lt":
    case "lte": {
      let parsedValue = typeof value === "number" ? value : null;
      if (typeof value === "string") {
        try {
          parsedValue = parseFloat(value);
        } catch (err) {
        }
      }
      if (parsedValue != null && overrideValue != null) {
        if (typeof overrideValue === "string") {
          return compare(overrideValue, String(value), operator);
        } else {
          return compare(overrideValue, parsedValue, operator);
        }
      } else {
        return compare(String(overrideValue), String(value), operator);
      }
    }
    case "is_date_after":
    case "is_date_before": {
      let parsedDate = relativeDateParseForFeatureFlagMatching(String(value));
      if (parsedDate == null) {
        parsedDate = convertToDateTime(value);
      }
      if (parsedDate == null) {
        throw new InconclusiveMatchError(`Invalid date: ${value}`);
      }
      const overrideDate = convertToDateTime(overrideValue);
      if (["is_date_before"].includes(operator)) {
        return overrideDate < parsedDate;
      }
      return overrideDate > parsedDate;
    }
    default:
      throw new InconclusiveMatchError(`Unknown operator: ${operator}`);
  }
}
function matchCohort(property, propertyValues, cohortProperties) {
  const cohortId = String(property.value);
  if (!(cohortId in cohortProperties)) {
    throw new InconclusiveMatchError("can't match cohort without a given cohort property value");
  }
  const propertyGroup = cohortProperties[cohortId];
  return matchPropertyGroup(propertyGroup, propertyValues, cohortProperties);
}
function matchPropertyGroup(propertyGroup, propertyValues, cohortProperties) {
  if (!propertyGroup) {
    return true;
  }
  const propertyGroupType = propertyGroup.type;
  const properties = propertyGroup.values;
  if (!properties || properties.length === 0) {
    return true;
  }
  let errorMatchingLocally = false;
  if ("values" in properties[0]) {
    for (const prop of properties) {
      try {
        const matches = matchPropertyGroup(prop, propertyValues, cohortProperties);
        if (propertyGroupType === "AND") {
          if (!matches) {
            return false;
          }
        } else {
          if (matches) {
            return true;
          }
        }
      } catch (err) {
        if (err instanceof InconclusiveMatchError) {
          console.debug(`Failed to compute property ${prop} locally: ${err}`);
          errorMatchingLocally = true;
        } else {
          throw err;
        }
      }
    }
    if (errorMatchingLocally) {
      throw new InconclusiveMatchError("Can't match cohort without a given cohort property value");
    }
    return propertyGroupType === "AND";
  } else {
    for (const prop of properties) {
      try {
        let matches;
        if (prop.type === "cohort") {
          matches = matchCohort(prop, propertyValues, cohortProperties);
        } else {
          matches = matchProperty(prop, propertyValues);
        }
        const negation = prop.negation || false;
        if (propertyGroupType === "AND") {
          if (!matches && !negation) {
            return false;
          }
          if (matches && negation) {
            return false;
          }
        } else {
          if (matches && !negation) {
            return true;
          }
          if (!matches && negation) {
            return true;
          }
        }
      } catch (err) {
        if (err instanceof InconclusiveMatchError) {
          console.debug(`Failed to compute property ${prop} locally: ${err}`);
          errorMatchingLocally = true;
        } else {
          throw err;
        }
      }
    }
    if (errorMatchingLocally) {
      throw new InconclusiveMatchError("can't match cohort without a given cohort property value");
    }
    return propertyGroupType === "AND";
  }
}
function isValidRegex(regex) {
  try {
    new RegExp(regex);
    return true;
  } catch (err) {
    return false;
  }
}
function convertToDateTime(value) {
  if (value instanceof Date) {
    return value;
  } else if (typeof value === "string" || typeof value === "number") {
    const date = new Date(value);
    if (!isNaN(date.valueOf())) {
      return date;
    }
    throw new InconclusiveMatchError(`${value} is in an invalid date format`);
  } else {
    throw new InconclusiveMatchError(`The date provided ${value} must be a string, number, or date object`);
  }
}
function relativeDateParseForFeatureFlagMatching(value) {
  const regex = /^-?(?<number>[0-9]+)(?<interval>[a-z])$/;
  const match = value.match(regex);
  const parsedDt = new Date((/* @__PURE__ */ new Date()).toISOString());
  if (match) {
    if (!match.groups) {
      return null;
    }
    const number = parseInt(match.groups["number"]);
    if (number >= 1e4) {
      return null;
    }
    const interval = match.groups["interval"];
    if (interval == "h") {
      parsedDt.setUTCHours(parsedDt.getUTCHours() - number);
    } else if (interval == "d") {
      parsedDt.setUTCDate(parsedDt.getUTCDate() - number);
    } else if (interval == "w") {
      parsedDt.setUTCDate(parsedDt.getUTCDate() - number * 7);
    } else if (interval == "m") {
      parsedDt.setUTCMonth(parsedDt.getUTCMonth() - number);
    } else if (interval == "y") {
      parsedDt.setUTCFullYear(parsedDt.getUTCFullYear() - number);
    } else {
      return null;
    }
    return parsedDt;
  } else {
    return null;
  }
}
var THIRTY_SECONDS = 30 * 1e3;
var MAX_CACHE_SIZE = 50 * 1e3;
var PostHog = class extends PostHogCoreStateless {
  constructor(apiKey, options = {}) {
    options.captureMode = options?.captureMode || "json";
    super(apiKey, options);
    this._memoryStorage = new PostHogMemoryStorage();
    this.options = options;
    if (options.personalApiKey) {
      this.featureFlagsPoller = new FeatureFlagsPoller({
        pollingInterval: typeof options.featureFlagsPollingInterval === "number" ? options.featureFlagsPollingInterval : THIRTY_SECONDS,
        personalApiKey: options.personalApiKey,
        projectApiKey: apiKey,
        timeout: options.requestTimeout ?? 1e4,
        host: this.host,
        fetch: options.fetch,
        onError: (err) => {
          this._events.emit("error", err);
        },
        customHeaders: this.getCustomHeaders()
      });
    }
    this.distinctIdHasSentFlagCalls = {};
    this.maxCacheSize = options.maxCacheSize || MAX_CACHE_SIZE;
  }
  getPersistedProperty(key) {
    return this._memoryStorage.getProperty(key);
  }
  setPersistedProperty(key, value) {
    return this._memoryStorage.setProperty(key, value);
  }
  fetch(url, options) {
    return this.options.fetch ? this.options.fetch(url, options) : fetch$1(url, options);
  }
  getLibraryId() {
    return "posthog-node";
  }
  getLibraryVersion() {
    return version2;
  }
  getCustomUserAgent() {
    return `${this.getLibraryId()}/${this.getLibraryVersion()}`;
  }
  enable() {
    return super.optIn();
  }
  disable() {
    return super.optOut();
  }
  debug(enabled = true) {
    super.debug(enabled);
    this.featureFlagsPoller?.debug(enabled);
  }
  capture({
    distinctId,
    event,
    properties,
    groups,
    sendFeatureFlags,
    timestamp: timestamp3,
    disableGeoip,
    uuid: uuid2
  }) {
    const _capture = (props) => {
      super.captureStateless(distinctId, event, props, {
        timestamp: timestamp3,
        disableGeoip,
        uuid: uuid2
      });
    };
    const _getFlags = (distinctId2, groups2, disableGeoip2) => {
      return super.getFeatureFlagsStateless(distinctId2, groups2, void 0, void 0, disableGeoip2);
    };
    const capturePromise = Promise.resolve().then(async () => {
      if (sendFeatureFlags) {
        return await _getFlags(distinctId, groups, disableGeoip);
      }
      if ((this.featureFlagsPoller?.featureFlags?.length || 0) > 0) {
        const groupsWithStringValues = {};
        for (const [key, value] of Object.entries(groups || {})) {
          groupsWithStringValues[key] = String(value);
        }
        return await this.getAllFlags(distinctId, {
          groups: groupsWithStringValues,
          disableGeoip,
          onlyEvaluateLocally: true
        });
      }
      return {};
    }).then((flags) => {
      const additionalProperties = {};
      if (flags) {
        for (const [feature, variant] of Object.entries(flags)) {
          additionalProperties[`$feature/${feature}`] = variant;
        }
      }
      const activeFlags = Object.keys(flags || {}).filter((flag) => flags?.[flag] !== false);
      if (activeFlags.length > 0) {
        additionalProperties["$active_feature_flags"] = activeFlags;
      }
      return additionalProperties;
    }).catch(() => {
      return {};
    }).then((additionalProperties) => {
      _capture({
        ...additionalProperties,
        ...properties,
        $groups: groups
      });
    });
    this.addPendingPromise(capturePromise);
  }
  identify({
    distinctId,
    properties,
    disableGeoip
  }) {
    const personProperties = properties?.$set || properties;
    super.identifyStateless(distinctId, {
      $set: personProperties
    }, {
      disableGeoip
    });
  }
  alias(data) {
    super.aliasStateless(data.alias, data.distinctId, void 0, {
      disableGeoip: data.disableGeoip
    });
  }
  async getFeatureFlag(key, distinctId, options) {
    const {
      groups,
      disableGeoip
    } = options || {};
    let {
      onlyEvaluateLocally,
      sendFeatureFlagEvents,
      personProperties,
      groupProperties
    } = options || {};
    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);
    personProperties = adjustedProperties.allPersonProperties;
    groupProperties = adjustedProperties.allGroupProperties;
    if (onlyEvaluateLocally == void 0) {
      onlyEvaluateLocally = false;
    }
    if (sendFeatureFlagEvents == void 0) {
      sendFeatureFlagEvents = true;
    }
    let response = await this.featureFlagsPoller?.getFeatureFlag(key, distinctId, groups, personProperties, groupProperties);
    const flagWasLocallyEvaluated = response !== void 0;
    if (!flagWasLocallyEvaluated && !onlyEvaluateLocally) {
      response = await super.getFeatureFlagStateless(key, distinctId, groups, personProperties, groupProperties, disableGeoip);
    }
    const featureFlagReportedKey = `${key}_${response}`;
    if (sendFeatureFlagEvents && (!(distinctId in this.distinctIdHasSentFlagCalls) || !this.distinctIdHasSentFlagCalls[distinctId].includes(featureFlagReportedKey))) {
      if (Object.keys(this.distinctIdHasSentFlagCalls).length >= this.maxCacheSize) {
        this.distinctIdHasSentFlagCalls = {};
      }
      if (Array.isArray(this.distinctIdHasSentFlagCalls[distinctId])) {
        this.distinctIdHasSentFlagCalls[distinctId].push(featureFlagReportedKey);
      } else {
        this.distinctIdHasSentFlagCalls[distinctId] = [featureFlagReportedKey];
      }
      this.capture({
        distinctId,
        event: "$feature_flag_called",
        properties: {
          $feature_flag: key,
          $feature_flag_response: response,
          locally_evaluated: flagWasLocallyEvaluated,
          [`$feature/${key}`]: response
        },
        groups,
        disableGeoip
      });
    }
    return response;
  }
  async getFeatureFlagPayload(key, distinctId, matchValue, options) {
    const {
      groups,
      disableGeoip
    } = options || {};
    let {
      onlyEvaluateLocally,
      sendFeatureFlagEvents,
      personProperties,
      groupProperties
    } = options || {};
    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);
    personProperties = adjustedProperties.allPersonProperties;
    groupProperties = adjustedProperties.allGroupProperties;
    let response = void 0;
    if (!matchValue) {
      matchValue = await this.getFeatureFlag(key, distinctId, {
        ...options,
        onlyEvaluateLocally: true
      });
    }
    if (matchValue) {
      response = await this.featureFlagsPoller?.computeFeatureFlagPayloadLocally(key, matchValue);
    }
    if (onlyEvaluateLocally == void 0) {
      onlyEvaluateLocally = false;
    }
    if (sendFeatureFlagEvents == void 0) {
      sendFeatureFlagEvents = true;
    }
    if (onlyEvaluateLocally == void 0) {
      onlyEvaluateLocally = false;
    }
    const payloadWasLocallyEvaluated = response !== void 0;
    if (!payloadWasLocallyEvaluated && !onlyEvaluateLocally) {
      response = await super.getFeatureFlagPayloadStateless(key, distinctId, groups, personProperties, groupProperties, disableGeoip);
    }
    try {
      return JSON.parse(response);
    } catch {
      return response;
    }
  }
  async isFeatureEnabled(key, distinctId, options) {
    const feat = await this.getFeatureFlag(key, distinctId, options);
    if (feat === void 0) {
      return void 0;
    }
    return !!feat || false;
  }
  async getAllFlags(distinctId, options) {
    const response = await this.getAllFlagsAndPayloads(distinctId, options);
    return response.featureFlags;
  }
  async getAllFlagsAndPayloads(distinctId, options) {
    const {
      groups,
      disableGeoip
    } = options || {};
    let {
      onlyEvaluateLocally,
      personProperties,
      groupProperties
    } = options || {};
    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);
    personProperties = adjustedProperties.allPersonProperties;
    groupProperties = adjustedProperties.allGroupProperties;
    if (onlyEvaluateLocally == void 0) {
      onlyEvaluateLocally = false;
    }
    const localEvaluationResult = await this.featureFlagsPoller?.getAllFlagsAndPayloads(distinctId, groups, personProperties, groupProperties);
    let featureFlags = {};
    let featureFlagPayloads = {};
    let fallbackToDecide = true;
    if (localEvaluationResult) {
      featureFlags = localEvaluationResult.response;
      featureFlagPayloads = localEvaluationResult.payloads;
      fallbackToDecide = localEvaluationResult.fallbackToDecide;
    }
    if (fallbackToDecide && !onlyEvaluateLocally) {
      const remoteEvaluationResult = await super.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip);
      featureFlags = {
        ...featureFlags,
        ...remoteEvaluationResult.flags || {}
      };
      featureFlagPayloads = {
        ...featureFlagPayloads,
        ...remoteEvaluationResult.payloads || {}
      };
    }
    return {
      featureFlags,
      featureFlagPayloads
    };
  }
  groupIdentify({
    groupType,
    groupKey,
    properties,
    distinctId,
    disableGeoip
  }) {
    super.groupIdentifyStateless(groupType, groupKey, properties, {
      disableGeoip
    }, distinctId);
  }
  async reloadFeatureFlags() {
    await this.featureFlagsPoller?.loadFeatureFlags(true);
  }
  async shutdown(shutdownTimeoutMs) {
    this.featureFlagsPoller?.stopPoller();
    return super.shutdown(shutdownTimeoutMs);
  }
  addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties) {
    const allPersonProperties = {
      distinct_id: distinctId,
      ...personProperties || {}
    };
    const allGroupProperties = {};
    if (groups) {
      for (const groupName of Object.keys(groups)) {
        allGroupProperties[groupName] = {
          $group_key: groups[groupName],
          ...groupProperties?.[groupName] || {}
        };
      }
    }
    return {
      allPersonProperties,
      allGroupProperties
    };
  }
};
var PostHogSentryIntegration = class {
  constructor(posthog, posthogHost, organization, prefix) {
    this.posthog = posthog;
    this.posthogHost = posthogHost;
    this.organization = organization;
    this.prefix = prefix;
    this.name = "posthog-node";
    this.posthogHost = posthog.options.host ?? "https://app.posthog.com";
  }
  setupOnce(addGlobalEventProcessor, getCurrentHub) {
    addGlobalEventProcessor((event) => {
      if (event.exception?.values === void 0 || event.exception.values.length === 0) {
        return event;
      }
      if (!event.tags) {
        event.tags = {};
      }
      const sentry = getCurrentHub();
      const userId = event.tags[PostHogSentryIntegration.POSTHOG_ID_TAG];
      if (userId === void 0) {
        return event;
      }
      event.tags["PostHog Person URL"] = new URL(`/person/${userId}`, this.posthogHost).toString();
      const properties = {
        // PostHog Exception Properties
        $exception_message: event.exception.values[0]?.value,
        $exception_type: event.exception.values[0]?.type,
        $exception_personURL: event.tags["PostHog Person URL"],
        // Sentry Exception Properties
        $sentry_event_id: event.event_id,
        $sentry_exception: event.exception,
        $sentry_exception_message: event.exception.values[0]?.value,
        $sentry_exception_type: event.exception.values[0]?.type,
        $sentry_tags: event.tags
      };
      const projectId = sentry.getClient()?.getDsn()?.projectId;
      if (this.organization !== void 0 && projectId !== void 0 && event.event_id !== void 0) {
        properties.$sentry_url = `${this.prefix ?? "https://sentry.io/organizations"}/${this.organization}/issues/?project=${projectId}&query=${event.event_id}`;
      }
      this.posthog.capture({
        event: "$exception",
        distinctId: userId,
        properties
      });
      return event;
    });
  }
};
PostHogSentryIntegration.POSTHOG_ID_TAG = "posthog_distinct_id";

// lib/posthog.ts
function initializePosthog(env) {
  const client = new PostHog(env.POSTHOG_ANALYTICS_KEY, {
    host: "https://app.posthog.com",
    flushAt: 1,
    flushInterval: 0
  });
  return client;
}

// lib/logging.ts
init_modules_watch_stub();
function safeLog(level, ...params) {
  const validLevels = ["log", "warn", "error"];
  let chosenLevel = validLevels.includes(level) ? level : "error";
  const output = params.map((param) => {
    if (param instanceof Error) {
      return `Error: ${param.message}, Stack: ${param.stack}`;
    } else if (typeof param === "object") {
      try {
        return JSON.stringify(param, null, 2);
      } catch (error) {
        chosenLevel = "error";
        return `Failed to stringify object: ${error.message}`;
      }
    }
    return param;
  });
  console[chosenLevel](...output);
}

// lib/utils.ts
async function singleEventAnalyticsLogger(userId, event, connectionAppId, channelId, timestamp3, uuid2, properties, env, posthog) {
  let client = posthog;
  if (!client) {
    client = initializePosthog(env);
  }
  if (!userId) {
    userId = "static_string_for_group_events";
  }
  let dateTimestamp = null;
  if (typeof timestamp3 === "number" || typeof timestamp3 === "string") {
    dateTimestamp = convertTimestampToDate(timestamp3);
  }
  client.capture({
    timestamp: dateTimestamp,
    uuid: uuid2,
    distinctId: userId,
    event,
    groups: { company: connectionAppId, channel: channelId },
    properties
  });
  await client.shutdown();
}
function convertTimestampToDate(timestamp3) {
  const parsedTimestamp = typeof timestamp3 === "string" ? parseFloat(timestamp3) : timestamp3;
  const timestampInMilliseconds = parsedTimestamp * 1e3;
  return new Date(timestampInMilliseconds);
}
async function verifySlackRequest(request, env) {
  const signingSecret = env.SLACK_SIGNING_SECRET;
  const timestamp3 = request.headers.get("x-slack-request-timestamp");
  const slackSignature = request.headers.get("x-slack-signature");
  const body = await request.text();
  const basestring = `v0:${timestamp3}:${body}`;
  const encoder = new TextEncoder();
  const keyData = encoder.encode(signingSecret);
  const data = encoder.encode(basestring);
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signatureBuffer = await crypto.subtle.sign("HMAC", cryptoKey, data);
  const mySignature = Array.from(new Uint8Array(signatureBuffer)).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  const computedSignature = `v0=${mySignature}`;
  return timingSafeEqual(computedSignature, slackSignature || "");
}
function timingSafeEqual(a2, b3) {
  if (a2.length !== b3.length) {
    return false;
  }
  let mismatch = 0;
  for (let i2 = 0; i2 < a2.length; i2++) {
    mismatch |= a2.charCodeAt(i2) ^ b3.charCodeAt(i2);
  }
  return mismatch === 0;
}
async function fetchZendeskCredentials(slackConnectionId, db, env, key) {
  try {
    const zendeskCredentials = await db.query.zendeskConnection.findFirst({
      where: eq(zendeskConnection.slackConnectionId, slackConnectionId)
    });
    const zendeskDomain = zendeskCredentials?.zendeskDomain;
    const zendeskEmail = zendeskCredentials?.zendeskEmail;
    const encryptedZendeskApiKey = zendeskCredentials?.encryptedZendeskApiKey;
    if (!zendeskDomain || !zendeskEmail || !encryptedZendeskApiKey) {
      safeLog(
        "log",
        `No Zendesk credentials found for slack connection ${slackConnectionId}`
      );
      return null;
    }
    let encryptionKey2 = key;
    if (!encryptionKey2) {
      encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
    }
    const decryptedApiKey = await decryptData(
      encryptedZendeskApiKey,
      encryptionKey2
    );
    return {
      ...zendeskCredentials,
      zendeskApiKey: decryptedApiKey
    };
  } catch (error) {
    safeLog("error", `Error querying ZendeskConnections: ${error}`);
    return void 0;
  }
}
async function findSlackConnectionByAppId(appId, db, env, key) {
  if (!appId) {
    safeLog("error", "No api_app_id found");
    return void 0;
  }
  try {
    const connection = await db.query.slackConnection.findFirst({
      where: eq(slackConnection.appId, appId),
      with: {
        subscription: true
      }
    });
    if (connection) {
      let encryptionKey2 = key;
      if (!encryptionKey2) {
        encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
      }
      const decryptedToken = await decryptData(
        connection.encryptedToken,
        encryptionKey2
      );
      return { ...connection, token: decryptedToken };
    }
    return null;
  } catch (error) {
    safeLog("error", error);
    return void 0;
  }
}
async function getSlackConnection(connectionId, db, env, key) {
  try {
    const connection = await db.query.slackConnection.findFirst({
      where: eq(slackConnection.id, connectionId),
      with: {
        subscription: true
      }
    });
    if (connection) {
      let encryptionKey2 = key;
      if (!encryptionKey2) {
        encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
      }
      const decryptedToken = await decryptData(
        connection.encryptedToken,
        encryptionKey2
      );
      return { ...connection, token: decryptedToken };
    }
    return null;
  } catch (error) {
    safeLog("error", `Error finding SlackConnection: ${error}`);
    return void 0;
  }
}
function isSubscriptionActive(connection, env) {
  if (!connection.subscription?.periodEnd) {
    safeLog("error", `periodEnd is missing for connection ${connection.id}`);
    return true;
  }
  const periodEnd = connection.subscription.periodEnd;
  const bufferMilliseconds = env.SUBSCRIPTION_EXPIRATION_BUFFER_HOURS * 60 * 60 * 1e3;
  const expirationDateWithBuffer = new Date(
    periodEnd.getTime() + bufferMilliseconds
  );
  return expirationDateWithBuffer >= /* @__PURE__ */ new Date();
}
async function getChannelInfo(channelId, slackConnectionId, db) {
  try {
    const channelInfo = await db.query.channel.findFirst({
      where: and(
        eq(channel.slackConnectionId, slackConnectionId),
        eq(channel.slackChannelIdentifier, channelId)
      )
    });
    return channelInfo;
  } catch (error) {
    safeLog("error", `Error getting channel info for ${channelId}`, error);
    return void 0;
  }
}
function isChannelEligibleForMessaging(channel2) {
  return channel2.isMember && channel2.status !== "PENDING_UPGRADE";
}
async function updateChannelActivity(slackConnection2, channelId, db) {
  const now = /* @__PURE__ */ new Date();
  await db.update(channel).set({
    updatedAt: now,
    latestActivityAt: now
  }).where(
    and(
      eq(channel.slackConnectionId, slackConnection2.id),
      eq(channel.slackChannelIdentifier, channelId)
    )
  );
}
async function createStripeAccount(name, email, env, idempotencyKey) {
  try {
    const stripe = new stripe_esm_worker_default(env.STRIPE_API_KEY);
    const customer = await stripe.customers.create(
      {
        name,
        ...email ? { email } : {}
      },
      { idempotencyKey: `customer-${idempotencyKey}` }
    );
    const subscription2 = await stripe.subscriptions.create(
      {
        customer: customer.id,
        items: [{ price: "price_1OjpyEDlJlwKmwDWreiHLSAY" }]
        // Default free plan
      },
      { idempotencyKey: `subscription-${idempotencyKey}` }
    );
    if (!customer || !subscription2) {
      safeLog(
        "error",
        `Empty objects creating Stripe account ${name}, ${email}`
      );
      return void 0;
    }
    return {
      customerId: customer.id,
      subscriptionId: subscription2.id,
      currentPeriodEnd: subscription2.current_period_end,
      currentPeriodStart: subscription2.current_period_start
    };
  } catch (error) {
    safeLog("error", "Error creating Stripe account:", error);
    return void 0;
  }
}

// src/endpoints/zendeskEvents.ts
var import_bcryptjs = __toESM(require_bcrypt());
var ZendeskEventHandler = class extends K {
  async handle(request, env, context, data) {
    const db = initializeDb(env);
    const requestBody = await request.json();
    safeLog("log", "Zendesk event received:", requestBody);
    if (typeof requestBody.current_user_external_id === "string" && requestBody.current_user_external_id.startsWith("zensync")) {
      safeLog("log", "Message from Zensync, skipping");
      return new Response("Ok", { status: 200 });
    }
    const ticketLastUpdatedAt = requestBody.last_updated_at;
    if (!ticketLastUpdatedAt) {
      safeLog("error", "Missing last_updated_at");
      return new Response("Missing last_updated_at", { status: 400 });
    }
    const slackConnectionId = await authenticateRequest(request, db);
    if (!slackConnectionId) {
      safeLog("warn", "Unauthorized");
      return new Response("Unauthorized", { status: 401 });
    }
    const conversationInfo = await db.query.conversation.findFirst({
      where: eq(conversation.id, requestBody.external_id),
      with: {
        channel: true
      }
    });
    if (!conversationInfo?.slackParentMessageId) {
      safeLog(
        "error",
        `No conversation found for id ${requestBody.external_id}`
      );
      return new Response("No conversation found", { status: 404 });
    }
    if (!conversationInfo.channel || !conversationInfo.channel.slackChannelIdentifier || conversationInfo.channel.slackConnectionId !== slackConnectionId) {
      safeLog(
        "error",
        `Invalid Ids: ${slackConnectionId} !== ${conversationInfo}`
      );
      return new Response("Invalid Ids", { status: 401 });
    }
    const slackConnectionInfo = await getSlackConnection(
      slackConnectionId,
      db,
      env
    );
    if (!slackConnectionInfo) {
      safeLog("error", `No Slack connection found for id ${slackConnectionId}`);
      return new Response("No Slack connection found", { status: 404 });
    }
    if (!isSubscriptionActive(slackConnectionInfo, env)) {
      safeLog("log", "Subscription is not active, ignoring");
      return new Response("Ok", { status: 200 });
    }
    try {
      await sendSlackMessage(
        requestBody,
        slackConnectionInfo,
        conversationInfo.slackParentMessageId,
        conversationInfo.channel.slackChannelIdentifier,
        env
      );
    } catch (error) {
      safeLog("error", error);
      return new Response("Error", { status: 500 });
    }
    return new Response("Ok", { status: 202 });
  }
};
async function getSlackUserByEmail(connection, email) {
  try {
    const response = await fetch(
      `https://slack.com/api/users.lookupByEmail?email=${email}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${connection.token}`
        }
      }
    );
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error getting Slack user: ${responseData.error}`);
    }
    const userId = responseData.user.id;
    const username = responseData.user.profile?.display_name || responseData.user.profile?.real_name || void 0;
    const imageUrl = responseData.user.profile.image_192;
    return { userId, username, imageUrl };
  } catch (error) {
    safeLog("error", `Error in getSlackUserByEmail:`, error);
    throw error;
  }
}
async function authenticateRequest(request, db) {
  try {
    const authorizationHeader = request.headers.get("authorization");
    const webhookId = request.headers.get("x-zendesk-webhook-id");
    const bearerToken = authorizationHeader?.replace("Bearer ", "");
    if (!bearerToken) {
      safeLog("error", "Missing bearer token");
      return null;
    }
    const url = new URL(request.url);
    if (!webhookId) {
      safeLog("error", "Missing webhook id");
      return null;
    }
    const connection = await db.query.zendeskConnection.findFirst({
      where: eq(zendeskConnection.zendeskWebhookId, webhookId)
    });
    if (!connection) {
      safeLog("error", `Invalid webhook Id ${webhookId}`);
      return null;
    }
    const hashedToken = connection.hashedWebhookBearerToken;
    const isValid2 = await import_bcryptjs.default.compare(bearerToken, hashedToken);
    if (!isValid2) {
      safeLog("error", "Invalid bearer token");
      return null;
    }
    return connection.slackConnectionId;
  } catch (error) {
    safeLog("error", "Error in authenticateRequest:", error);
    return null;
  }
}
async function sendSlackMessage(requestBody, connection, parentMessageId, slackChannelId, env) {
  let username;
  let imageUrl;
  let slackUser;
  try {
    if (requestBody.current_user_email) {
      slackUser = await getSlackUserByEmail(
        connection,
        requestBody.current_user_email
      );
      username = slackUser.username || requestBody.current_user_name;
      imageUrl = slackUser.imageUrl;
    }
  } catch (error) {
    safeLog("warn", `Error getting Slack user: ${error}`);
  }
  try {
    const message2 = requestBody.message;
    const signature = requestBody.current_user_signature;
    const body = JSON.stringify({
      channel: slackChannelId,
      text: stripSignatureFromMessage(message2, signature),
      thread_ts: parentMessageId,
      username,
      icon_url: imageUrl
    });
    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${connection.token}`
      },
      body
    });
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error posting message: ${responseData.error}`);
    }
  } catch (error) {
    safeLog("error", `Error in sendSlackMessage:`, error);
    throw error;
  }
  await singleEventAnalyticsLogger(
    slackUser.userId,
    "message_reply",
    connection.appId,
    slackChannelId,
    null,
    null,
    {
      source: "zendesk"
    },
    env,
    null
  );
}
function stripSignatureFromMessage(message2, signature) {
  if (!message2) {
    return "";
  }
  if (!signature || !message2.endsWith(signature)) {
    return message2;
  }
  return message2.slice(0, message2.length - signature.length);
}

// src/endpoints/slackInteractivity.ts
init_modules_watch_stub();
var import_bcryptjs2 = __toESM(require_bcrypt());

// views/homeTab.ts
init_modules_watch_stub();
var PENDING_UPGRADE = "PENDING_UPGRADE";
async function handleAppHomeOpened(slackUserId, connection, db, env, key) {
  try {
    const [zendeskInfo, channelInfos] = await fetchHomeTabData(
      connection,
      db,
      env,
      key
    );
    const viewJson = {
      type: "home",
      blocks: [
        {
          type: "header",
          text: {
            type: "plain_text",
            text: "Welcome to Zensync :wave:",
            emoji: true
          }
        },
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: "Check out our <https://slacktozendesk.com/docs|documentation> for setup guides and answers to common questions."
          }
        },
        ...buildSupportLinks(connection),
        {
          type: "divider"
        },
        ...buildUpgradeCTA(channelInfos, connection, env),
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: "Manage your connection with Zendesk through the button below."
          }
        },
        {
          type: "actions",
          elements: [
            {
              type: "button",
              text: {
                type: "plain_text",
                text: zendeskInfo?.status !== "ACTIVE" ? "Connect to Zendesk" : "Edit Zendesk Connection",
                emoji: true
              },
              action_id: "configure-zendesk" /* CONFIGURE_ZENDESK_BUTTON_TAPPED */,
              ...zendeskInfo?.status !== "ACTIVE" && { style: "primary" }
            }
          ]
        },
        {
          type: "divider"
        },
        {
          type: "header",
          text: {
            type: "plain_text",
            text: `Connected channels (${channelInfos.length})`,
            emoji: true
          }
        },
        {
          type: "context",
          elements: [
            {
              type: "mrkdwn",
              text: "Use command `/invite @zensync` in any channel to connect it with Zendesk."
            }
          ]
        },
        {
          type: "divider"
        },
        ...createChannelSections(channelInfos),
        {
          type: "divider"
        },
        {
          type: "actions",
          elements: [
            {
              type: "button",
              text: {
                type: "plain_text",
                text: "Account Details",
                emoji: true
              },
              action_id: "open-account-settings" /* OPEN_ACCOUNT_SETTINGS_BUTTON_TAPPED */
            }
          ]
        }
      ]
    };
    const body = JSON.stringify({
      user_id: slackUserId,
      view: viewJson
    });
    const response = await fetch("https://slack.com/api/views.publish", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${connection.token}`
      },
      body
    });
    const responseData = await response.json();
    if (!responseData.ok) {
      safeLog("error", `Error publishing Slack View: ${body}`);
      const errorDetails = JSON.stringify(responseData, null, 2);
      throw new Error(`Error publishig view: ${errorDetails}`);
    }
  } catch (error) {
    safeLog("error", `Error in handleAppHomeOpened: ${error.message}`);
    throw error;
  }
}
async function fetchHomeTabData(slackConnection2, db, env, key) {
  try {
    const zendeskInfo = await fetchZendeskCredentials(
      slackConnection2.id,
      db,
      env,
      key
    );
    const channelInfos = await db.query.channel.findMany({
      where: and(
        eq(channel.slackConnectionId, slackConnection2.id),
        eq(channel.isMember, true)
      ),
      orderBy: [desc(channel.name)],
      limit: 1e3
      // This is artificaially set just to not blow up the home tab
    });
    return [zendeskInfo, channelInfos];
  } catch (error) {
    safeLog(
      "error",
      `Error fetching home tab data from database: ${error.message}`
    );
    throw error;
  }
}
function containsPendingChannels(channelInfos) {
  return channelInfos.some((channel2) => channel2.status === PENDING_UPGRADE);
}
function createChannelSections(channelInfos) {
  if (channelInfos.length === 0) {
    return [];
  }
  return channelInfos.flatMap((info) => {
    const activityDate = info.latestActivityAt ?? info.createdAt;
    const latestActivityTimestamp = Math.floor(activityDate.getTime() / 1e3);
    const fallbackText = activityDate.toLocaleDateString();
    const slackFormattedDate = `<!date^${latestActivityTimestamp}^{date_short} at {time}|${fallbackText}>`;
    const tags = info.tags || [];
    const tagsString = tags.length > 0 ? tags.map((tag) => `\`${tag}\``).join(", ") : "";
    const accessory = {
      type: "button",
      text: {
        type: "plain_text",
        emoji: true,
        text: info.status === PENDING_UPGRADE ? ":warning: Upgrade" : "Edit"
      },
      action_id: info.status === PENDING_UPGRADE ? "open-account-settings" /* OPEN_ACCOUNT_SETTINGS_BUTTON_TAPPED */ : `${"edit-channel" /* EDIT_CHANNEL_BUTTON_TAPPED */}:${info.slackChannelIdentifier}`,
      ...info.status === PENDING_UPGRADE && { style: "danger" }
    };
    const section = {
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*<#${info.slackChannelIdentifier}|${info.name}>*
*Zendesk assignee:* ${info.defaultAssigneeEmail ?? ""}
*Zendesk tags:* ${tagsString}`
      },
      accessory
    };
    const contextText = info.status === PENDING_UPGRADE ? "Channel deactivated, upgrade plan to receive messages!" : `Last message on ${slackFormattedDate}`;
    const contextBlock = {
      type: "context",
      elements: [
        {
          type: "mrkdwn",
          text: contextText
        }
      ]
    };
    const dividerBlock = { type: "divider" };
    return [section, contextBlock, dividerBlock];
  });
}
function buildSupportLinks(connection) {
  if (!connection.supportSlackChannelId || !connection.supportSlackChannelName) {
    return [
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*Set up your shared slack channel*`
        }
      },
      {
        type: "context",
        elements: [
          {
            type: "mrkdwn",
            text: "Reach out to support@slacktozendesk.com to request a free shared slack channel for help and integration support directly from the Zensync team."
          }
        ]
      }
    ];
  }
  return [
    {
      type: "rich_text",
      elements: [
        {
          type: "rich_text_section",
          elements: [
            {
              type: "text",
              text: "Need support? Open your shared slack channel: ",
              style: {
                bold: true
              }
            },
            {
              type: "channel",
              channel_id: connection.supportSlackChannelId,
              style: {
                bold: true
              }
            }
          ]
        }
      ]
    },
    {
      type: "context",
      elements: [
        {
          type: "mrkdwn",
          text: "Depending on your Slack permissions, you may need an invite to join.\nIf you can't use Slack, need an invite, or prefer email, reach out to support@slacktozendesk.com."
        }
      ]
    }
  ];
}
function buildUpgradeCTA(channelInfos, connection, env) {
  const subscriptionActive = isSubscriptionActive(connection, env);
  const hasPendingChannels = containsPendingChannels(channelInfos);
  if (subscriptionActive && !hasPendingChannels) {
    return [];
  }
  return [
    {
      type: "section",
      text: {
        type: "plain_text",
        text: subscriptionActive ? ":warning: You've exceeded your plan limit :warning:" : ":warning: You're subscription has expired :warning:",
        emoji: true
      }
    },
    {
      type: "actions",
      elements: [
        {
          type: "button",
          text: {
            type: "plain_text",
            text: "Upgrade Plan",
            emoji: true
          },
          action_id: "open-account-settings" /* OPEN_ACCOUNT_SETTINGS_BUTTON_TAPPED */,
          style: "danger"
        }
      ]
    },
    {
      type: "divider"
    }
  ];
}

// interfaces/products.interface.ts
init_modules_watch_stub();
var productSeats = {
  prod_PYxuYByQ6U1tCK: 1,
  // Free
  prod_PYxvepWcZa2v7K: 3,
  // Starter
  prod_PYxwITwNzYqxaJ: 5e3,
  // Unlimited - seats are arbitrary, can be raised but unlikely to be hit
  prod_Pgqqt8hNokEwKb: 5001
  // Enterprise - seats are arbitrary, can be raised but unlikely to be hit
};
function getChannelsByProductId(productId) {
  return productSeats[productId] || 0;
}
function getBillingPortalConfiguration(connectedChannels) {
  if (connectedChannels <= 1) {
    return null;
  } else if (connectedChannels >= 2 && connectedChannels <= 3) {
    return "bpc_1OrS3gDlJlwKmwDW0t9z87NQ";
  } else if (connectedChannels > 3) {
    return "bpc_1OrSVIDlJlwKmwDWWunkSSxd";
  }
  return null;
}

// src/endpoints/slackInteractivity.ts
var SlackInteractivityHandler = class extends K {
  async handle(request, env, context, data) {
    const db = initializeDb(env);
    const encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
    const textClone = request.clone();
    if (!await verifySlackRequest(textClone, env)) {
      safeLog("warn", "Slack verification failed!");
      return new Response("Verification failed", { status: 200 });
    }
    const requestBody = await request.formData();
    const payloadString = requestBody.get("payload");
    if (typeof payloadString !== "string") {
      return new Response("Invalid payload", { status: 400 });
    }
    const payload = JSON.parse(payloadString);
    safeLog("log", "Payload recieved:", payload);
    const slackConnectionDetails = await findSlackConnectionByAppId(
      payload.api_app_id,
      db,
      env,
      encryptionKey2
    );
    if (!slackConnectionDetails) {
      safeLog(
        "error",
        `No organization found for team ID: ${payload.api_app_id}.`
      );
      return new Response("Invalid api_app_id", { status: 404 });
    }
    const actionId = getFirstActionId(payload);
    const posthog = initializePosthog(env);
    const analyticsDistinctId = payload.user?.id;
    const analyticsCompanyId = slackConnectionDetails.appId;
    if (actionId?.startsWith("edit-channel" /* EDIT_CHANNEL_BUTTON_TAPPED */)) {
      try {
        await openChannelConfigurationModal(
          actionId,
          payload,
          slackConnectionDetails,
          db
        );
      } catch (error) {
        return returnGenericError(error);
      }
    } else if (actionId === "configure-zendesk" /* CONFIGURE_ZENDESK_BUTTON_TAPPED */) {
      try {
        await openZendeskConfigurationModal(
          payload,
          slackConnectionDetails,
          db,
          env,
          encryptionKey2
        );
      } catch (error) {
        return returnGenericError(error);
      }
    } else if (payload.type === "view_submission" && payload.view?.callback_id.startsWith(
      "edit-channel-configuration-modal" /* EDIT_CHANNEL_CONFIGURATION_MODAL_ID */
    )) {
      try {
        const response = await updateChannelConfiguration(
          payload,
          slackConnectionDetails,
          db,
          encryptionKey2,
          env
        );
        if (response instanceof Response) {
          return response;
        }
      } catch (error) {
        return returnGenericError(error);
      }
    } else if (payload.type === "view_submission" && payload.view?.callback_id === "zendesk-configuration-modal" /* ZENDESK_CONFIGURATION_MODAL_ID */) {
      try {
        await saveZendeskCredentials(
          payload,
          slackConnectionDetails,
          env,
          db,
          encryptionKey2
        );
        posthog.capture({
          distinctId: analyticsDistinctId,
          event: "zendesk_connection_saved",
          groups: { company: analyticsCompanyId }
        });
        await posthog.shutdown();
      } catch (error) {
        return returnGenericError(error);
      }
    } else if (actionId === "open-account-settings" /* OPEN_ACCOUNT_SETTINGS_BUTTON_TAPPED */) {
      try {
        await openAccountSettings(payload, slackConnectionDetails, env, db);
        posthog.capture({
          distinctId: analyticsDistinctId,
          event: "account_details_viewed",
          groups: { company: analyticsCompanyId }
        });
        await posthog.shutdown();
      } catch (error) {
        return returnGenericError(error);
      }
    } else if (payload.type === "view_closed") {
      const userId = payload.user?.id;
      if (userId) {
        await handleAppHomeOpened(
          userId,
          slackConnectionDetails,
          db,
          env,
          encryptionKey2
        );
      }
    }
    return new Response(null, { status: 200 });
  }
};
function returnGenericError(error) {
  safeLog("error", `Error: ${error.message}`);
  return new Response("There was an issue", { status: 500 });
}
function extractZendeskDomain(input) {
  const urlPattern = /^(?:https?:\/\/)?([^\.]+)\.zendesk\.com$/;
  const match = input.match(urlPattern);
  if (match) {
    return match[1];
  } else {
    return input;
  }
}
function getFirstActionId(payload) {
  if (payload && payload.actions && Array.isArray(payload.actions)) {
    if (payload.actions.length > 0 && payload.actions[0].action_id) {
      return payload.actions[0].action_id;
    }
  }
  return null;
}
async function saveZendeskCredentials(payload, connection, env, db, key) {
  const values = payload.view?.state.values;
  const rawZendeskDomain = values?.zendesk_domain["zendesk-domain-input"]?.value;
  const rawZendeskAdminEmail = values?.zendesk_admin_email["zendesk-email-input"]?.value;
  const rawZendeskApiKey = values?.zendesk_api_key["zendesk-api-key-input"]?.value;
  const zendeskDomain = extractZendeskDomain(
    rawZendeskDomain?.replace(/\s/g, "").toLowerCase()
  );
  const zendeskEmail = rawZendeskAdminEmail?.replace(/\s/g, "").toLowerCase();
  const zendeskKey = rawZendeskApiKey?.replace(/\s/g, "");
  const zendeskAuthToken = btoa(`${zendeskEmail}/token:${zendeskKey}`);
  let webhookToken = crypto.randomUUID();
  let zendeskTriggerId;
  let zendeskWebhookId;
  try {
    const webhookPayload = JSON.stringify({
      webhook: {
        endpoint: `${env.ROOT_URL}/v1/zendesk/events`,
        http_method: "POST",
        name: "Slack-to-Zendesk Sync",
        request_format: "json",
        status: "active",
        subscriptions: ["conditional_ticket_events"],
        authentication: {
          type: "bearer_token",
          data: {
            token: webhookToken
          },
          add_position: "header"
        }
      }
    });
    const zendeskWebhookResponse = await fetch(
      `https://${zendeskDomain}.zendesk.com/api/v2/webhooks`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${zendeskAuthToken}`
        },
        body: webhookPayload
      }
    );
    if (!zendeskWebhookResponse.ok) {
      safeLog(
        "error",
        `Zendesk Webhook API failed with status: ${zendeskWebhookResponse.status}`
      );
      safeLog("error", `Response: ${await zendeskWebhookResponse.text()}`);
      throw new Error("Failed to set Zendesk webhook");
    }
    const webhookResponseJson = await zendeskWebhookResponse.json();
    zendeskWebhookId = webhookResponseJson.webhook.id;
    if (!zendeskWebhookId) {
      throw new Error("Failed to find webhook id");
    }
    const triggerPayload = JSON.stringify({
      trigger: {
        title: "Zensync - Slack-to-Zendesk Sync [DO NOT EDIT]",
        description: "Two-way sync between Slack and Zendesk. Contact your admin or email support@slacktozendesk.com for help.",
        active: true,
        conditions: {
          all: [
            {
              field: "status",
              operator: "less_than",
              value: "closed"
            },
            {
              field: "role",
              operator: "is",
              value: "agent"
            },
            {
              field: "current_tags",
              operator: "includes",
              value: "zensync"
            },
            {
              field: "current_via_id",
              operator: "is_not",
              value: "5"
            },
            {
              field: "comment_is_public",
              operator: "is",
              value: "true"
            }
          ]
        },
        actions: [
          {
            field: "notification_webhook",
            value: [
              zendeskWebhookId,
              '{\n  "ticket_id": "{{ticket.id}}",\n  "external_id": "{{ticket.external_id}}",\n  "last_updated_at": "{{ticket.updated_at_with_timestamp}}",\n  "created_at": "{{ticket.created_at_with_timestamp}}",\n  "requester_email": "{{ticket.requester.email}}",\n  "requester_external_id": "{{ticket.requester.external_id}}",\n  "current_user_email": "{{current_user.email}}",\n  "current_user_name": "{{current_user.name}}",\n  "current_user_external_id": "{{current_user.external_id}}",\n  "current_user_signature": "{{current_user.signature}}",\n "message": "{{ticket.latest_public_comment}}",\n  "is_public": "{{ticket.latest_public_comment.is_public}}",\n  "attachments": [\n    {% for attachment in ticket.latest_public_comment.attachments %}\n    {\n      "filename": "{{attachment.filename}}",\n      "url": "{{attachment.url}}"\n    }{% if forloop.last == false %},{% endif %}\n    {% endfor %}\n  ],\n  "via": "{{ticket.via}}"\n}\n'
            ]
          }
        ]
      }
    });
    const zendeskTriggerResponse = await fetch(
      `https://${zendeskDomain}.zendesk.com/api/v2/triggers`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${zendeskAuthToken}`
        },
        body: triggerPayload
      }
    );
    if (!zendeskTriggerResponse.ok) {
      safeLog(
        "error",
        `Zendesk Trigger API failed with status: ${zendeskTriggerResponse.status}`
      );
      safeLog("error", `Response: ${await zendeskTriggerResponse.text()}`);
      throw new Error("Failed to set Zendesk trigger");
    }
    const triggerResponseJson = await zendeskTriggerResponse.json();
    zendeskTriggerId = triggerResponseJson.trigger.id ?? null;
  } catch (error) {
    safeLog("error", error);
    throw error;
  }
  try {
    const encryptedApiKey = await encryptData(zendeskKey, key);
    const salt = await import_bcryptjs2.default.genSalt(10);
    const hashedWebhookToken = await import_bcryptjs2.default.hash(webhookToken, salt);
    await db.insert(zendeskConnection).values({
      encryptedZendeskApiKey: encryptedApiKey,
      zendeskDomain,
      zendeskEmail,
      slackConnectionId: connection.id,
      status: "ACTIVE",
      zendeskTriggerId,
      zendeskWebhookId,
      hashedWebhookBearerToken: hashedWebhookToken
    }).onConflictDoUpdate({
      target: zendeskConnection.slackConnectionId,
      set: {
        updatedAt: /* @__PURE__ */ new Date(),
        encryptedZendeskApiKey: encryptedApiKey,
        zendeskDomain,
        zendeskEmail,
        hashedWebhookBearerToken: hashedWebhookToken,
        zendeskTriggerId,
        zendeskWebhookId,
        status: "ACTIVE"
      }
    });
    const slackUserId = payload.user?.id;
    if (slackUserId) {
      await handleAppHomeOpened(slackUserId, connection, db, env, key);
    }
  } catch (error) {
    safeLog("error", error);
    throw error;
  }
}
async function openSlackModal(body, connection) {
  const response = await fetch("https://slack.com/api/views.open", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${connection.token}`
    },
    body
  });
  const responseData = await response.json();
  if (!responseData.ok) {
    safeLog("error", "Error opening modal:", responseData);
    throw new Error(`Error opening modal: ${JSON.stringify(responseData)}`);
  }
}
async function openAccountSettings(payload, connection, env, db) {
  const triggerId = payload.trigger_id;
  if (!triggerId) {
    safeLog("warn", "No trigger_id found in payload");
    return;
  }
  try {
    if (!connection.stripeCustomerId) {
      safeLog(
        "error",
        `No stripeCustomerId found in connection ${connection.id}`
      );
      throw new Error("No stripe customer found in connection");
    }
    const stripeProductId = connection.subscription?.stripeProductId;
    const stripe = new stripe_esm_worker_default(env.STRIPE_API_KEY);
    const limitedChannels = await db.select({ id: channel.id }).from(channel).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.isMember, true)
      )
    ).limit(4);
    const billingPortalConfiguration = getBillingPortalConfiguration(
      limitedChannels.length
    );
    const session = await stripe.billingPortal.sessions.create({
      customer: connection.stripeCustomerId,
      ...billingPortalConfiguration !== null && {
        configuration: billingPortalConfiguration
      },
      return_url: `https://${connection.domain}.slack.com`
    });
    const portalUrl = session.url;
    if (!portalUrl) {
      safeLog("error", "No portal URL found");
      throw new Error("No portal URL found");
    }
    let product;
    if (stripeProductId) {
      product = await stripe.products.retrieve(
        connection.subscription?.stripeProductId
      );
    }
    const body = JSON.stringify({
      trigger_id: triggerId,
      view: {
        notify_on_close: true,
        type: "modal",
        title: {
          type: "plain_text",
          text: "Account Details",
          emoji: true
        },
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: `*Current plan:* ${product?.name ?? ""}`
            }
          },
          {
            type: "context",
            elements: [
              {
                type: "mrkdwn",
                text: `${product?.description ?? ""}`
              }
            ]
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "Manage Subscription",
                  emoji: true
                },
                url: portalUrl
              }
            ]
          }
        ]
      }
    });
    await openSlackModal(body, connection);
  } catch (error) {
    safeLog("error", `Error in openBillingPortal: ${error}`);
    throw error;
  }
}
async function openZendeskConfigurationModal(payload, connection, db, env, key) {
  const triggerId = payload.trigger_id;
  if (!triggerId) {
    safeLog("warn", "No trigger_id found in payload");
    return;
  }
  try {
    const zendeskInfo = await fetchZendeskCredentials(
      connection.id,
      db,
      env,
      key
    );
    const body = JSON.stringify({
      trigger_id: triggerId,
      view: {
        type: "modal",
        callback_id: "zendesk-configuration-modal" /* ZENDESK_CONFIGURATION_MODAL_ID */,
        title: {
          type: "plain_text",
          text: "Zendesk Connection",
          emoji: true
        },
        submit: {
          type: "plain_text",
          text: "Connect",
          emoji: true
        },
        close: {
          type: "plain_text",
          text: "Cancel",
          emoji: true
        },
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: "Visit our <https://slacktozendesk.com/docs|documentation> for any questions or help connecting to Zendesk."
            }
          },
          {
            type: "input",
            block_id: "zendesk_domain",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-domain-input" /* ZENDESK_DOMAIN_TEXT_FIELD */,
              initial_value: `${zendeskInfo?.zendeskDomain ?? ""}`,
              placeholder: {
                type: "plain_text",
                text: "slacktozendesk.zendesk.com"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Domain Prefix",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: 'Example: If your Zendesk domain is yourcompany.zendesk.com, you would just enter "yourcompany" here.'
            }
          },
          {
            type: "input",
            block_id: "zendesk_api_key",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-api-key-input" /* ZENDESK_API_KEY_TEXT_FIELD */,
              placeholder: {
                type: "plain_text",
                text: "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk API Key",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: "The Zendesk API key your admin created."
            }
          },
          {
            type: "input",
            block_id: "zendesk_admin_email",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-email-input" /* ZENDESK_EMAIL_TEXT_FIELD */,
              initial_value: `${zendeskInfo?.zendeskEmail ?? ""}`,
              placeholder: {
                type: "plain_text",
                text: "admin@your-domain.com"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Admin Email",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: "Enter the email address of the Zendesk admin that created the API key."
            }
          }
        ]
      }
    });
    await openSlackModal(body, connection);
  } catch (error) {
    safeLog("error", `Error in openZendeskConfigurationModal: ${error}`);
    throw error;
  }
}
async function openChannelConfigurationModal(actionId, payload, connection, db) {
  const triggerId = payload.trigger_id;
  if (!triggerId) {
    safeLog("warn", "No trigger_id found in payload");
    throw new Error("No trigger_id found in payload");
  }
  try {
    const channelId = actionId.split(":")[1];
    if (!channelId) {
      safeLog("error", "No channel ID found in action ID");
      throw new Error("No channel ID found in action ID");
    }
    const channelInfo = await db.query.channel.findFirst({
      where: and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, channelId)
      )
    });
    if (!channelInfo) {
      safeLog("error", `No channel found for ID: ${channelId}`);
      throw new Error(`No channel found for ID: ${channelId}`);
    }
    const activityDate = channelInfo.latestActivityAt;
    const createdAtTimestamp = Math.floor(
      channelInfo.createdAt.getTime() / 1e3
    );
    const fallbackText = "No message activity";
    let lastActivityString = "No message activity";
    if (activityDate) {
      const latestActivityTimestamp = Math.floor(activityDate.getTime() / 1e3);
      lastActivityString = `Last message on <!date^${latestActivityTimestamp}^{date_short} at {time}|${fallbackText}>`;
    }
    const createdAtString = `Created on <!date^${createdAtTimestamp}^{date_short} at {time}|Created at date unavailable>`;
    const body = JSON.stringify({
      trigger_id: triggerId,
      view: {
        type: "modal",
        callback_id: `${"edit-channel-configuration-modal" /* EDIT_CHANNEL_CONFIGURATION_MODAL_ID */}:${channelId}`,
        title: {
          type: "plain_text",
          text: `#${channelInfo.name}`,
          emoji: true
        },
        submit: {
          type: "plain_text",
          text: "Save",
          emoji: true
        },
        close: {
          type: "plain_text",
          text: "Cancel",
          emoji: true
        },
        blocks: [
          {
            type: "context",
            elements: [
              {
                type: "mrkdwn",
                text: `${createdAtString}
${lastActivityString}`
              }
            ]
          },
          {
            type: "input",
            block_id: "channel_owner",
            optional: true,
            element: {
              type: "email_text_input",
              action_id: "edit-channel-owner-input" /* EDIT_CHANNEL_OWNER_FIELD */,
              ...channelInfo.defaultAssigneeEmail ? { initial_value: channelInfo.defaultAssigneeEmail } : {},
              placeholder: {
                type: "plain_text",
                text: "Enter an email or leave blank"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Assignee Email",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: "The email address of the Zendesk agent who should be assigned new tickets from this channel. Leave blank to handle assignment in Zendesk."
            }
          },
          {
            type: "input",
            block_id: "channel_tags",
            optional: true,
            element: {
              type: "plain_text_input",
              action_id: "edit-channel-tags-input" /* EDIT_CHANNEL_TAGS_FIELD */,
              initial_value: `${channelInfo.tags ? channelInfo.tags.join(", ") : ""}`,
              placeholder: {
                type: "plain_text",
                text: "example1, example2"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Tags",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: 'Enter a comma separated list of tags to set on Zendesk tickets created from this channel. Tags cannot contain spaces, dashes or special characters (-, #, @, !, etc.). Underscores "_" are allowed. The tag `zensync` is always automatically applied.'
            }
          }
        ]
      }
    });
    await openSlackModal(body, connection);
  } catch (error) {
    safeLog("error", `Error in openChannelConfigurationModal:`, error);
    throw error;
  }
}
async function updateChannelConfiguration(payload, connection, db, key, env) {
  const callbackId = payload.view?.callback_id;
  if (!callbackId) {
    safeLog(
      "error",
      `No callback_id found in payload: ${JSON.stringify(payload)}`
    );
    throw new Error("No callback_id found in payload");
  }
  try {
    const channelId = callbackId.split(":")[1];
    if (!channelId) {
      safeLog("error", `No channel ID found in callback_id: ${callbackId}`);
      throw new Error("No channel ID found in callback_id");
    }
    const ownerFieldActionId = "edit-channel-owner-input" /* EDIT_CHANNEL_OWNER_FIELD */;
    const tagsFieldActionId = "edit-channel-tags-input" /* EDIT_CHANNEL_TAGS_FIELD */;
    const stateValues = payload.view.state.values;
    let modalErrors = {};
    let channelOwnerEmail;
    const ownerBlock = Object.values(stateValues).find(
      (block) => block[ownerFieldActionId]
    );
    if (ownerBlock && typeof ownerBlock[ownerFieldActionId].value === "string") {
      const rawEmail = ownerBlock[ownerFieldActionId].value.trim();
      if (rawEmail.length > 0) {
        const emailRegex2 = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (emailRegex2.test(rawEmail)) {
          channelOwnerEmail = rawEmail;
        } else {
          modalErrors.channel_owner = "Please provide a valid email address or leave blank.";
        }
      }
    }
    let channelTags;
    const tagsBlock = Object.values(stateValues).find(
      (block) => block[tagsFieldActionId]
    );
    if (tagsBlock) {
      channelTags = tagsBlock[tagsFieldActionId].value;
    }
    const tagsArray = validateAndConvertTags(channelTags);
    if (tagsArray === null) {
      modalErrors.channel_tags = "Please provide a comma-separated list of tags without spaces or special characters, or leave blank.";
    }
    if (Object.keys(modalErrors).length > 0) {
      const errorResponse = JSON.stringify({
        response_action: "errors",
        errors: modalErrors
      });
      return new Response(errorResponse, {
        headers: { "Content-Type": "application/json" },
        status: 200
      });
    }
    await db.update(channel).set({
      defaultAssigneeEmail: channelOwnerEmail ?? null,
      tags: tagsArray
    }).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, channelId)
      )
    );
    const slackUserId = payload.user?.id;
    if (slackUserId) {
      await handleAppHomeOpened(slackUserId, connection, db, env, key);
    }
  } catch (error) {
    safeLog("error", `Error updating channel ${callbackId}`, error);
    throw error;
  }
}
function validateAndConvertTags(tagsString) {
  if (!tagsString || tagsString.trim().length === 0) {
    return [];
  }
  const trimmedTagsString = tagsString.replace(/\s*,\s*/g, ",").trim();
  const validTagsRegex = /^[a-zA-Z0-9_]+(,[a-zA-Z0-9_]+)*$/;
  if (validTagsRegex.test(trimmedTagsString)) {
    return trimmedTagsString.split(",");
  } else {
    return null;
  }
}

// src/endpoints/slackAuthRedirect.ts
init_modules_watch_stub();
var SlackAuthRedirect = class extends K {
  async handle(request, env, context, data) {
    const state = crypto.randomUUID();
    try {
      const db = initializeDb(env);
      await db.insert(slackOauthState).values({
        id: state
      });
    } catch (error) {
      safeLog("error", error);
      return new Response(JSON.stringify({ error: "Error saving state." }), {
        status: 500,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
    const scopes = [
      "team:read",
      "channels:read",
      "groups:read",
      "channels:history",
      "groups:history",
      "reactions:read",
      "chat:write",
      "chat:write.customize",
      "users:read.email",
      "users:read",
      "users.profile:read",
      "files:read",
      "files:write"
    ].join(",");
    const redirectUrl = `https://slack.com/oauth/v2/authorize?client_id=${env.SLACK_CLIENT_ID}&scope=${encodeURIComponent(scopes)}&state=${state}`;
    return Response.redirect(redirectUrl);
  }
};

// src/endpoints/slackAuthCallback.ts
init_modules_watch_stub();
var SlackAuthCallback = class extends K {
  async handle(request, env, context, data) {
    const url = new URL(request.url);
    const code = url.searchParams.get("code");
    const state = url.searchParams.get("state");
    if (!code || !state) {
      return new Response(
        "Missing required parameters: code and state. Try again.",
        {
          status: 400
        }
      );
    }
    const posthog = initializePosthog(env);
    const db = initializeDb(env);
    const slackOauthStateResponse = await db.query.slackOauthState.findFirst({
      where: eq(slackOauthState.id, state)
    });
    if (!slackOauthStateResponse || (/* @__PURE__ */ new Date()).getTime() - new Date(slackOauthStateResponse.createdAt).getTime() > 6e5) {
      return new Response("Invalid or expired state. Try again.", {
        status: 401
      });
    }
    let accessToken;
    let authedUser;
    let botUserId;
    let appId;
    let teamId;
    try {
      const params = new URLSearchParams();
      params.append("client_id", env.SLACK_CLIENT_ID);
      params.append("client_secret", env.SLACK_CLIENT_SECRET);
      params.append("code", code);
      const response2 = await fetch("https://slack.com/api/oauth.v2.access", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params
      });
      const responseData = await response2.json();
      if (!responseData.ok) {
        return new Response("Failed to authenticate.", { status: 401 });
      }
      accessToken = responseData.access_token;
      authedUser = responseData.authed_user.id;
      botUserId = responseData.bot_user_id;
      appId = responseData.app_id;
      if (!accessToken || !botUserId) {
        safeLog(
          "error",
          `Error fetching access token or bot user id: ${JSON.stringify(
            responseData,
            null,
            2
          )}`
        );
        return new Response("Missing access token.", { status: 404 });
      }
    } catch (error) {
      safeLog("error", error);
      return new Response("Authentication failed.", { status: 400 });
    }
    const response = await fetch("https://slack.com/api/team.info", {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    });
    try {
      const teamInfoResponse = await response.json();
      if (!teamInfoResponse.ok || !teamInfoResponse.team) {
        safeLog(
          "error",
          `Error fetching team info: ${JSON.stringify(
            teamInfoResponse,
            null,
            2
          )}`
        );
        return new Response("Invalid access token or permissions.", {
          status: 401
        });
      }
      const team = teamInfoResponse.team;
      teamId = team.id;
      const encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
      const encryptedToken = await encryptData(accessToken, encryptionKey2);
      const connectionInfo = await db.insert(slackConnection).values({
        slackTeamId: teamId,
        name: team.name,
        domain: team.domain,
        iconUrl: team.icon.image_132,
        emailDomain: team.email_domain,
        slackEnterpriseId: team.enterprise_id,
        slackEnterpriseName: team.enterprise_name,
        encryptedToken,
        authedUserId: authedUser,
        botUserId,
        appId,
        status: "ACTIVE"
      }).onConflictDoUpdate({
        target: slackConnection.slackTeamId,
        set: {
          updatedAt: /* @__PURE__ */ new Date(),
          name: team.name,
          domain: team.domain,
          iconUrl: team.icon.image_132,
          emailDomain: team.email_domain,
          slackEnterpriseId: team.enterprise_id,
          slackEnterpriseName: team.enterprise_name,
          encryptedToken,
          authedUserId: authedUser,
          botUserId,
          appId,
          status: "ACTIVE"
        }
      }).returning();
      posthog.groupIdentify({
        distinctId: authedUser,
        groupType: "company",
        groupKey: teamId,
        properties: {
          name: team.name
        }
      });
      posthog.capture({
        event: "user_signed_up",
        distinctId: authedUser,
        groups: { company: teamId }
      });
      if (connectionInfo && connectionInfo.length === 1) {
        const fullConnectionInfo = {
          ...connectionInfo[0],
          token: accessToken
        };
        if (!fullConnectionInfo.updatedAt) {
          await env.SLACK_CONNECTION_CREATED_QUEUE_BINDING.send({
            connectionDetails: fullConnectionInfo,
            idempotencyKey: crypto.randomUUID()
          });
        }
      }
    } catch (error) {
      safeLog("error", error);
      return new Response("Error saving access token.", { status: 500 });
    }
    await posthog.shutdown();
    return new Response(responseHtml(teamId, appId), {
      status: 200,
      headers: {
        "Content-Type": "text/html;charset=UTF-8"
      }
    });
  }
};
__publicField(SlackAuthCallback, "schema", {
  parameters: {
    code: M(String),
    state: M(String)
  }
});
function responseHtml(teamId, appId) {
  const html = `<!DOCTYPE html>
  <html>
  <head>
      <meta name="viewport" content="width=device-width"/>
      <meta charset="utf-8"/>
      <title data-react-helmet="true"></title>
      <style>
          .button-text { margin-bottom: 6px; font-size: 14px; }
          .icon { margin-right: 6px; }
          .logo-container { width: 240px; margin-right: 0.5rem; }
          .logo-container > svg { fill: #f37f20; }
          .main-text { font-size: 15px; line-height: 1.5rem; }
          .content-container { min-height: 100vh; display: flex; align-items: center; justify-content: center; background-color: #f0f0f2; margin: 0; padding: 0 1rem; font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; }
          .card { max-width: 600px; margin: 5rem auto; padding: 2rem; background-color: #fdfdff; border-radius: 6px; box-shadow: 2px 3px 7px 2px rgba(0, 0, 0, 0.02); color: #333; }
      </style>
  </head>
  <body>
  <div id="__flareact">
      <div class="content-container">
          <div class="card">
              <div class="logo-container">
                  <!-- SVG Logo goes here -->
              </div>
              <h2 class="title">You have successfully authorized Zensync \u{1F389}</h2>
              <p class="main-text">You're one step closer to taming your Slack support! Use the links below to dive right in our check out our getting started guides.</p>
              <div class="links-container">
                  <div class="link-item">
                  <span class="icon">\u{1F5A5}\uFE0F</span>
                      <a href="slack://app?team=${teamId}&id=${appId}&tab=home" target="_blank" rel="noreferrer noopener">Open in Slack</a>
                  </div>
                  <div class="link-item">
                      <span class="icon">\u{1F4D6}</span>
                      <a href="https://slacktozendesk.com/docs" target="_blank" rel="noreferrer noopener">Check out the docs and setup guides</a>
                  </div>
              </div>
              <h4 class="closing-remark">Feel free to close this browser window.</h4>
          </div>
      </div>
  </div>
  <!-- Scripts -->
  </body>
  </html>`;
  return html;
}

// src/endpoints/slackEvents.ts
init_modules_watch_stub();
var SlackEventHandler = class extends K {
  async handle(request, env, context, data) {
    const jsonClone = request.clone();
    const textClone = request.clone();
    const requestBody = await jsonClone.json();
    safeLog("log", "Incoming Slack event:", request);
    if (!await verifySlackRequest(textClone, env)) {
      safeLog("warn", "Slack verification failed!");
      return new Response("Verification failed", {
        status: 200
      });
    }
    const db = initializeDb(env);
    const encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
    const connectionDetails = await findSlackConnectionByAppId(
      requestBody.api_app_id,
      db,
      env,
      encryptionKey2
    );
    if (!connectionDetails) {
      safeLog(
        "warn",
        `No slack connection found for app ID: ${requestBody.api_app_id}.`
      );
      return new Response("Invalid api_app_id", {
        status: 404
      });
    }
    const eventType = requestBody.event?.type;
    const eventSubtype = requestBody.event?.subtype;
    if (eventType === "app_home_opened") {
      const slackUserId = requestBody.event?.user;
      if (slackUserId) {
        try {
          await handleAppHomeOpened(
            slackUserId,
            connectionDetails,
            db,
            env,
            encryptionKey2
          );
          await singleEventAnalyticsLogger(
            slackUserId,
            "app_home_opened",
            connectionDetails.appId,
            null,
            requestBody.event_time,
            null,
            null,
            env,
            null
          );
        } catch (error) {
          safeLog("error", `Error handling app_home_opened: ${error.message}`);
          return new Response("Internal Server Error", {
            status: 500
          });
        }
      } else {
        safeLog("error", "No slackUserId found in app_home_opened event");
      }
    } else if (isSubscriptionActive(connectionDetails, env) && (isMessageToQueue(eventType, eventSubtype) || eventType === "message" && isPayloadEligibleForTicket(requestBody, connectionDetails))) {
      try {
        await env.PROCESS_SLACK_MESSAGES_QUEUE_BINDING.send({
          eventBody: requestBody,
          connectionDetails
        });
      } catch (error) {
        safeLog("error", `Error publishing message queue: ${error.message}`);
        return new Response("Internal Server Error", {
          status: 500
        });
      }
    } else if (eventSubtype === "file_share" && isSubscriptionActive(connectionDetails, env)) {
      try {
        await env.UPLOAD_FILES_TO_ZENDESK_QUEUE_BINDING.send({
          eventBody: requestBody,
          connectionDetails
        });
      } catch (error) {
        safeLog("error", `Error publishing file to queue: ${error.message}`);
        return new Response("Internal Server Error", {
          status: 500
        });
      }
    } else if (eventType === "app_uninstalled") {
      try {
        await env.SLACK_APP_UNINSTALLED_QUEUE_BINDING.send({
          eventBody: requestBody,
          connectionDetails
        });
      } catch (error) {
        safeLog(
          "error",
          `Error publishing app uninstalled to queue: ${error.message}`
        );
        return new Response("Internal Server Error", {
          status: 500
        });
      }
    } else {
      safeLog("log", "No processable event type found for event");
    }
    return new Response("Ok", {
      status: 202
    });
  }
};
function isPayloadEligibleForTicket(request, connection) {
  const eventData = request.event;
  if (connection.botUserId === eventData.user) {
    safeLog("log", "Ignoring message from Zensync");
    return false;
  }
  const eligibleSubtypes = /* @__PURE__ */ new Set([
    "message_replied",
    "message_changed",
    "message_deleted",
    void 0
  ]);
  const subtype = eventData.subtype;
  if (eligibleSubtypes.has(subtype)) {
    return true;
  }
  safeLog("log", `Ignoring message subtype: ${subtype}`);
  return false;
}
function isMessageToQueue(eventType, eventSubtype) {
  const specificEventsToHandle = [
    "member_joined_channel",
    "channel_left",
    "channel_archive",
    "channel_unarchive",
    "channel_deleted",
    "channel_rename",
    "channel_id_changed"
  ];
  return specificEventsToHandle.includes(eventType) || specificEventsToHandle.includes(eventSubtype);
}

// src/endpoints/stripeEvents.ts
init_modules_watch_stub();
var StripeEventHandler = class extends K {
  async handle(request, env, context, data) {
    const body = await request.text();
    safeLog("log", "Stripe event received:", body);
    const stripe = new stripe_esm_worker_default(env.STRIPE_API_KEY);
    const sig = request.headers.get("stripe-signature");
    let event;
    try {
      event = await stripe.webhooks.constructEventAsync(
        body,
        sig,
        env.STRIPE_ENDPOINT_SECRET
      );
      switch (event.type) {
        case "customer.subscription.deleted":
          await updateCustomerSubscription(event.data.object, env);
          break;
        case "customer.subscription.updated":
          await updateCustomerSubscription(event.data.object, env);
          break;
        default:
          safeLog("log", `Unhandled event type ${event.type}`);
      }
    } catch (error) {
      safeLog("error", `Error constructing Stripe event:`, error);
      return new Response(`Webhook error ${error}`, { status: 400 });
    }
    return new Response("Ok", { status: 200 });
  }
};
async function updateCustomerSubscription(data, env) {
  try {
    const subscriptionId = data.id;
    const productId = data.items.data[0].price.product.toString();
    const db = initializeDb(env);
    const slackConnectionInfo = await db.select().from(slackConnection).fullJoin(
      subscription,
      eq(slackConnection.subscriptionId, subscription.id)
    ).where(eq(subscription.stripeSubscriptionId, subscriptionId)).limit(1);
    if (!slackConnectionInfo[0]) {
      safeLog("error", `Subscription not found: ${subscriptionId}`);
      throw new Error(`Subscription not found: ${subscriptionId}`);
    }
    const connectionInfo = slackConnectionInfo[0];
    const subscriptionInfo = connectionInfo.subscriptions;
    if (subscriptionInfo.updatedAt > new Date(data.created * 1e3)) {
      safeLog("warn", "Out of date subscription event");
      return;
    }
    const currentPeriodEnd = new Date(data.current_period_end * 1e3);
    const currentPeriodStart = new Date(data.current_period_start * 1e3);
    const canceledAt = data.canceled_at ? new Date(data.canceled_at * 1e3) : null;
    await db.update(subscription).set({
      updatedAt: new Date(data.created * 1e3),
      periodStart: currentPeriodStart,
      periodEnd: currentPeriodEnd,
      canceledAt,
      ...productId ? { stripeProductId: productId } : {}
    }).where(eq(subscription.stripeSubscriptionId, subscriptionId));
    await env.STRIPE_SUBSCRIPTION_CHANGED_QUEUE_BINDING.send({
      productId,
      subscriptionId: subscriptionInfo.id
    });
    if (canceledAt && subscriptionInfo.canceledAt === null) {
      const posthog = initializePosthog(env);
      posthog.capture({
        event: "subscription_cancelled",
        distinctId: "static_string_for_group_events",
        groups: { company: connectionInfo.slack_connections.appId }
      });
      await posthog.shutdown();
    } else if (getChannelsByProductId(productId) < getChannelsByProductId(subscriptionInfo.stripeProductId)) {
      const posthog = initializePosthog(env);
      posthog.capture({
        event: "subscription_downgraded",
        distinctId: "static_string_for_group_events",
        groups: { company: connectionInfo.slack_connections.appId }
      });
      await posthog.shutdown();
    } else if (getChannelsByProductId(productId) > getChannelsByProductId(subscriptionInfo.stripeProductId)) {
      const posthog = initializePosthog(env);
      posthog.capture({
        event: "subscription_upgraded",
        distinctId: "static_string_for_group_events",
        groups: { company: connectionInfo.slack_connections.appId }
      });
      await posthog.shutdown();
    }
  } catch (error) {
    safeLog("error", `Error updating customer subscription:`, error);
    throw new Error(`Error updating customer subscription: ${error}`);
  }
}

// src/endpoints/syncSubscription.ts
init_modules_watch_stub();
var SyncSubscriptionHandler = class extends K {
  async handle(request, env, context, data) {
    try {
      const url = new URL(request.url);
      const subscriptionId = url.searchParams.get("subscription_id");
      if (!subscriptionId) {
        safeLog("error", "Missing required parameters");
        return new Response("Missing required parameters", { status: 400 });
      }
      const db = initializeDb(env);
      const subscriptionInfo = await db.query.subscription.findFirst({
        where: eq(subscription.stripeSubscriptionId, subscriptionId)
      });
      if (!subscriptionInfo) {
        safeLog("error", "No subscription found");
        return new Response("No subscription found", { status: 404 });
      }
      const productId = subscriptionInfo.stripeProductId;
      if (!productId) {
        safeLog("error", "No product found");
        return new Response("No product found", { status: 404 });
      }
      await env.STRIPE_SUBSCRIPTION_CHANGED_QUEUE_BINDING.send({
        productId,
        subscriptionId: subscriptionInfo.id
      });
      return new Response("Ok", { status: 200 });
    } catch (error) {
      safeLog("error", `Error syncing subscription: ${error}`);
      return new Response("Error syncing subscription", { status: 500 });
    }
  }
};
__publicField(SyncSubscriptionHandler, "schema", {
  parameters: {
    subscription_id: M(String)
  }
});

// src/queues/queueHandler.ts
init_modules_watch_stub();

// src/queues/uploadFiles.ts
init_modules_watch_stub();
import { Buffer as Buffer2 } from "node:buffer";
async function uploadFilesToZendesk(requestJson, env) {
  safeLog("log", "uploadFilesToZendesk", requestJson);
  let responseJson = requestJson;
  const slackRequestBody = requestJson.eventBody;
  const connectionDetails = requestJson.connectionDetails;
  if (!connectionDetails) {
    safeLog("error", "No connection details found");
    return;
  }
  const slackFiles = slackRequestBody.event?.files || [];
  if (slackFiles.length === 0) {
    safeLog("error", "No file objects found in request body");
    return;
  }
  const db = initializeDb(env);
  let zendeskCredentials;
  try {
    zendeskCredentials = await fetchZendeskCredentials(
      connectionDetails.id,
      db,
      env
    );
  } catch (error) {
    safeLog("error", error);
    throw new Error("Error fetching Zendesk credentials");
  }
  if (!zendeskCredentials) {
    safeLog(
      "log",
      `No Zendesk credentials found for slack connection: ${connectionDetails.id}`
    );
    return;
  }
  let zendeskFileTokens = [];
  for (let slackFile of slackFiles) {
    if (slackFile.id && slackFile.file_access === "check_file_info") {
      slackFile = await getFileInfoFromSlack(connectionDetails, slackFile.id);
    }
    let uploadToken;
    try {
      uploadToken = await uploadFileFromUrlToZendesk(
        slackFile.url_private,
        slackFile.name,
        slackFile.mimetype,
        zendeskCredentials,
        connectionDetails
      );
    } catch (error) {
      safeLog("error", error);
      throw new Error("Error uploading file to Zendesk");
    }
    if (!uploadToken) {
      safeLog("error", "No upload token found");
      throw new Error("No upload token found");
    }
    zendeskFileTokens.push(uploadToken);
  }
  responseJson.eventBody.zendeskFileTokens = zendeskFileTokens;
  try {
    await env.PROCESS_SLACK_MESSAGES_QUEUE_BINDING.send(responseJson);
  } catch (error) {
    safeLog("error", "Error publishing to message processing queue:", error);
    throw new Error("Error publishing to queue");
  }
}
async function uploadFileFromUrlToZendesk(fileUrl, fileName, mimetype, zendeskCredentials, slackCredentials) {
  const fileResponse = await fetch(fileUrl, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${slackCredentials.token}`
    }
  });
  if (!fileResponse.ok) {
    throw new Error(`Error fetching file: ${fileResponse.statusText}`);
  }
  const arrayBuffer = await fileResponse.arrayBuffer();
  const fileBuffer = Buffer2.from(arrayBuffer);
  const url = `https://${zendeskCredentials.zendeskDomain}.zendesk.com/api/v2/uploads.json?filename=${encodeURIComponent(fileName)}`;
  const zendeskAuthToken = btoa(
    `${zendeskCredentials.zendeskEmail}/token:${zendeskCredentials.zendeskApiKey}`
  );
  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Basic ${zendeskAuthToken}`,
      "Content-Type": mimetype
    },
    body: fileBuffer
  });
  if (!response.ok) {
    safeLog("error", `Failed to upload to Zendesk:`, response);
    throw new Error(`Failed to upload to Zendesk`);
  }
  const data = await response.json();
  return data.upload.token;
}
async function getFileInfoFromSlack(slackConnection2, fileId) {
  try {
    const response = await fetch(
      `https://slack.com/api/files.info?file=${fileId}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${slackConnection2.token}`
        }
      }
    );
    const responseData = await response.json();
    if (!responseData.ok) {
      safeLog("error", `Error getting Slack file info:`, responseData);
      throw new Error(`Error getting Slack file info: ${responseData.error}`);
    }
    return responseData.file;
  } catch (error) {
    safeLog("error", `Error in getFileInfoFromSlack:`, error);
    throw error;
  }
}

// src/queues/handleSlackMessage.ts
init_modules_watch_stub();
var MISSING_ZENDESK_CREDENTIALS_MESSAGE = "Zendesk credentials are missing or inactive. Configure them in the Zensync app settings to start syncing messages.";
var eventHandlers = {
  member_joined_channel: handleChannelJoined,
  channel_left: handleChannelLeft,
  message: handleMessage,
  file_share: handleFileUpload,
  message_changed: handleMessageEdit,
  message_deleted: handleMessageDeleted,
  channel_archive: handleChannelLeft,
  channel_deleted: handleChannelLeft,
  channel_unarchive: handleChannelUnarchive,
  channel_rename: handleChannelNameChanged,
  channel_id_changed: handleChannelIdChanged
  // Add more event handlers as needed
};
async function handleMessageFromSlack(requestJson, env) {
  const requestBody = requestJson.eventBody;
  const connectionDetails = requestJson.connectionDetails;
  const analyticsIdempotencyKey = requestJson.idempotencyKey || null;
  if (!connectionDetails) {
    safeLog("error", "No connection details found in request:", requestJson);
    return;
  }
  const db = initializeDb(env);
  const encryptionKey2 = await importEncryptionKeyFromEnvironment(env);
  const eventType = requestBody.event?.type;
  const eventSubtype = requestBody.event?.subtype;
  if (eventSubtype && eventHandlers[eventSubtype]) {
    try {
      await eventHandlers[eventSubtype](
        requestBody,
        connectionDetails,
        db,
        env,
        encryptionKey2,
        analyticsIdempotencyKey
      );
    } catch (error) {
      safeLog("error", `Error handling ${eventSubtype} subtype event:`, error);
      throw new Error(`Error handling ${eventSubtype} event`);
    }
  } else if (eventType && eventHandlers[eventType]) {
    try {
      await eventHandlers[eventType](
        requestBody,
        connectionDetails,
        db,
        env,
        encryptionKey2,
        analyticsIdempotencyKey
      );
    } catch (error) {
      safeLog("error", `Error handling ${eventType} event:`, error);
      throw new Error(`Error handling ${eventSubtype} event`);
    }
  } else {
    safeLog("log", `No handler for event type: ${eventType}`);
  }
}
async function handleChannelJoined(request, connection, db, env, key, analyticsIdempotencyKey) {
  const eventData = request.event;
  const channelId = eventData.channel;
  if (connection.botUserId !== eventData.user) {
    return;
  }
  try {
    let channelStatus = null;
    const limitedChannels = await db.select({ id: channel.id }).from(channel).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.isMember, true)
      )
    ).limit(10);
    const channelLimit = getChannelsByProductId(
      connection.subscription?.stripeProductId
    );
    if (limitedChannels.length + 1 > channelLimit || // More channels than allowed
    !isSubscriptionActive(connection, env)) {
      channelStatus = "PENDING_UPGRADE";
      const inviterUserId = eventData.inviter;
      if (inviterUserId && inviterUserId !== "") {
        await postUpgradeEphemeralMessage(
          channelId,
          inviterUserId,
          connection,
          env
        );
      }
    }
    const zendeskCredentials = await fetchZendeskCredentials(
      connection.id,
      db,
      env,
      key
    );
    if (!zendeskCredentials || zendeskCredentials.status !== "ACTIVE") {
      await postEphemeralMessage(
        channelId,
        eventData.user,
        MISSING_ZENDESK_CREDENTIALS_MESSAGE,
        connection,
        env
      );
    }
    const params = new URLSearchParams();
    params.append("channel", channelId);
    const channelJoinResponse = await fetch(
      `https://slack.com/api/conversations.info?${params.toString()}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${connection.token}`
        }
      }
    );
    const channelJoinResponseData = await channelJoinResponse.json();
    if (!channelJoinResponseData.ok) {
      safeLog(
        "error",
        `Failed to fetch channel info:`,
        channelJoinResponseData
      );
      throw new Error("Failed to fetch channel info");
    }
    const channelType = getChannelType(channelJoinResponseData.channel);
    const channelName = channelJoinResponseData.channel?.name;
    const isShared = channelJoinResponseData.channel?.is_ext_shared || channelJoinResponseData.channel?.is_pending_ext_shared;
    await db.insert(channel).values({
      slackConnectionId: connection.id,
      slackChannelIdentifier: channelId,
      type: channelType,
      isMember: true,
      name: channelName,
      isShared,
      status: channelStatus
    }).onConflictDoUpdate({
      target: [channel.slackConnectionId, channel.slackChannelIdentifier],
      set: {
        updatedAt: /* @__PURE__ */ new Date(),
        type: channelType,
        isMember: true,
        name: channelName,
        isShared,
        status: channelStatus
      }
    });
    await singleEventAnalyticsLogger(
      eventData.inviter,
      "channel_joined",
      connection.appId,
      eventData.channel,
      request.event_time,
      analyticsIdempotencyKey,
      null,
      env,
      null
    );
  } catch (error) {
    safeLog("error", "Error saving channel to database:", error);
    throw error;
  }
}
async function postEphemeralMessage(channelId, userId, text2, connection, env) {
  const postEphemeralParams = new URLSearchParams({
    channel: channelId,
    user: userId,
    text: text2
  });
  const ephemeralResponse = await fetch(
    `https://slack.com/api/chat.postEphemeral?${postEphemeralParams.toString()}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `Bearer ${connection.token}`
      }
    }
  );
  if (!ephemeralResponse.ok) {
    safeLog("error", `Failed to post ephemeral message:`, ephemeralResponse);
  }
}
async function postUpgradeEphemeralMessage(channelId, userId, connection, env) {
  let ephemeralMessageText = "You've reached your maximum channel limit, upgrade your plan to join this channel.";
  const stripe = new stripe_esm_worker_default(env.STRIPE_API_KEY);
  const session = await stripe.billingPortal.sessions.create({
    customer: connection.stripeCustomerId,
    return_url: `https://${connection.domain}.slack.com`,
    ...connection.subscription?.stripeSubscriptionId && {
      flow_data: {
        type: "subscription_update",
        subscription_update: {
          subscription: connection.subscription.stripeSubscriptionId
        }
      }
    }
  });
  const portalUrl = session.url;
  if (portalUrl) {
    ephemeralMessageText = `You've reached you maximum channel limit, <${portalUrl}|upgrade your plan> to join this channel.`;
  }
  await postEphemeralMessage(
    channelId,
    userId,
    ephemeralMessageText,
    connection,
    env
  );
}
function getChannelType(channelData) {
  if (typeof channelData !== "object" || channelData === null) {
    safeLog("warn", "Invalid or undefined channel data received:", channelData);
    return null;
  }
  if (channelData.is_channel) {
    return "PUBLIC";
  } else if (channelData.is_private) {
    return "PRIVATE";
  } else if (channelData.is_im) {
    return "DM";
  } else if (channelData.is_mpim) {
    return "GROUP_DM";
  }
  safeLog("warn", `Unkonwn channel type: ${channelData}`);
  return null;
}
async function handleChannelLeft(request, connection, db, env, key, analyticsIdempotencyKey) {
  const eventData = request.event;
  const channelId = eventData.channel;
  try {
    await db.update(channel).set({
      updatedAt: /* @__PURE__ */ new Date(),
      isMember: false
    }).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, channelId)
      )
    );
    await singleEventAnalyticsLogger(
      eventData.user,
      "channel_left",
      connection.appId,
      eventData.channel,
      request.event_time,
      analyticsIdempotencyKey,
      null,
      env,
      null
    );
  } catch (error) {
    safeLog("error", `Error archiving channel in database:`, error);
    throw error;
  }
}
async function handleChannelUnarchive(request, connection, db, env, key, analyticsIdempotencyKey) {
  const eventData = request.event;
  const channelId = eventData.channel;
  try {
    await db.update(channel).set({
      updatedAt: /* @__PURE__ */ new Date(),
      isMember: true
    }).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, channelId)
      )
    );
    await singleEventAnalyticsLogger(
      eventData.user,
      "channel_joined",
      connection.appId,
      request.event?.channel,
      request.event_time,
      analyticsIdempotencyKey,
      null,
      env,
      null
    );
  } catch (error) {
    safeLog("error", `Error unarchiving channel in database:`, error);
    throw error;
  }
}
async function handleChannelNameChanged(request, connection, db, env, key) {
  const eventData = request.event;
  try {
    await db.update(channel).set({
      updatedAt: /* @__PURE__ */ new Date(),
      name: eventData.channel.name
    }).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, eventData.channel.id)
      )
    );
  } catch (error) {
    safeLog("error", `Error updating channel name in database:`, error);
    throw error;
  }
}
async function handleChannelIdChanged(request, connection, db, env, key) {
  const eventData = request.event;
  try {
    await db.update(channel).set({
      updatedAt: /* @__PURE__ */ new Date(),
      slackChannelIdentifier: eventData.new_channel_id
    }).where(
      and(
        eq(channel.slackConnectionId, connection.id),
        eq(channel.slackChannelIdentifier, eventData.old_channel_id)
      )
    );
  } catch (error) {
    safeLog("error", `Error updating channel Id in database`, error);
    throw error;
  }
}
async function handleFileUpload(request, connection, db, env, key, analyticsIdempotencyKey) {
  if (request.zendeskFileTokens) {
    return await handleMessage(
      request,
      connection,
      db,
      env,
      key,
      analyticsIdempotencyKey
    );
  } else {
    safeLog("log", "Need to handle file fallback");
    const files = request.event.files;
    if (!files || files.length === 0) {
      safeLog("warn", "No files found in fallback");
      return await handleMessage(
        request,
        connection,
        db,
        env,
        key,
        analyticsIdempotencyKey
      );
    }
    let htmlOutput = "<p><strong>Attachments:</strong>";
    for (const file of files) {
      htmlOutput += `<br><a href="${file.permalink}">${file.title}</a>`;
    }
    htmlOutput += "</p>";
    request.event.text += htmlOutput;
    return await handleMessage(
      request,
      connection,
      db,
      env,
      key,
      analyticsIdempotencyKey
    );
  }
}
async function handleMessageEdit(request, connection, db, env, key, analyticsIdempotencyKey) {
  if (request.event?.message?.text === request.event?.previous_message?.text) {
    safeLog("log", "Message edit was not a change to text, ignoring");
    return;
  } else if (request.event?.message) {
    request.event = {
      ...request.event,
      ...request.event.message,
      text: `<strong>(Edited)</strong>

${request.event.message.text}`
    };
    try {
      await singleEventAnalyticsLogger(
        request.event?.user,
        "message_edited",
        connection.appId,
        request.event?.channel,
        request.event_time,
        analyticsIdempotencyKey,
        null,
        env,
        null
      );
    } catch (error) {
      safeLog("error", `Analytics logging error:`, error);
    }
    return await handleMessage(
      request,
      connection,
      db,
      env,
      key,
      analyticsIdempotencyKey
    );
  } else {
    safeLog("warn", `Unhandled message edit type:`, request);
    return;
  }
}
async function handleMessageDeleted(request, connection, db, env, key, analyticsIdempotencyKey) {
  if (request.event?.previous_message) {
    request.event = {
      ...request.event,
      ...request.event.previous_message,
      text: `<strong>(Deleted)</strong>

${request.event.previous_message.text}`
    };
    let status = "open";
    if (!getParentMessageId(request.event)) {
      status = "closed";
    }
    try {
      await singleEventAnalyticsLogger(
        request.event?.user,
        "message_deleted",
        connection.appId,
        request.event?.channel,
        request.event_time,
        analyticsIdempotencyKey,
        null,
        env,
        null
      );
    } catch (error) {
      safeLog("error", `Analytics logging error:`, error);
    }
    return await handleMessage(
      request,
      connection,
      db,
      env,
      key,
      analyticsIdempotencyKey,
      false,
      status
    );
  } else {
    safeLog("warn", `Unhandled message deletion:`, request);
    return;
  }
}
async function handleMessage(request, connection, db, env, key, analyticsIdempotencyKey, isPublic = true, status = "open") {
  const messageData = request.event;
  if (!messageData || messageData.type !== "message") {
    safeLog("error", "Invalid message payload", request);
    return;
  }
  const fileUploadTokens = request.zendeskFileTokens;
  let zendeskCredentials;
  try {
    zendeskCredentials = await fetchZendeskCredentials(
      connection.id,
      db,
      env,
      key
    );
  } catch (error) {
    safeLog("error", error);
    throw new Error("Error fetching Zendesk credentials");
  }
  if (!zendeskCredentials) {
    safeLog(
      "log",
      `No Zendesk credentials found for slack connection: ${connection.id}`
    );
    return;
  }
  let zendeskUserId;
  try {
    zendeskUserId = await getOrCreateZendeskUser(
      connection,
      zendeskCredentials,
      messageData
    );
  } catch (error) {
    safeLog("error", `Error getting or creating Zendesk user:`, error);
    throw error;
  }
  if (!zendeskUserId) {
    safeLog("error", "No Zendesk user ID");
    throw new Error("No Zendesk user ID");
  }
  const parentMessageId = getParentMessageId(messageData);
  if (parentMessageId || !isPublic) {
    try {
      await handleThreadReply(
        messageData,
        zendeskCredentials,
        connection,
        db,
        env,
        messageData.channel,
        parentMessageId ?? messageData.ts,
        zendeskUserId,
        fileUploadTokens,
        isPublic,
        status,
        analyticsIdempotencyKey
      );
    } catch (error) {
      safeLog("error", `Error handling thread reply:`, error);
      throw error;
    }
    return;
  }
  const existingConversationId = await sameSenderConversationId();
  if (existingConversationId) {
    return;
  }
  try {
    await handleNewConversation(
      messageData,
      zendeskCredentials,
      connection,
      db,
      env,
      messageData.channel,
      zendeskUserId,
      fileUploadTokens,
      isPublic,
      analyticsIdempotencyKey
    );
  } catch (error) {
    safeLog("error", `Error creating new conversation:`, error);
    throw error;
  }
}
function getParentMessageId(event) {
  if (event.thread_ts && event.thread_ts !== event.ts) {
    return event.thread_ts;
  }
  return null;
}
async function sameSenderConversationId() {
  return null;
}
async function getOrCreateZendeskUser(slackConnection2, zendeskCredentials, messageData) {
  const zendeskAuthToken = btoa(
    `${zendeskCredentials.zendeskEmail}/token:${zendeskCredentials.zendeskApiKey}`
  );
  const slackChannelId = messageData.channel;
  if (!messageData.user) {
    safeLog("error", `No slack user found:`, messageData);
    throw new Error("No message user found");
  }
  try {
    const { username, imageUrl } = await getSlackUser(
      slackConnection2,
      messageData.user
    );
    const zendeskUserData = {
      user: {
        name: `${username} (via Slack)` || "Unknown Slack user",
        skip_verify_email: true,
        external_id: `zensync-${slackChannelId}:${messageData.user}`,
        remote_photo_url: imageUrl
      }
    };
    const response = await fetch(
      `https://${zendeskCredentials.zendeskDomain}.zendesk.com/api/v2/users/create_or_update`,
      {
        method: "POST",
        headers: {
          Authorization: `Basic ${zendeskAuthToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(zendeskUserData)
      }
    );
    if (!response.ok) {
      throw new Error("Error updating or creating user");
    }
    const responseData = await response.json();
    return responseData.user.id;
  } catch (error) {
    safeLog("error", `Error creating or updating user:`, error);
    throw error;
  }
}
function extractProfileImageUrls(slackImageUrl) {
  const [gravatarUrl, slackUrl] = slackImageUrl.split("&d=");
  return {
    gravatarUrl,
    slackUrl: slackUrl ? decodeURIComponent(slackUrl) : null
  };
}
async function getSlackUser(connection, userId) {
  try {
    const response = await fetch(
      `https://slack.com/api/users.profile.get?user=${userId}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${connection.token}`
        }
      }
    );
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error getting Slack user: ${responseData.error}`);
    }
    const username = responseData.profile.display_name || responseData.profile.real_name || void 0;
    const { gravatarUrl, slackUrl } = extractProfileImageUrls(
      responseData.profile.image_72
    );
    const imageUrl = slackUrl || gravatarUrl;
    return { username, imageUrl };
  } catch (error) {
    safeLog("error", `Error in getSlackUser:`, error);
    throw error;
  }
}
async function handleThreadReply(messageData, zendeskCredentials, slackConnectionInfo, db, env, channelId, slackParentMessageId, authorId, fileUploadTokens, isPublic, status = "open", analyticsIdempotencyKey) {
  const conversationInfo = await db.select({
    id: conversation.id,
    zendeskTicketId: conversation.zendeskTicketId
  }).from(conversation).innerJoin(channel, eq(conversation.channelId, channel.id)).where(
    and(
      eq(channel.slackChannelIdentifier, channelId),
      eq(conversation.slackParentMessageId, slackParentMessageId),
      eq(channel.slackConnectionId, slackConnectionInfo.id)
    )
  ).limit(1);
  if (conversationInfo.length === 0 || !conversationInfo[0].zendeskTicketId || !conversationInfo[0].id) {
    safeLog("log", "No conversation found, creating new ticket");
    return await handleNewConversation(
      messageData,
      zendeskCredentials,
      slackConnectionInfo,
      db,
      env,
      channelId,
      authorId,
      fileUploadTokens,
      isPublic,
      analyticsIdempotencyKey
    );
  }
  const idempotencyKey = channelId + messageData.ts;
  const zendeskAuthToken = btoa(
    `${zendeskCredentials.zendeskEmail}/token:${zendeskCredentials.zendeskApiKey}`
  );
  const zendeskTicketId = conversationInfo[0].zendeskTicketId;
  const conversationId = conversationInfo[0].id;
  let htmlBody = slackMarkdownToHtml(messageData.text);
  if (!htmlBody || htmlBody === "") {
    htmlBody = "<i>(Empty message)</i>";
  }
  let commentData = {
    ticket: {
      comment: {
        html_body: htmlBody + generateHTMLPermalink(slackConnectionInfo, messageData),
        public: isPublic,
        author_id: authorId
      },
      status
    }
  };
  if (fileUploadTokens && fileUploadTokens.length > 0) {
    commentData.ticket.comment.uploads = fileUploadTokens;
  }
  const response = await fetch(
    `https://${zendeskCredentials.zendeskDomain}.zendesk.com/api/v2/tickets/${zendeskTicketId}.json`,
    {
      method: "PUT",
      headers: {
        Authorization: `Basic ${zendeskAuthToken}`,
        "Content-Type": "application/json",
        "Idempotency-Key": idempotencyKey
      },
      body: JSON.stringify(commentData)
    }
  );
  const responseData = await response.json();
  if (needsFollowUpTicket(responseData)) {
    if (isPublic) {
      const followUpTicket = {
        sourceTicketId: zendeskTicketId,
        conversationId
      };
      return await handleNewConversation(
        messageData,
        zendeskCredentials,
        slackConnectionInfo,
        db,
        env,
        messageData.channel,
        authorId,
        fileUploadTokens,
        true,
        analyticsIdempotencyKey,
        followUpTicket
      );
    }
  } else if (!response.ok) {
    throw new Error("Error creating comment");
  } else {
    try {
      await db.update(conversation).set({
        updatedAt: /* @__PURE__ */ new Date(),
        latestSlackMessageId: messageData.ts
      }).where(eq(conversation.id, conversationId));
      await updateChannelActivity(slackConnectionInfo, channelId, db);
      await singleEventAnalyticsLogger(
        messageData.user,
        "message_reply",
        slackConnectionInfo.appId,
        messageData.channel,
        messageData.ts,
        analyticsIdempotencyKey,
        {
          is_public: isPublic,
          has_attachments: fileUploadTokens && fileUploadTokens.length > 0,
          source: "slack"
        },
        env,
        null
      );
    } catch (error) {
      safeLog("error", `Error updating conversation in database:`, error);
      throw new Error("Error updating conversation in database");
    }
  }
}
function needsFollowUpTicket(responseJson) {
  if (responseJson.error === "RecordInvalid" && responseJson.details?.status) {
    const statusDetails = responseJson.details.status.find(
      (d4) => d4.description.includes("Status: closed prevents ticket update")
    );
    return !!statusDetails;
  } else if (responseJson.error === "RecordNotFound") {
    return true;
  }
  return false;
}
async function handleNewConversation(messageData, zendeskCredentials, slackConnectionInfo, db, env, channelId, authorId, fileUploadTokens, isPublic, analyticsIdempotencyKey, followUpTicket = void 0) {
  const channelInfo = await getChannelInfo(
    channelId,
    slackConnectionInfo.id,
    db
  );
  if (!channelInfo) {
    safeLog("error", `No channel found for ${channelId}`);
    throw new Error(`No channel found`);
  }
  if (!channelInfo.name) {
    safeLog("warn", `No channel name found, continuing: ${channelInfo}`);
  }
  if (!isChannelEligibleForMessaging(channelInfo)) {
    safeLog("log", `Channel is not eligible for messaging: ${channelInfo}`);
    return;
  }
  const idempotencyKey = channelId + messageData.ts;
  const zendeskAuthToken = btoa(
    `${zendeskCredentials.zendeskEmail}/token:${zendeskCredentials.zendeskApiKey}`
  );
  let conversationUuid = followUpTicket?.conversationId ?? crypto.randomUUID();
  let htmlBody = slackMarkdownToHtml(messageData.text);
  if (!htmlBody || htmlBody === "") {
    htmlBody = "<i>(Empty message)</i>";
  }
  const channelTags = channelInfo.tags || [];
  let ticketData = {
    ticket: {
      subject: `${channelInfo?.name}: ${messageData.text?.substring(0, 69) ?? ""}...`,
      comment: {
        html_body: htmlBody + generateHTMLPermalink(slackConnectionInfo, messageData),
        public: isPublic,
        author_id: authorId
      },
      requester_id: authorId,
      external_id: conversationUuid,
      tags: ["zensync"],
      ...channelInfo.defaultAssigneeEmail && {
        assignee_email: channelInfo.defaultAssigneeEmail
      },
      ...followUpTicket && {
        via_followup_source_id: followUpTicket.sourceTicketId
      }
    }
  };
  if (fileUploadTokens && fileUploadTokens.length > 0) {
    ticketData.ticket.comment.uploads = fileUploadTokens;
  }
  let ticketId = null;
  try {
    const response = await fetch(
      `https://${zendeskCredentials.zendeskDomain}.zendesk.com/api/v2/tickets.json`,
      {
        method: "POST",
        headers: {
          Authorization: `Basic ${zendeskAuthToken}`,
          "Content-Type": "application/json",
          "Idempotency-Key": idempotencyKey
        },
        body: JSON.stringify(ticketData)
      }
    );
    const responseData = await response.json();
    if (!response.ok) {
      throw new Error("Error creating ticket");
    }
    ticketId = responseData.ticket.id;
    await singleEventAnalyticsLogger(
      messageData.user,
      "ticket_created",
      slackConnectionInfo.appId,
      messageData.channel,
      messageData.ts,
      analyticsIdempotencyKey,
      {
        is_public: isPublic,
        has_attachments: fileUploadTokens && fileUploadTokens.length > 0
      },
      env,
      null
    );
  } catch (error) {
    safeLog("error", "Error creating ticket: ", error);
    throw error;
  }
  if (!ticketId) {
    safeLog("error", "No ticket ID in payload");
    throw new Error("No ticket ID");
  }
  if (followUpTicket) {
    try {
      await db.update(conversation).set({
        updatedAt: /* @__PURE__ */ new Date(),
        zendeskTicketId: ticketId,
        latestSlackMessageId: messageData.ts
      }).where(eq(conversation.id, conversationUuid));
    } catch (error) {
      safeLog("error", `Error updating conversation:`, error);
      safeLog("error", "Failed payload:", {
        zendeskTicketId: ticketId,
        latestSlackMessageId: messageData.ts
      });
    }
  } else {
    try {
      await db.insert(conversation).values({
        id: conversationUuid,
        channelId: channelInfo.id,
        slackParentMessageId: messageData.ts,
        zendeskTicketId: ticketId,
        slackAuthorUserId: messageData.user,
        latestSlackMessageId: messageData.ts
      });
    } catch (error) {
      safeLog("error", `Error creating conversation:`, error);
      safeLog("error", "Failed payload:", {
        id: conversationUuid,
        channelId: channelInfo.id,
        slackParentMessageId: messageData.ts,
        zendeskTicketId: ticketId,
        slackAuthorUserId: messageData.user,
        latestSlackMessageId: messageData.ts
      });
    }
  }
  try {
    await updateChannelActivity(slackConnectionInfo, channelId, db);
  } catch (error) {
    safeLog("error", `Error updating channel activity:`, error);
    throw error;
  }
}
function generateHTMLPermalink(slackConnection2, messageData) {
  return `<p><i>(<a href="https://${slackConnection2.domain}.slack.com/archives/${messageData.channel}/p${messageData.ts.replace(
    ".",
    ""
  )}?ref=zensync">View in Slack</a>)</i></p>`;
}
function slackMarkdownToHtml(markdown) {
  markdown = markdown.replace(/^>\s?(.*)/gm, "<blockquote>$1</blockquote>");
  markdown = markdown.replace(
    /```(.*?)```/gs,
    (_, code) => `<pre><code>${escapeCurlyBraces(code)}</code></pre>`
  );
  markdown = markdown.replace(
    /^\d+\.\s(.*)/gm,
    (_, item) => `<li>${item}</li>`
  );
  markdown = markdown.replace(/(<li>.*<\/li>)/gs, "<ol>$1</ol>");
  markdown = markdown.replace(
    /^[\*\+\-]\s(.*)/gm,
    (_, item) => `<li>${item}</li>`
  );
  markdown = markdown.replace(/(<li>.*<\/li>)/gs, "<ul>$1</ul>");
  markdown = markdown.replace(
    /`(.*?)`/g,
    (_, code) => `<code>${escapeCurlyBraces(code)}</code>`
  );
  markdown = markdown.replace(/\*(.*?)\*/g, "<strong>$1</strong>");
  markdown = markdown.replace(/_(.*?)_/g, "<em>$1</em>");
  markdown = markdown.replace(/~(.*?)~/g, "<del>$1</del>");
  markdown = markdown.replace(
    /^(?!<li>|<\/li>|<ol>|<\/ol>|<ul>|<\/ul>|<pre>|<\/pre>|<blockquote>|<\/blockquote>).*$/gm,
    "$&<br>"
  );
  return markdown;
}
function escapeCurlyBraces(code) {
  return code.replace(/{{(.*?)}}/g, "&lcub;&lcub;$1&rcub;&rcub;");
}

// src/queues/slackConnectionCreated.ts
init_modules_watch_stub();
async function slackConnectionCreated(requestJson, env) {
  const connectionDetails = requestJson.connectionDetails;
  if (!connectionDetails) {
    safeLog("error", "No connection details found", requestJson);
    return;
  }
  const email = await getAuthedConnectionUserEmail(connectionDetails);
  const db = initializeDb(env);
  await setupSupportChannelInSlack(connectionDetails, db, email, env);
  await setupCustomerInStripe(requestJson, connectionDetails, db, email, env);
}
async function setupSupportChannelInSlack(connectionDetails, db, email, env) {
  if (connectionDetails.supportSlackChannelId || !connectionDetails.domain || !connectionDetails.authedUserId) {
    return;
  }
  try {
    const headers = {
      "Content-type": "application/json",
      Accept: "application/json",
      Authorization: "Bearer " + env.INTERNAL_SLACKBOT_ACCESS_TOKEN
    };
    let createChannel = await fetch(
      "https://slack.com/api/conversations.create",
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          team_id: "T06Q45PBVGT",
          // Zensync team Id
          is_private: false,
          name: `ext-zensync-${connectionDetails.domain}`
        })
      }
    );
    const createChannelResponseData = await createChannel.json();
    if (!createChannelResponseData.ok) {
      throw new Error(
        `Error creating Slack channel: ${createChannelResponseData.error}`
      );
    }
    let inviteZensyncAccount = await fetch(
      "https://slack.com/api/conversations.invite",
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          channel: createChannelResponseData.channel.id,
          users: "U06QGUD7F5X"
          // ryan zensync user id
        })
      }
    );
    const inviteZensyncAccountResponseData = await inviteZensyncAccount.json();
    if (!inviteZensyncAccountResponseData.ok) {
      safeLog(
        "error",
        "Error inviting Zensync Account:",
        inviteZensyncAccountResponseData
      );
      throw new Error(
        `Error inviting Zensync Account: ${inviteZensyncAccountResponseData.error}`
      );
    }
    await db.update(slackConnection).set({
      supportSlackChannelId: createChannelResponseData.channel.id,
      supportSlackChannelName: `ext-zensync-${connectionDetails.domain}`
    }).where(eq(slackConnection.id, connectionDetails.id));
    let inviteExternalUser = await fetch(
      "https://slack.com/api/conversations.inviteShared",
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          channel: createChannelResponseData.channel.id,
          emails: email,
          external_limited: false
        })
      }
    );
    const inviteExternalUserResponseData = await inviteExternalUser.json();
    if (!inviteExternalUserResponseData.ok) {
      throw new Error(
        `Error inviting user: ${inviteExternalUserResponseData.error}`
      );
    }
  } catch (error) {
    safeLog("error", "Error in setupSupportChannelInSlack:", error);
    throw new Error("Error in setupSupportChannelInSlack");
  }
}
async function setupCustomerInStripe(requestJson, connectionDetails, db, email, env) {
  const idempotencyKey = requestJson.idempotencyKey;
  if (!idempotencyKey) {
    safeLog("error", "No idempotency key found");
    return;
  }
  try {
    const stripeAccount = await createStripeAccount(
      connectionDetails.name,
      email,
      env,
      idempotencyKey
    );
    const databaseSubscription = await db.insert(subscription).values({
      stripeSubscriptionId: stripeAccount.subscriptionId,
      stripeProductId: env.DEFAULT_STRIPE_PRODUCT_ID,
      // Conditionally include startedAt only if currentPeriodStart exists
      ...stripeAccount.currentPeriodStart ? { periodStart: new Date(stripeAccount.currentPeriodStart * 1e3) } : {},
      // Conditionally include endsAt only if currentPeriodEnd exists
      ...stripeAccount.currentPeriodEnd ? { periodEnd: new Date(stripeAccount.currentPeriodEnd * 1e3) } : {}
    }).onConflictDoNothing().returning({ insertedId: subscription.id });
    if (!databaseSubscription || databaseSubscription.length === 0) {
      safeLog("error", "Error upserting subscription");
      throw new Error("Error upserting subscription");
    }
    await db.update(slackConnection).set({
      stripeCustomerId: stripeAccount.customerId,
      subscriptionId: databaseSubscription[0].insertedId
    }).where(eq(slackConnection.id, connectionDetails.id));
  } catch (error) {
    safeLog("error", "Error in slackConnectionCreated:", error);
    throw new Error("Error in slackConnectionCreated");
  }
}
async function getAuthedConnectionUserEmail(connection) {
  try {
    const response = await fetch(
      `https://slack.com/api/users.info?user=${connection.authedUserId}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${connection.token}`
        }
      }
    );
    const responseData = await response.json();
    if (!responseData.ok) {
      return void 0;
    }
    return responseData.user.profile?.email || void 0;
  } catch (error) {
    safeLog("error", `Error in getSlackUserEmail:`, error);
    throw error;
  }
}

// src/queues/subscriptionChanged.ts
init_modules_watch_stub();
var PENDING_UPGRADE2 = "PENDING_UPGRADE";
async function stripeSubscriptionChanged(requestJson, env) {
  safeLog("log", "stripeSubscriptionChanged", requestJson);
  try {
    const db = initializeDb(env);
    await updateChannelStatus(db, requestJson);
  } catch (error) {
    safeLog("error", error);
    throw error;
  }
}
async function updateChannelStatus(db, requestJson) {
  const productId = requestJson.productId;
  const subscriptionId = requestJson.subscriptionId;
  if (!productId || !subscriptionId) {
    safeLog("error", "Missing required parameters");
    return;
  }
  const connection = await db.query.slackConnection.findFirst({
    where: eq(slackConnection.subscriptionId, subscriptionId)
  });
  if (!connection) {
    safeLog("error", `No connection found for subscription ${subscriptionId}`);
    return;
  }
  const channelLimit = getChannelsByProductId(productId);
  const allChannels = await db.query.channel.findMany({
    where: and(
      eq(channel.slackConnectionId, connection.id),
      eq(channel.isMember, true)
    ),
    orderBy: [asc(channel.createdAt)]
  });
  if (allChannels.length > channelLimit) {
    if (allChannels.length > 0 && channelLimit > 0) {
      const safeIndex = Math.min(channelLimit - 1, allChannels.length - 1);
      const lastActiveChannelDate = allChannels[safeIndex].createdAt;
      await activateChannels(db, connection.id, lastActiveChannelDate);
      await deactivateChannels(db, connection.id, lastActiveChannelDate);
    }
  } else {
    await activateAllChannels(db, connection.id);
  }
}
async function deactivateChannels(db, connectionId, beyondLimit) {
  const deactivateChannels2 = await db.update(channel).set({ status: PENDING_UPGRADE2, updatedAt: /* @__PURE__ */ new Date() }).where(
    and(
      eq(channel.slackConnectionId, connectionId),
      eq(channel.isMember, true),
      isNull(channel.status),
      gt2(channel.createdAt, beyondLimit)
    )
  ).returning();
  safeLog(
    "log",
    `Deactivated ${JSON.stringify(deactivateChannels2, null, 2)} channels`
  );
}
async function activateChannels(db, connectionId, upToLimit) {
  safeLog("log", `Activating channels up to ${upToLimit}`);
  const activatedChannels = await db.update(channel).set({ status: null, updatedAt: /* @__PURE__ */ new Date() }).where(
    and(
      eq(channel.slackConnectionId, connectionId),
      eq(channel.isMember, true),
      eq(channel.status, PENDING_UPGRADE2),
      lte(channel.createdAt, upToLimit)
    )
  ).returning();
  safeLog(
    "log",
    `Activated ${JSON.stringify(activatedChannels, null, 2)} channels`
  );
}
async function activateAllChannels(db, connectionId) {
  safeLog("log", `Activating all channels`);
  await db.update(channel).set({ status: null, updatedAt: /* @__PURE__ */ new Date() }).where(
    and(
      eq(channel.slackConnectionId, connectionId),
      eq(channel.isMember, true),
      eq(channel.status, PENDING_UPGRADE2)
    )
  );
}

// src/queues/slackAppUninstalled.ts
init_modules_watch_stub();
async function slackAppUninstalled(requestJson, env) {
  try {
    const connectionDetails = requestJson.connectionDetails;
    if (!connectionDetails) {
      safeLog("error", "No connection details found", requestJson);
      return;
    }
    const db = initializeDb(env);
    await leaveAllChannels(db, connectionDetails.id);
  } catch (error) {
    safeLog("error", error);
    throw error;
  }
}
async function leaveAllChannels(db, connectionId) {
  try {
    await db.update(channel).set({ isMember: false, updatedAt: /* @__PURE__ */ new Date() }).where(
      and(
        eq(channel.slackConnectionId, connectionId),
        eq(channel.isMember, true)
      )
    );
  } catch (error) {
    safeLog("error", error);
    throw error;
  }
}

// src/queues/queueHandler.ts
var QueueMessageHandler = class {
  async handle(batch, env, ctx) {
    try {
      for (const message2 of batch.messages) {
        switch (batch.queue) {
          case "upload-files-to-zendesk":
            await uploadFilesToZendesk(message2.body, env);
            break;
          case "process-slack-messages":
            await handleMessageFromSlack(message2.body, env);
            break;
          case "slack-connection-created":
            await slackConnectionCreated(message2.body, env);
            break;
          case "stripe-subscription-changed":
            await stripeSubscriptionChanged(message2.body, env);
            break;
          case "slack-app-uninstalled":
            await slackAppUninstalled(message2.body, env);
            break;
          case "dlq":
            safeLog("error", message2.body);
            break;
          default:
            safeLog("warn", `Unknown queue: ${batch.queue}`);
        }
      }
    } catch (error) {
      safeLog(
        "error",
        `Error processing queue message on ${batch.queue}`,
        error
      );
      throw error;
    }
  }
};

// src/index.ts
var router = h();
var message = new QueueMessageHandler();
router.post(`/v1/zendesk/events`, ZendeskEventHandler);
router.post(`/v1/slack/interactivity`, SlackInteractivityHandler);
router.get(`/v1/slack/auth/redirect`, SlackAuthRedirect);
router.get(`/v1/slack/auth/callback`, SlackAuthCallback);
router.post(`/v1/slack/events`, SlackEventHandler);
router.post(`/v1/stripe/events`, StripeEventHandler);
router.post(`/internal/syncSubscription`, SyncSubscriptionHandler);
router.all(
  "*",
  () => Response.json(
    {
      success: false,
      error: "Route not found"
    },
    { status: 404 }
  )
);
var worker = {
  async fetch(request, env, ctx) {
    return await router.handle(request, env, ctx);
  },
  queue: message.handle.bind(message)
};
var src_default = worker;
export {
  src_default as default,
  router
};
/*! Bundled license information:

bcryptjs/dist/bcrypt.js:
  (**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   *)

@neondatabase/serverless/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)

posthog-node/lib/index.esm.js:
  (**
   * uuidv7: An experimental implementation of the proposed UUID Version 7
   *
   * @license Apache-2.0
   * @copyright 2021-2023 LiosK
   * @packageDocumentation
   *)
*/
//# sourceMappingURL=index.js.map
