var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b3) => (typeof require !== "undefined" ? require : a2)[b3]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except2)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// .wrangler/tmp/bundle-7bl23J/checked-fetch.js
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-7bl23J/checked-fetch.js"() {
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init] = argArray;
        checkURL(request, init);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/zod-is-type.js
var require_zod_is_type = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/zod-is-type.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAnyZodType = exports.isZodType = void 0;
    function isZodType(schema4, typeName) {
      var _a89;
      return ((_a89 = schema4 === null || schema4 === void 0 ? void 0 : schema4._def) === null || _a89 === void 0 ? void 0 : _a89.typeName) === typeName;
    }
    exports.isZodType = isZodType;
    function isAnyZodType(schema4) {
      return "_def" in schema4;
    }
    exports.isAnyZodType = isAnyZodType;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/zod-extensions.js
var require_zod_extensions = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/zod-extensions.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __rest = exports && exports.__rest || function(s2, e3) {
      var t2 = {};
      for (var p4 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p4) && e3.indexOf(p4) < 0)
          t2[p4] = s2[p4];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s2); i2 < p4.length; i2++) {
          if (e3.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p4[i2]))
            t2[p4[i2]] = s2[p4[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendZodWithOpenApi = void 0;
    var zod_is_type_1 = require_zod_is_type();
    function preserveMetadataFromModifier(zod, modifier) {
      const zodModifier = zod.ZodType.prototype[modifier];
      zod.ZodType.prototype[modifier] = function(...args) {
        const result = zodModifier.apply(this, args);
        result._def.openapi = this._def.openapi;
        return result;
      };
    }
    function extendZodWithOpenApi(zod) {
      if (typeof zod.ZodType.prototype.openapi !== "undefined") {
        return;
      }
      zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
        var _a89, _b2, _c2, _d, _e2, _f;
        const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
        const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
        const _internal = Object.assign(Object.assign({}, (_a89 = this._def.openapi) === null || _a89 === void 0 ? void 0 : _a89._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
        const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b2 = this._def.openapi) === null || _b2 === void 0 ? void 0 : _b2.metadata), restOfOpenApi), ((_d = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
          param: Object.assign(Object.assign({}, (_f = (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
        } : void 0);
        const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
        if ((0, zod_is_type_1.isZodType)(this, "ZodObject")) {
          const originalExtend = this.extend;
          result.extend = function(...args) {
            var _a90, _b3, _c3, _d2, _e3, _f2;
            const extendedResult = originalExtend.apply(this, args);
            extendedResult._def.openapi = {
              _internal: {
                extendedFrom: ((_b3 = (_a90 = this._def.openapi) === null || _a90 === void 0 ? void 0 : _a90._internal) === null || _b3 === void 0 ? void 0 : _b3.refId) ? { refId: (_d2 = (_c3 = this._def.openapi) === null || _c3 === void 0 ? void 0 : _c3._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_e3 = this._def.openapi) === null || _e3 === void 0 ? void 0 : _e3._internal.extendedFrom
              },
              metadata: (_f2 = extendedResult._def.openapi) === null || _f2 === void 0 ? void 0 : _f2.metadata
            };
            return extendedResult;
          };
        }
        return result;
      };
      preserveMetadataFromModifier(zod, "optional");
      preserveMetadataFromModifier(zod, "nullable");
      preserveMetadataFromModifier(zod, "default");
      preserveMetadataFromModifier(zod, "transform");
      preserveMetadataFromModifier(zod, "refine");
      const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
      zod.ZodObject.prototype.deepPartial = function() {
        const initialShape = this._def.shape();
        const result = zodDeepPartial.apply(this);
        const resultShape = result._def.shape();
        Object.entries(resultShape).forEach(([key, value]) => {
          var _a89, _b2;
          value._def.openapi = (_b2 = (_a89 = initialShape[key]) === null || _a89 === void 0 ? void 0 : _a89._def) === null || _b2 === void 0 ? void 0 : _b2.openapi;
        });
        return result;
      };
      const zodPick = zod.ZodObject.prototype.pick;
      zod.ZodObject.prototype.pick = function(...args) {
        const result = zodPick.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
      const zodOmit = zod.ZodObject.prototype.omit;
      zod.ZodObject.prototype.omit = function(...args) {
        const result = zodOmit.apply(this, args);
        result._def.openapi = void 0;
        return result;
      };
    }
    exports.extendZodWithOpenApi = extendZodWithOpenApi;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/object-set.js
var require_object_set = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/object-set.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectSet = exports.isEqual = void 0;
    function isEqual(x2, y2) {
      if (x2 === null || x2 === void 0 || y2 === null || y2 === void 0) {
        return x2 === y2;
      }
      if (x2 === y2 || x2.valueOf() === y2.valueOf()) {
        return true;
      }
      if (Array.isArray(x2)) {
        if (!Array.isArray(y2)) {
          return false;
        }
        if (x2.length !== y2.length) {
          return false;
        }
      }
      if (!(x2 instanceof Object) || !(y2 instanceof Object)) {
        return false;
      }
      const keysX = Object.keys(x2);
      return Object.keys(y2).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x2[key], y2[key]));
    }
    exports.isEqual = isEqual;
    var ObjectSet = class {
      constructor() {
        this.buckets = /* @__PURE__ */ new Map();
      }
      put(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          this.buckets.set(hashCode, [value]);
          return;
        }
        const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
        if (!alreadyHasItem) {
          itemsByCode.push(value);
        }
      }
      contains(value) {
        const hashCode = this.hashCodeOf(value);
        const itemsByCode = this.buckets.get(hashCode);
        if (!itemsByCode) {
          return false;
        }
        return itemsByCode.some((_) => isEqual(_, value));
      }
      values() {
        return [...this.buckets.values()].flat();
      }
      stats() {
        let totalBuckets = 0;
        let totalValues = 0;
        let collisions = 0;
        for (const bucket of this.buckets.values()) {
          totalBuckets += 1;
          totalValues += bucket.length;
          if (bucket.length > 1) {
            collisions += 1;
          }
        }
        const hashEffectiveness = totalBuckets / totalValues;
        return { totalBuckets, collisions, totalValues, hashEffectiveness };
      }
      hashCodeOf(object) {
        let hashCode = 0;
        if (Array.isArray(object)) {
          for (let i2 = 0; i2 < object.length; i2++) {
            hashCode ^= this.hashCodeOf(object[i2]) * i2;
          }
          return hashCode;
        }
        if (typeof object === "string") {
          for (let i2 = 0; i2 < object.length; i2++) {
            hashCode ^= object.charCodeAt(i2) * i2;
          }
          return hashCode;
        }
        if (typeof object === "number") {
          return object;
        }
        if (typeof object === "object") {
          for (const [key, value] of Object.entries(object)) {
            hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
          }
        }
        return hashCode;
      }
    };
    exports.ObjectSet = ObjectSet;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/lodash.js
var require_lodash = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/lodash.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniq = exports.objectEquals = exports.compact = exports.omitBy = exports.omit = exports.mapValues = exports.isNil = exports.isUndefined = void 0;
    var object_set_1 = require_object_set();
    function isUndefined(value) {
      return value === void 0;
    }
    exports.isUndefined = isUndefined;
    function isNil(value) {
      return value === null || value === void 0;
    }
    exports.isNil = isNil;
    function mapValues(object, mapper) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        result[key] = mapper(value);
      });
      return result;
    }
    exports.mapValues = mapValues;
    function omit(object, keys) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!keys.some((keyToOmit) => keyToOmit === key)) {
          result[key] = value;
        }
      });
      return result;
    }
    exports.omit = omit;
    function omitBy(object, predicate) {
      const result = {};
      Object.entries(object).forEach(([key, value]) => {
        if (!predicate(value, key)) {
          result[key] = value;
        }
      });
      return result;
    }
    exports.omitBy = omitBy;
    function compact(arr) {
      return arr.filter((elem) => !isNil(elem));
    }
    exports.compact = compact;
    exports.objectEquals = object_set_1.isEqual;
    function uniq(values) {
      const set2 = new object_set_1.ObjectSet();
      values.forEach((value) => set2.put(value));
      return [...set2.values()];
    }
    exports.uniq = uniq;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-metadata.js
var require_openapi_metadata = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-metadata.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOpenApiMetadata = void 0;
    var lodash_1 = require_lodash();
    function getOpenApiMetadata(zodSchema) {
      var _a89, _b2;
      return (0, lodash_1.omitBy)((_b2 = (_a89 = zodSchema._def.openapi) === null || _a89 === void 0 ? void 0 : _a89.metadata) !== null && _b2 !== void 0 ? _b2 : {}, lodash_1.isNil);
    }
    exports.getOpenApiMetadata = getOpenApiMetadata;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-registry.js
var require_openapi_registry = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-registry.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAPIRegistry = void 0;
    var OpenAPIRegistry = class {
      constructor(parents) {
        this.parents = parents;
        this._definitions = [];
      }
      get definitions() {
        var _a89, _b2;
        const parentDefinitions = (_b2 = (_a89 = this.parents) === null || _a89 === void 0 ? void 0 : _a89.flatMap((par) => par.definitions)) !== null && _b2 !== void 0 ? _b2 : [];
        return [...parentDefinitions, ...this._definitions];
      }
      /**
       * Registers a new component schema under /components/schemas/${name}
       */
      register(refId, zodSchema) {
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        this._definitions.push({ type: "schema", schema: schemaWithRefId });
        return schemaWithRefId;
      }
      /**
       * Registers a new parameter schema under /components/parameters/${name}
       */
      registerParameter(refId, zodSchema) {
        var _a89, _b2, _c2;
        const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
        const currentMetadata = (_a89 = schemaWithRefId._def.openapi) === null || _a89 === void 0 ? void 0 : _a89.metadata;
        const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c2 = (_b2 = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : refId }) }));
        this._definitions.push({
          type: "parameter",
          schema: schemaWithMetadata
        });
        return schemaWithMetadata;
      }
      /**
       * Registers a new path that would be generated under paths:
       */
      registerPath(route) {
        this._definitions.push({
          type: "route",
          route
        });
      }
      /**
       * Registers a new webhook that would be generated under webhooks:
       */
      registerWebhook(webhook) {
        this._definitions.push({
          type: "webhook",
          webhook
        });
      }
      /**
       * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
       *
       * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
       * @param name The name of the object, it is the key under the component
       *             type in the resulting OpenAPI document
       * @param component The actual object to put there
       */
      registerComponent(type, name, component) {
        this._definitions.push({
          type: "component",
          componentType: type,
          name,
          component
        });
        return {
          name,
          ref: { $ref: `#/components/${type}/${name}` }
        };
      }
      schemaWithRefId(refId, zodSchema) {
        return zodSchema.openapi(refId);
      }
    };
    exports.OpenAPIRegistry = OpenAPIRegistry;
  }
});

// node_modules/yaml/browser/dist/nodes/identity.js
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var ALIAS, DOC, MAP, PAIR, SCALAR, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar, isSeq, hasAnchor;
var init_identity = __esm({
  "node_modules/yaml/browser/dist/nodes/identity.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  }
});

// node_modules/yaml/browser/dist/visit.js
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = visit_(i2, node.items[i2], visitor, path);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = await visitAsync_(i2, node.items[i2], visitor, path);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return visitor.Map?.(key, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path);
  if (isPair(node))
    return visitor.Pair?.(key, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var BREAK, SKIP, REMOVE;
var init_visit = __esm({
  "node_modules/yaml/browser/dist/visit.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove node");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
  }
});

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars, escapeTagName, Directives;
var init_directives = __esm({
  "node_modules/yaml/browser/dist/doc/directives.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_visit();
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
          const tags = {};
          visit(doc.contents, (_key, node) => {
            if (isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  }
});

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name = `${prefix}${i2}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
var init_anchors = __esm({
  "node_modules/yaml/browser/dist/doc/anchors.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_visit();
  }
});

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len = val.length; i2 < len; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var init_applyReviver = __esm({
  "node_modules/yaml/browser/dist/doc/applyReviver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v3, i2) => toJS(v3, String(i2), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
var init_toJS = __esm({
  "node_modules/yaml/browser/dist/nodes/toJS.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
  }
});

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase;
var init_Node = __esm({
  "node_modules/yaml/browser/dist/nodes/Node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_applyReviver();
    init_identity();
    init_toJS();
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Alias.js
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c3 = getAliasCount(doc, item, anchors);
      if (c3 > count)
        count = c3;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
var Alias;
var init_Alias = __esm({
  "node_modules/yaml/browser/dist/nodes/Alias.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_anchors();
    init_visit();
    init_identity();
    init_Node();
    init_toJS();
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue, Scalar;
var init_Scalar = __esm({
  "node_modules/yaml/browser/dist/nodes/Scalar.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Node();
    init_toJS();
    isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    Scalar = class extends NodeBase {
      constructor(value) {
        super(SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  }
});

// node_modules/yaml/browser/dist/doc/createNode.js
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t2) => t2.tag === tagName);
    const tagObj = match.find((t2) => !t2.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t2) => t2.identify?.(value) && !t2.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}
var defaultTagPrefix;
var init_createNode = __esm({
  "node_modules/yaml/browser/dist/doc/createNode.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Alias();
    init_identity();
    init_Scalar();
    defaultTagPrefix = "tag:yaml.org,2002:";
  }
});

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v3 = value;
  for (let i2 = path.length - 1; i2 >= 0; --i2) {
    const k2 = path[i2];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a2 = [];
      a2[k2] = v3;
      v3 = a2;
    } else {
      v3 = /* @__PURE__ */ new Map([[k2, v3]]);
    }
  }
  return createNode(v3, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath, Collection;
var init_Collection = __esm({
  "node_modules/yaml/browser/dist/nodes/Collection.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_createNode();
    init_identity();
    init_Node();
    isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema4) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema4,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema4) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema4)
          copy.schema = schema4;
        copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar(node) ? node.value : node;
        else
          return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!isPair(node))
            return false;
          const n2 = node.value;
          return n2 == null || allowScalar && isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var stringifyComment, lineComment;
var init_stringifyComment = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  }
});

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text2, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (let ch; ch = text2[i2 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text2[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text2, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text2[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i2 += 1];
            overflow = true;
          }
          const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text2;
          folds.push(j2);
          escapedFolds[j2] = true;
          end = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold = folds[i3];
    const end2 = folds[i3 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i2) {
  let ch = text2[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text2[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text2[i2 + 1];
  }
  return i2;
}
var FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED;
var init_foldFlowLines = __esm({
  "node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyString.js
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
    if (str[i2] === "\n") {
      if (i2 - start > limit)
        return true;
      start = i2 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i2 = 0, ch = json[i2]; ch; ch = json[++i2]) {
    if (ch === " " && json[i2 + 1] === "\\" && json[i2 + 2] === "n") {
      str += json.slice(start, i2) + "\\ ";
      i2 += 1;
      start = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i2 + 1]) {
        case "u":
          {
            str += json.slice(start, i2);
            const code = json.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i2, 6);
            }
            i2 += 5;
            start = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i2 + 2] === '"' || json.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str += json.slice(start, i2) + "\n\n";
            while (json[i2 + 2] === "\\" && json[i2 + 3] === "n" && json[i2 + 4] !== '"') {
              str += "\n";
              i2 += 2;
            }
            str += indent;
            if (json[i2 + 2] === " ")
              str += "\\";
            i2 += 1;
            start = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}
var getFoldOptions, containsDocumentMarker, blockEndNewlines;
var init_stringifyString = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_foldFlowLines();
    getFoldOptions = (ctx, isBlock2) => ({
      indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
  }
});

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t2) => t2.tag === item.tag);
    if (match.length > 0)
      return match.find((t2) => t2.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t2) => t2.identify?.(obj));
    tagObj = match.find((t2) => t2.format === item.format) ?? match.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o2) => tagObj = o2 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
var init_stringify = __esm({
  "node_modules/yaml/browser/dist/stringify/stringify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_anchors();
    init_identity();
    init_stringifyComment();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws2 = " ";
  if (keyComment || vsb || vcb) {
    ws2 = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws2 += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws2 === "\n")
        ws2 = "\n\n";
    } else {
      ws2 += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws2 = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws2 = "";
  }
  str += ws2 + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
var init_stringifyPair = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var init_log = __esm({
  "node_modules/yaml/browser/dist/log.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx?.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
var MERGE_KEY, isMergeKey;
var init_addPairToJSMap = __esm({
  "node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_log();
    init_stringify();
    init_identity();
    init_Scalar();
    init_toJS();
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
  }
});

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v3 = createNode(value, void 0, ctx);
  return new Pair(k2, v3);
}
var Pair;
var init_Pair = __esm({
  "node_modules/yaml/browser/dist/nodes/Pair.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_createNode();
    init_stringifyPair();
    init_addPairToJSMap();
    init_identity();
    Pair = class {
      constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema4) {
        let { key, value } = this;
        if (isNode(key))
          key = key.clone(schema4);
        if (isNode(value))
          value = value.clone(schema4);
        return new Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line = lines[i2];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i2 < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, indent, commentString(comment));
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
var init_stringifyCollection = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Collection();
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k2 = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k2)
        return it;
      if (isScalar(it.key) && it.key.value === k2)
        return it;
    }
  }
  return void 0;
}
var YAMLMap;
var init_YAMLMap = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stringifyCollection();
    init_addPairToJSMap();
    init_Collection();
    init_identity();
    init_Pair();
    init_Scalar();
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema4) {
        super(MAP, schema4);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema4, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map2 = new this(schema4);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map2.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema4.sortMapEntries === "function") {
          map2.items.sort(schema4.sortMapEntries);
        }
        return map2;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i2 === -1)
            this.items.push(_pair);
          else
            this.items.splice(i2, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          addPairToJSMap(ctx, map2, item);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/map.js
var map;
var init_map = __esm({
  "node_modules/yaml/browser/dist/schema/common/map.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_YAMLMap();
    map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq;
var init_YAMLSeq = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_createNode();
    init_stringifyCollection();
    init_Collection();
    init_identity();
    init_Scalar();
    init_toJS();
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema4) {
        super(SEQ, schema4);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i2 = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i2++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema4, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema4);
        if (obj && Symbol.iterator in Object(obj)) {
          let i2 = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i2++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq;
var init_seq = __esm({
  "node_modules/yaml/browser/dist/schema/common/seq.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_YAMLSeq();
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/string.js
var string;
var init_string = __esm({
  "node_modules/yaml/browser/dist/schema/common/string.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stringifyString();
    string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag;
var init_null = __esm({
  "node_modules/yaml/browser/dist/schema/common/null.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag;
var init_bool = __esm({
  "node_modules/yaml/browser/dist/schema/core/bool.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i2 = n2.indexOf(".");
    if (i2 < 0) {
      i2 = n2.length;
      n2 += ".";
    }
    let d4 = minFractionDigits - (n2.length - i2 - 1);
    while (d4-- > 0)
      n2 += "0";
  }
  return n2;
}
var init_stringifyNumber = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN, floatExp, float;
var init_float = __esm({
  "node_modules/yaml/browser/dist/schema/core/float.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyNumber();
    floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/int.js
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intIdentify, intResolve, intOct, int, intHex;
var init_int = __esm({
  "node_modules/yaml/browser/dist/schema/core/int.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stringifyNumber();
    intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema;
var init_schema = __esm({
  "node_modules/yaml/browser/dist/schema/core/schema.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    schema = [
      map,
      seq,
      string,
      nullTag,
      boolTag,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float
    ];
  }
});

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON, jsonScalars, jsonError, schema2;
var init_schema2 = __esm({
  "node_modules/yaml/browser/dist/schema/json/schema.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_map();
    init_seq();
    stringifyJSON = ({ value }) => JSON.stringify(value);
    jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify2,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    schema2 = [map, seq].concat(jsonScalars, jsonError);
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary;
var init_binary = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyString();
    binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i2 = 0; i2 < str.length; ++i2)
            buffer[i2] = str.charCodeAt(i2);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s2 = "";
          for (let i2 = 0; i2 < buf.length; ++i2)
            s2 += String.fromCharCode(buf[i2]);
          str = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n2 = Math.ceil(str.length / lineWidth);
          const lines = new Array(n2);
          for (let i2 = 0, o2 = 0; i2 < n2; ++i2, o2 += lineWidth) {
            lines[i2] = str.substr(o2, lineWidth);
          }
          str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i2 = 0; i2 < seq2.items.length; ++i2) {
      let item = seq2.items[i2];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn2 = pair.value ?? pair.key;
          cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i2] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i2++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs;
var init_pairs = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLSeq();
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap, omap;
var init_omap = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_toJS();
    init_YAMLMap();
    init_YAMLSeq();
    init_pairs();
    YAMLOMap = class extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map2 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
      static from(schema4, iterable, ctx) {
        const pairs2 = createPairs(schema4, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError) {
        const pairs2 = resolvePairs(seq2, onError);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag, falseTag;
var init_bool2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2, floatExp2, float2;
var init_float2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_stringifyNumber();
    floatNaN2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f2 = str.substring(dot + 1).replace(/_/g, "");
          if (f2[f2.length - 1] === "0")
            node.minFractionDigits = f2.length;
        }
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign2 = str[0];
  if (sign2 === "-" || sign2 === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign2 === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign2 === "-" ? -1 * n2 : n2;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intIdentify3, intBin, intOct2, int2, intHex2;
var init_int2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stringifyNumber();
    intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
    intBin = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
      stringify: (node) => intStringify2(node, 2, "0b")
    };
    intOct2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
      stringify: (node) => intStringify2(node, 8, "0")
    };
    int2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
      stringify: (node) => intStringify2(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet, set;
var init_set = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_YAMLMap();
    YAMLSet = class extends YAMLMap {
      constructor(schema4) {
        super(schema4);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema4, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema4);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
      resolve(map2, onError) {
        if (isMap(map2)) {
          if (map2.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map2);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign2 = str[0];
  const parts = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p4) => res2 * num(60) + num(p4), num(0));
  return sign2 === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n2) => n2;
  if (typeof value === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign2 = "";
  if (value < 0) {
    sign2 = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign2 + parts.map((n2) => String(n2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime, floatTime, timestamp;
var init_timestamp = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stringifyNumber();
    intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month, day2, hour2, minute2, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year2, month - 1, day2, hour2 || 0, minute2 || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d4 = parseSexagesimal(tz, false);
          if (Math.abs(d4) < 30)
            d4 *= 60;
          date -= 6e4 * d4;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3;
var init_schema3 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_binary();
    init_bool2();
    init_float2();
    init_int2();
    init_omap();
    init_pairs();
    init_set();
    init_timestamp();
    schema3 = [
      map,
      seq,
      string,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct2,
      int2,
      intHex2,
      floatNaN2,
      floatExp2,
      float2,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
  }
});

// node_modules/yaml/browser/dist/schema/tags.js
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var schemas, tagsByName, coreKnownTags;
var init_tags = __esm({
  "node_modules/yaml/browser/dist/schema/tags.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    init_schema();
    init_schema2();
    init_binary();
    init_omap();
    init_pairs();
    init_schema3();
    init_set();
    init_timestamp();
    schemas = /* @__PURE__ */ new Map([
      ["core", schema],
      ["failsafe", [map, seq, string]],
      ["json", schema2],
      ["yaml11", schema3],
      ["yaml-1.1", schema3]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float,
      floatExp,
      floatNaN,
      floatTime,
      int,
      intHex,
      intOct,
      intTime,
      map,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
  }
});

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey, Schema;
var init_Schema = __esm({
  "node_modules/yaml/browser/dist/schema/Schema.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_map();
    init_seq();
    init_string();
    init_tags();
    sortMapEntriesByKey = (a2, b3) => a2.key < b3.key ? -1 : a2.key > b3.key ? 1 : 0;
    Schema = class {
      constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema4 === "string" && schema4 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
var init_stringifyDocument = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/doc/Document.js
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document;
var init_Document = __esm({
  "node_modules/yaml/browser/dist/doc/Document.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Alias();
    init_Collection();
    init_identity();
    init_Pair();
    init_toJS();
    init_Schema();
    init_stringifyDocument();
    init_anchors();
    init_applyReviver();
    init_createNode();
    init_directives();
    Document = class {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
        }
        return new Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v3) => typeof v3 === "number" || v3 instanceof String || v3 instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k2 = this.createNode(key, null, options);
        const v3 = this.createNode(value, null, options);
        return new Pair(k2, v3);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (isEmptyPath(path))
          return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
        return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (isEmptyPath(path))
          return this.contents !== void 0;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new Directives({ version: version2 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s2 = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s2}`);
        }
        return stringifyDocument(this, options);
      }
    };
  }
});

// node_modules/yaml/browser/dist/errors.js
var YAMLError, YAMLParseError, YAMLWarning, prettifyError;
var init_errors = __esm({
  "node_modules/yaml/browser/dist/errors.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    YAMLError = class extends Error {
      constructor(name, pos, code, message3) {
        super();
        this.name = name;
        this.code = code;
        this.message = message3;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message3) {
        super("YAMLParseError", pos, code, message3);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message3) {
        super("YAMLWarning", pos, code, message3);
      }
    };
    prettifyError = (src, lc2) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc2.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc2.lineStarts[line - 1], lc2.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc2.lineStarts[line - 2], lc2.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
  }
});

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
var init_resolve_props = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-props.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
var init_util_contains_newline = __esm({
  "node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
var init_util_flow_indent_check = __esm({
  "node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_util_contains_newline();
  }
});

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b3) => a2 === b3 || isScalar(a2) && isScalar(b3) && a2.value === b3.value && !(a2.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var init_util_map_includes = __esm({
  "node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}
var startColMsg;
var init_resolve_block_map = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Pair();
    init_YAMLMap();
    init_resolve_props();
    init_util_contains_newline();
    init_util_flow_indent_check();
    init_util_map_includes();
    startColMsg = "All mapping items must start at the same column";
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs2, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs2.offset;
  let commentEnd = null;
  for (const { start, value } of bs2.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs2.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs2.offset, offset, commentEnd ?? offset];
  return seq2;
}
var init_resolve_block_seq = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_YAMLSeq();
    init_resolve_props();
    init_util_flow_indent_check();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}
var init_resolve_end = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-end.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
var blockMsg, isBlock;
var init_resolve_flow_collection = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Pair();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_end();
    init_resolve_props();
    init_util_contains_newline();
    init_util_map_includes();
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  }
});

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq" || !expType) {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t2) => t2.tag === tagName && t2.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt?.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag?.format)
    node.format = tag.format;
  return node;
}
var init_compose_collection = __esm({
  "node_modules/yaml/browser/dist/compose/compose-collection.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_block_map();
    init_resolve_block_seq();
    init_resolve_flow_collection();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message3 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message3);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i2;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent, content] = lines[i2];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message3 = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message3);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value += "\n" + lines[i2][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error === -1)
        error = offset + i2;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token = props[i2];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message3 = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message3);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message3 = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message3);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m3 = first.match(/^( *)/);
  const line0 = m3?.[1] ? [m3[1], first.slice(m3[1].length)] : ["", first];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}
var init_resolve_block_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i2);
      res += fold;
      i2 = offset;
    } else if (ch === "\\") {
      let next = source[++i2];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "\r" && source[i2 + 1] === "\n") {
        next = source[++i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next = source[i2 + 1];
      while (next === " " || next === "	")
        next = source[++i2 + 1];
      if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
var escapeCodes;
var init_resolve_flow_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Scalar();
    init_resolve_end();
    escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
  }
});

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => tag2.default && tag2.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
var init_compose_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identity();
    init_Scalar();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
  }
});

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i2];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset;
}
var init_util_empty_scalar_position = __esm({
  "node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/yaml/browser/dist/compose/compose-node.js
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message3 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message3);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
var CN;
var init_compose_node = __esm({
  "node_modules/yaml/browser/dist/compose/compose-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Alias();
    init_compose_collection();
    init_compose_scalar();
    init_resolve_end();
    init_util_empty_scalar_position();
    CN = { composeNode, composeEmptyNode };
  }
});

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
var init_compose_doc = __esm({
  "node_modules/yaml/browser/dist/compose/compose-doc.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_Document();
    init_compose_node();
    init_resolve_end();
    init_resolve_props();
  }
});

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i2 + 1]?.[0] !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer;
var init_composer = __esm({
  "node_modules/yaml/browser/dist/compose/composer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_directives();
    init_Document();
    init_errors();
    init_identity();
    init_compose_doc();
    init_resolve_end();
    Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message3, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message3));
          else
            this.errors.push(new YAMLParseError(pos, code, message3));
        };
        this.directives = new Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message3, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message3, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message3) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message3);
      else
        throw new YAMLParseError([offset, offset + 1], code, message3);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var init_cst_scalar = __esm({
  "node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
    init_errors();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/parse/cst-stringify.js
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
var stringify2;
var init_cst_stringify = __esm({
  "node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  }
});

// node_modules/yaml/browser/dist/parse/cst-visit.js
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i2 = 0; i2 < token.items.length; ++i2) {
        const ci = _visit(Object.freeze(path.concat([[field, i2]])), token.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
var BREAK2, SKIP2, REMOVE2;
var init_cst_visit = __esm({
  "node_modules/yaml/browser/dist/parse/cst-visit.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    BREAK2 = Symbol("break visit");
    SKIP2 = Symbol("skip children");
    REMOVE2 = Symbol("remove item");
    visit2.BREAK = BREAK2;
    visit2.SKIP = SKIP2;
    visit2.REMOVE = REMOVE2;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index2] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index2];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var BOM, DOCUMENT, FLOW_END, SCALAR2, isCollection2, isScalar2;
var init_cst = __esm({
  "node_modules/yaml/browser/dist/parse/cst.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_cst_scalar();
    init_cst_stringify();
    init_cst_visit();
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR2 = "";
    isCollection2 = (token) => !!token && "items" in token;
    isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  }
});

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits, tagChars, invalidFlowScalarChars, invalidAnchorChars, isNotAnchorChar, Lexer;
var init_lexer = __esm({
  "node_modules/yaml/browser/dist/parse/lexer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_cst();
    hexDigits = "0123456789ABCDEFabcdef".split("");
    tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    invalidFlowScalarChars = ",[]{}".split("");
    invalidAnchorChars = " ,[]{}\n\r	".split("");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i2];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i2 + 1] === "\n";
        return false;
      }
      charAt(n2) {
        return this.buffer[this.pos + n2];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n2) {
        return this.pos + n2 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n2) {
        return this.buffer.substr(this.pos, n2);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n2);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s2 = this.peek(3);
          if (s2 === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s2 === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n2;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n2 = yield* this.pushIndicators();
        switch (line[n2]) {
          case "#":
            yield* this.pushCount(line.length - n2);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n2 += yield* this.parseBlockScalarHeader();
            n2 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n2);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n2 = 0;
        while (line[n2] === ",") {
          n2 += yield* this.pushCount(1);
          n2 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n2 += yield* this.pushIndicators();
        switch (line[n2]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n2);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n2 = 0;
            while (this.buffer[end - 1 - n2] === "\\")
              n2 += 1;
            if (n2 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i2 = this.pos;
        while (true) {
          const ch = this.buffer[++i2];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i2;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i2 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield SCALAR2;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i2 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i2]) {
          if (ch === ":") {
            const next = this.buffer[i2 + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i2;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i2 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i2 += 1;
                ch = "\n";
                next = this.buffer[i2 + 1];
              } else
                end = i2;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i2 + 1);
              if (cs === -1)
                break;
              i2 = Math.max(i2, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i2;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR2;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n2) {
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos += n2;
          return n2;
        }
        return 0;
      }
      *pushToIndex(i2, allowEmpty) {
        const s2 = this.buffer.slice(this.pos, i2);
        if (s2) {
          yield s2;
          this.pos += s2.length;
          return s2.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i2 = this.pos + 2;
          let ch = this.buffer[i2];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i2];
          return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
        } else {
          let i2 = this.pos + 1;
          let ch = this.buffer[i2];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i2];
            else if (ch === "%" && hexDigits.includes(this.buffer[i2 + 1]) && hexDigits.includes(this.buffer[i2 + 2])) {
              ch = this.buffer[i2 += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i2, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i2 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i2];
        } while (ch === " " || allowTabs && ch === "	");
        const n2 = i2 - this.pos;
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos = i2;
        }
        return n2;
      }
      *pushUntil(test) {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (!test(ch))
          ch = this.buffer[++i2];
        return yield* this.pushToIndex(i2, false);
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter;
var init_line_counter = __esm({
  "node_modules/yaml/browser/dist/parse/line-counter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i2 = 0; i2 < list.length; ++i2)
    if (list[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i2 = 0; i2 < list.length; ++i2) {
    switch (list[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (prev[++i2]?.type === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser;
var init_parser = __esm({
  "node_modules/yaml/browser/dist/parse/parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_cst();
    init_lexer();
    Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message3 = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message3, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n2) {
        return this.stack[this.stack.length - n2];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message3 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message3 };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map2 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map2) {
        const it = map2.items[map2.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map2.indent)) {
                const prev = map2.items[map2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map2.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i2 = 0; i2 < it.sep.length; ++i2) {
              const st = it.sep[i2];
              switch (st.type) {
                case "newline":
                  nl.push(i2);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map2.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map2.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map2.items.push({ start, key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map2);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                  map2.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map2 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map2;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options).toString(options);
}
var init_public_api = __esm({
  "node_modules/yaml/browser/dist/public-api.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_composer();
    init_Document();
    init_errors();
    init_log();
    init_line_counter();
    init_parser();
  }
});

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var init_dist = __esm({
  "node_modules/yaml/browser/dist/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_composer();
    init_Document();
    init_Schema();
    init_errors();
    init_Alias();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_cst();
    init_lexer();
    init_line_counter();
    init_parser();
    init_public_api();
    init_visit();
  }
});

// node_modules/yaml/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  default: () => browser_default,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var browser_default;
var init_browser = __esm({
  "node_modules/yaml/browser/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_dist();
    browser_default = dist_exports;
  }
});

// node_modules/openapi3-ts/dist/server-kRKy5879.js
var require_server_kRKy5879 = __commonJS({
  "node_modules/openapi3-ts/dist/server-kRKy5879.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var r2 = class {
      static isValidExtension(i2) {
        return /^x-/.test(i2);
      }
      getExtension(i2) {
        if (!r2.isValidExtension(i2))
          throw new Error(`Invalid specification extension: '${i2}'. Extensions must start with prefix 'x-`);
        return this[i2] ? this[i2] : null;
      }
      addExtension(i2, t2) {
        if (!r2.isValidExtension(i2))
          throw new Error(`Invalid specification extension: '${i2}'. Extensions must start with prefix 'x-`);
        this[i2] = t2;
      }
      listExtensions() {
        const i2 = [];
        for (const t2 in this)
          Object.prototype.hasOwnProperty.call(this, t2) && r2.isValidExtension(t2) && i2.push(t2);
        return i2;
      }
    };
    function e3(s2, i2) {
      if (s2 && r2.isValidExtension(i2))
        return s2[i2];
    }
    function o2(s2, i2, t2) {
      s2 && r2.isValidExtension(i2) && (s2[i2] = t2);
    }
    var a2 = class {
      constructor(i2, t2) {
        this.url = i2, this.description = t2, this.variables = {};
      }
      addVariable(i2, t2) {
        this.variables[i2] = t2;
      }
    };
    var l3 = class {
      constructor(i2, t2, n2) {
        this.default = i2, this.enum = t2, this.description = n2;
      }
    };
    exports.Server = a2;
    exports.ServerVariable = l3;
    exports.SpecificationExtension = r2;
    exports.addExtension = o2;
    exports.getExtension = e3;
  }
});

// node_modules/openapi3-ts/dist/oas30-zGY2VGOJ.js
var require_oas30_zGY2VGOJ = __commonJS({
  "node_modules/openapi3-ts/dist/oas30-zGY2VGOJ.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var h2 = (init_browser(), __toCommonJS(browser_exports));
    var s2 = require_server_kRKy5879();
    function p4(e3) {
      const o2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
      if (e3) {
        for (const t2 in e3)
          if (t2 !== "default") {
            const n2 = Object.getOwnPropertyDescriptor(e3, t2);
            Object.defineProperty(o2, t2, n2.get ? n2 : { enumerable: true, get: () => e3[t2] });
          }
      }
      return o2.default = e3, Object.freeze(o2);
    }
    var m3 = p4(h2);
    var r2 = class {
      static create(o2) {
        return new r2(o2);
      }
      constructor(o2) {
        this.rootDoc = o2 || { openapi: "3.0.0", info: { title: "app", version: "version" }, paths: {}, components: { schemas: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, securitySchemes: {}, links: {}, callbacks: {} }, tags: [], servers: [] };
      }
      getSpec() {
        return this.rootDoc;
      }
      getSpecAsJson(o2, t2) {
        return JSON.stringify(this.rootDoc, o2, t2);
      }
      getSpecAsYaml() {
        return m3.stringify(this.rootDoc);
      }
      static isValidOpenApiVersion(o2) {
        o2 = o2 || "";
        const t2 = /(\d+)\.(\d+).(\d+)/.exec(o2);
        return !!(t2 && parseInt(t2[1], 10) >= 3);
      }
      addOpenApiVersion(o2) {
        if (!r2.isValidOpenApiVersion(o2))
          throw new Error("Invalid OpenApi version: " + o2 + ". Follow convention: 3.x.y");
        return this.rootDoc.openapi = o2, this;
      }
      addInfo(o2) {
        return this.rootDoc.info = o2, this;
      }
      addContact(o2) {
        return this.rootDoc.info.contact = o2, this;
      }
      addLicense(o2) {
        return this.rootDoc.info.license = o2, this;
      }
      addTitle(o2) {
        return this.rootDoc.info.title = o2, this;
      }
      addDescription(o2) {
        return this.rootDoc.info.description = o2, this;
      }
      addTermsOfService(o2) {
        return this.rootDoc.info.termsOfService = o2, this;
      }
      addVersion(o2) {
        return this.rootDoc.info.version = o2, this;
      }
      addPath(o2, t2) {
        return this.rootDoc.paths[o2] = { ...this.rootDoc.paths[o2] || {}, ...t2 }, this;
      }
      addSchema(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.schemas = this.rootDoc.components.schemas || {}, this.rootDoc.components.schemas[o2] = t2, this;
      }
      addResponse(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.responses = this.rootDoc.components.responses || {}, this.rootDoc.components.responses[o2] = t2, this;
      }
      addParameter(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.parameters = this.rootDoc.components.parameters || {}, this.rootDoc.components.parameters[o2] = t2, this;
      }
      addExample(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.examples = this.rootDoc.components.examples || {}, this.rootDoc.components.examples[o2] = t2, this;
      }
      addRequestBody(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.requestBodies = this.rootDoc.components.requestBodies || {}, this.rootDoc.components.requestBodies[o2] = t2, this;
      }
      addHeader(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.headers = this.rootDoc.components.headers || {}, this.rootDoc.components.headers[o2] = t2, this;
      }
      addSecurityScheme(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.securitySchemes = this.rootDoc.components.securitySchemes || {}, this.rootDoc.components.securitySchemes[o2] = t2, this;
      }
      addLink(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.links = this.rootDoc.components.links || {}, this.rootDoc.components.links[o2] = t2, this;
      }
      addCallback(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.callbacks = this.rootDoc.components.callbacks || {}, this.rootDoc.components.callbacks[o2] = t2, this;
      }
      addServer(o2) {
        return this.rootDoc.servers = this.rootDoc.servers || [], this.rootDoc.servers.push(o2), this;
      }
      addTag(o2) {
        return this.rootDoc.tags = this.rootDoc.tags || [], this.rootDoc.tags.push(o2), this;
      }
      addExternalDocs(o2) {
        return this.rootDoc.externalDocs = o2, this;
      }
    };
    function c3(e3, o2) {
      if (!s2.SpecificationExtension.isValidExtension(o2))
        return e3[o2];
    }
    function i2(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    function a2(e3) {
      return !Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    var d4 = Object.freeze(Object.defineProperty({ __proto__: null, OpenApiBuilder: r2, Server: s2.Server, ServerVariable: s2.ServerVariable, addExtension: s2.addExtension, getExtension: s2.getExtension, getPath: c3, isReferenceObject: i2, isSchemaObject: a2 }, Symbol.toStringTag, { value: "Module" }));
    exports.OpenApiBuilder = r2;
    exports.getPath = c3;
    exports.isReferenceObject = i2;
    exports.isSchemaObject = a2;
    exports.oas30 = d4;
  }
});

// node_modules/openapi3-ts/dist/oas30.js
var require_oas30 = __commonJS({
  "node_modules/openapi3-ts/dist/oas30.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var e3 = require_oas30_zGY2VGOJ();
    var r2 = require_server_kRKy5879();
    init_browser();
    exports.OpenApiBuilder = e3.OpenApiBuilder;
    exports.getPath = e3.getPath;
    exports.isReferenceObject = e3.isReferenceObject;
    exports.isSchemaObject = e3.isSchemaObject;
    exports.Server = r2.Server;
    exports.ServerVariable = r2.ServerVariable;
    exports.addExtension = r2.addExtension;
    exports.getExtension = r2.getExtension;
  }
});

// node_modules/openapi3-ts/dist/oas31-2ULMvMLl.js
var require_oas31_2ULMvMLl = __commonJS({
  "node_modules/openapi3-ts/dist/oas31-2ULMvMLl.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var a2 = (init_browser(), __toCommonJS(browser_exports));
    var r2 = require_server_kRKy5879();
    function p4(e3) {
      const o2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
      if (e3) {
        for (const t2 in e3)
          if (t2 !== "default") {
            const s2 = Object.getOwnPropertyDescriptor(e3, t2);
            Object.defineProperty(o2, t2, s2.get ? s2 : { enumerable: true, get: () => e3[t2] });
          }
      }
      return o2.default = e3, Object.freeze(o2);
    }
    var m3 = p4(a2);
    var n2 = class {
      static create(o2) {
        return new n2(o2);
      }
      constructor(o2) {
        this.rootDoc = o2 || { openapi: "3.1.0", info: { title: "app", version: "version" }, paths: {}, components: { schemas: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, securitySchemes: {}, links: {}, callbacks: {} }, tags: [], servers: [] };
      }
      getSpec() {
        return this.rootDoc;
      }
      getSpecAsJson(o2, t2) {
        return JSON.stringify(this.rootDoc, o2, t2);
      }
      getSpecAsYaml() {
        return m3.stringify(this.rootDoc);
      }
      static isValidOpenApiVersion(o2) {
        o2 = o2 || "";
        const t2 = /(\d+)\.(\d+).(\d+)/.exec(o2);
        return !!(t2 && parseInt(t2[1], 10) >= 3);
      }
      addOpenApiVersion(o2) {
        if (!n2.isValidOpenApiVersion(o2))
          throw new Error("Invalid OpenApi version: " + o2 + ". Follow convention: 3.x.y");
        return this.rootDoc.openapi = o2, this;
      }
      addInfo(o2) {
        return this.rootDoc.info = o2, this;
      }
      addContact(o2) {
        return this.rootDoc.info.contact = o2, this;
      }
      addLicense(o2) {
        return this.rootDoc.info.license = o2, this;
      }
      addTitle(o2) {
        return this.rootDoc.info.title = o2, this;
      }
      addDescription(o2) {
        return this.rootDoc.info.description = o2, this;
      }
      addTermsOfService(o2) {
        return this.rootDoc.info.termsOfService = o2, this;
      }
      addVersion(o2) {
        return this.rootDoc.info.version = o2, this;
      }
      addPath(o2, t2) {
        return this.rootDoc.paths = this.rootDoc.paths || {}, this.rootDoc.paths[o2] = { ...this.rootDoc.paths[o2] || {}, ...t2 }, this;
      }
      addSchema(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.schemas = this.rootDoc.components.schemas || {}, this.rootDoc.components.schemas[o2] = t2, this;
      }
      addResponse(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.responses = this.rootDoc.components.responses || {}, this.rootDoc.components.responses[o2] = t2, this;
      }
      addParameter(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.parameters = this.rootDoc.components.parameters || {}, this.rootDoc.components.parameters[o2] = t2, this;
      }
      addExample(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.examples = this.rootDoc.components.examples || {}, this.rootDoc.components.examples[o2] = t2, this;
      }
      addRequestBody(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.requestBodies = this.rootDoc.components.requestBodies || {}, this.rootDoc.components.requestBodies[o2] = t2, this;
      }
      addHeader(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.headers = this.rootDoc.components.headers || {}, this.rootDoc.components.headers[o2] = t2, this;
      }
      addSecurityScheme(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.securitySchemes = this.rootDoc.components.securitySchemes || {}, this.rootDoc.components.securitySchemes[o2] = t2, this;
      }
      addLink(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.links = this.rootDoc.components.links || {}, this.rootDoc.components.links[o2] = t2, this;
      }
      addCallback(o2, t2) {
        return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.callbacks = this.rootDoc.components.callbacks || {}, this.rootDoc.components.callbacks[o2] = t2, this;
      }
      addServer(o2) {
        return this.rootDoc.servers = this.rootDoc.servers || [], this.rootDoc.servers.push(o2), this;
      }
      addTag(o2) {
        return this.rootDoc.tags = this.rootDoc.tags || [], this.rootDoc.tags.push(o2), this;
      }
      addExternalDocs(o2) {
        return this.rootDoc.externalDocs = o2, this;
      }
      addWebhook(o2, t2) {
        var s2;
        return (s2 = this.rootDoc).webhooks ?? (s2.webhooks = {}), this.rootDoc.webhooks[o2] = t2, this;
      }
    };
    function c3(e3, o2) {
      if (!r2.SpecificationExtension.isValidExtension(o2))
        return e3 ? e3[o2] : void 0;
    }
    function i2(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    function h2(e3) {
      return !Object.prototype.hasOwnProperty.call(e3, "$ref");
    }
    var d4 = Object.freeze(Object.defineProperty({ __proto__: null, OpenApiBuilder: n2, Server: r2.Server, ServerVariable: r2.ServerVariable, addExtension: r2.addExtension, getExtension: r2.getExtension, getPath: c3, isReferenceObject: i2, isSchemaObject: h2 }, Symbol.toStringTag, { value: "Module" }));
    exports.OpenApiBuilder = n2;
    exports.getPath = c3;
    exports.isReferenceObject = i2;
    exports.isSchemaObject = h2;
    exports.oas31 = d4;
  }
});

// node_modules/openapi3-ts/dist/oas31.js
var require_oas31 = __commonJS({
  "node_modules/openapi3-ts/dist/oas31.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var e3 = require_oas31_2ULMvMLl();
    var r2 = require_server_kRKy5879();
    init_browser();
    exports.OpenApiBuilder = e3.OpenApiBuilder;
    exports.getPath = e3.getPath;
    exports.isReferenceObject = e3.isReferenceObject;
    exports.isSchemaObject = e3.isSchemaObject;
    exports.Server = r2.Server;
    exports.ServerVariable = r2.ServerVariable;
    exports.addExtension = r2.addExtension;
    exports.getExtension = r2.getExtension;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/errors.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownZodTypeError = exports.MissingParameterDataError = exports.ConflictError = exports.ZodToOpenAPIError = void 0;
    var ZodToOpenAPIError = class {
      constructor(message3) {
        this.message = message3;
      }
    };
    exports.ZodToOpenAPIError = ZodToOpenAPIError;
    var ConflictError = class extends ZodToOpenAPIError {
      constructor(message3, data) {
        super(message3);
        this.data = data;
      }
    };
    exports.ConflictError = ConflictError;
    var MissingParameterDataError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
        this.data = data;
      }
    };
    exports.MissingParameterDataError = MissingParameterDataError;
    var UnknownZodTypeError = class extends ZodToOpenAPIError {
      constructor(data) {
        super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
        this.data = data;
      }
    };
    exports.UnknownZodTypeError = UnknownZodTypeError;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/lib/enum-info.js
var require_enum_info = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/lib/enum-info.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumInfo = void 0;
    function enumInfo(enumObject) {
      const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
      const values = keysExceptReverseMappings.map((key) => enumObject[key]);
      const numericCount = values.filter((_) => typeof _ === "number").length;
      const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
      return { values, type };
    }
    exports.enumInfo = enumInfo;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js
var require_openapi_generator = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __rest = exports && exports.__rest || function(s2, e3) {
      var t2 = {};
      for (var p4 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p4) && e3.indexOf(p4) < 0)
          t2[p4] = s2[p4];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s2); i2 < p4.length; i2++) {
          if (e3.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p4[i2]))
            t2[p4[i2]] = s2[p4[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAPIGenerator = void 0;
    var errors_1 = require_errors();
    var enum_info_1 = require_enum_info();
    var lodash_1 = require_lodash();
    var zod_is_type_1 = require_zod_is_type();
    var OpenAPIGenerator = class {
      constructor(definitions, versionSpecifics) {
        this.definitions = definitions;
        this.versionSpecifics = versionSpecifics;
        this.schemaRefs = {};
        this.paramRefs = {};
        this.pathRefs = {};
        this.rawComponents = [];
        this.sortDefinitions();
      }
      generateDocumentData() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents(),
          paths: this.pathRefs
        };
      }
      generateComponents() {
        this.definitions.forEach((definition) => this.generateSingle(definition));
        return {
          components: this.buildComponents()
        };
      }
      buildComponents() {
        var _a89, _b2;
        const rawComponents = {};
        this.rawComponents.forEach(({ componentType, name, component }) => {
          var _a90;
          (_a90 = rawComponents[componentType]) !== null && _a90 !== void 0 ? _a90 : rawComponents[componentType] = {};
          rawComponents[componentType][name] = component;
        });
        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a89 = rawComponents.schemas) !== null && _a89 !== void 0 ? _a89 : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b2 = rawComponents.parameters) !== null && _b2 !== void 0 ? _b2 : {}), this.paramRefs) });
      }
      sortDefinitions() {
        const generationOrder = [
          "schema",
          "parameter",
          "component",
          "route"
        ];
        this.definitions.sort((left, right) => {
          if (!("type" in left)) {
            if (!("type" in right)) {
              return 0;
            }
            return -1;
          }
          if (!("type" in right)) {
            return 1;
          }
          const leftIndex = generationOrder.findIndex((type) => type === left.type);
          const rightIndex = generationOrder.findIndex((type) => type === right.type);
          return leftIndex - rightIndex;
        });
      }
      generateSingle(definition) {
        if (!("type" in definition)) {
          this.generateSchema(definition);
          return;
        }
        switch (definition.type) {
          case "parameter":
            this.generateParameterDefinition(definition.schema);
            return;
          case "schema":
            this.generateSchema(definition.schema);
            return;
          case "route":
            this.generateSingleRoute(definition.route);
            return;
          case "component":
            this.rawComponents.push(definition);
            return;
        }
      }
      generateParameterDefinition(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateParameter(zodSchema);
        if (refId) {
          this.paramRefs[refId] = result;
        }
        return result;
      }
      getParameterRef(schemaMetadata, external) {
        var _a89, _b2, _c2, _d, _e2;
        const parameterMetadata = (_a89 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.param;
        const existingRef = ((_b2 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? this.paramRefs[(_c2 = schemaMetadata._internal) === null || _c2 === void 0 ? void 0 : _c2.refId] : void 0;
        if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
          return void 0;
        }
        if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
          throw new errors_1.ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
            key: "in",
            values: (0, lodash_1.compact)([
              existingRef.in,
              external === null || external === void 0 ? void 0 : external.in,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
            ])
          });
        }
        if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
          throw new errors_1.ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: (0, lodash_1.compact)([
              existingRef.name,
              external === null || external === void 0 ? void 0 : external.name,
              parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
            ])
          });
        }
        return {
          $ref: `#/components/parameters/${(_e2 = schemaMetadata._internal) === null || _e2 === void 0 ? void 0 : _e2.refId}`
        };
      }
      generateInlineParameters(zodSchema, location) {
        var _a89;
        const metadata = this.getMetadata(zodSchema);
        const parameterMetadata = (_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.param;
        const referencedSchema = this.getParameterRef(metadata, { in: location });
        if (referencedSchema) {
          return [referencedSchema];
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodObject")) {
          const propTypes = zodSchema._def.shape();
          const parameters = Object.entries(propTypes).map(([key, schema4]) => {
            var _a90, _b2;
            const innerMetadata = this.getMetadata(schema4);
            const referencedSchema2 = this.getParameterRef(innerMetadata, {
              in: location,
              name: key
            });
            if (referencedSchema2) {
              return referencedSchema2;
            }
            const innerParameterMetadata = (_a90 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a90 === void 0 ? void 0 : _a90.param;
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
              throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                key: "name",
                values: [key, innerParameterMetadata.name]
              });
            }
            if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
              throw new errors_1.ConflictError(`Conflicting location for parameter ${(_b2 = innerParameterMetadata.name) !== null && _b2 !== void 0 ? _b2 : key}`, {
                key: "in",
                values: [location, innerParameterMetadata.in]
              });
            }
            return this.generateParameter(schema4.openapi({ param: { name: key, in: location } }));
          });
          return parameters;
        }
        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
          throw new errors_1.ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
            key: "in",
            values: [location, parameterMetadata.in]
          });
        }
        return [
          this.generateParameter(zodSchema.openapi({ param: { in: location } }))
        ];
      }
      generateSimpleParameter(zodSchema) {
        var _a89;
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = (_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.param;
        const required = !this.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
        const schema4 = this.generateSchemaWithRef(zodSchema);
        return Object.assign({
          schema: schema4,
          required
        }, paramMetadata ? this.buildParameterMetadata(paramMetadata) : {});
      }
      generateParameter(zodSchema) {
        var _a89;
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = (_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.param;
        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
        if (!paramName) {
          throw new errors_1.MissingParameterDataError({ missingField: "name" });
        }
        if (!paramLocation) {
          throw new errors_1.MissingParameterDataError({
            missingField: "in",
            paramName
          });
        }
        const baseParameter = this.generateSimpleParameter(zodSchema);
        return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
      }
      generateSchemaWithMetadata(zodSchema) {
        var _a89;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = this.getMetadata(zodSchema);
        const defaultValue = this.getDefaultValue(zodSchema);
        const result = ((_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.type) ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata) ? this.applySchemaMetadata(result, metadata.metadata) : (0, lodash_1.omitBy)(result, lodash_1.isNil);
      }
      /**
       * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
       */
      generateSimpleSchema(zodSchema) {
        var _a89;
        const metadata = this.getMetadata(zodSchema);
        const refId = this.getRefId(zodSchema);
        if (!refId || !this.schemaRefs[refId]) {
          return this.generateSchemaWithMetadata(zodSchema);
        }
        const schemaRef = this.schemaRefs[refId];
        const referenceObject = {
          $ref: this.generateSchemaRef(refId)
        };
        const newMetadata = (0, lodash_1.omitBy)(this.buildSchemaMetadata((_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a89 !== void 0 ? _a89 : {}), (value, key) => value === void 0 || (0, lodash_1.objectEquals)(value, schemaRef[key]));
        if (newMetadata.type) {
          return {
            allOf: [referenceObject, newMetadata]
          };
        }
        const newSchemaMetadata = (0, lodash_1.omitBy)(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === void 0 || (0, lodash_1.objectEquals)(value, schemaRef[key]));
        const appliedMetadata = this.applySchemaMetadata(newSchemaMetadata, newMetadata);
        if (Object.keys(appliedMetadata).length > 0) {
          return {
            allOf: [referenceObject, appliedMetadata]
          };
        }
        return referenceObject;
      }
      /**
       * Generates a whole OpenApi schema and saves it into
       * schemaRefs if a `refId` is provided.
       */
      generateSchema(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateSimpleSchema(zodSchema);
        if (refId && this.schemaRefs[refId] === void 0) {
          this.schemaRefs[refId] = result;
        }
        return result;
      }
      /**
       * Same as `generateSchema` but if the new schema is added into the
       * referenced schemas, it would return a ReferenceObject and not the
       * whole result.
       *
       * Should be used for nested objects, arrays, etc.
       */
      generateSchemaWithRef(zodSchema) {
        const refId = this.getRefId(zodSchema);
        const result = this.generateSimpleSchema(zodSchema);
        if (refId && this.schemaRefs[refId] === void 0) {
          this.schemaRefs[refId] = result;
          return { $ref: this.generateSchemaRef(refId) };
        }
        return result;
      }
      generateSchemaRef(refId) {
        return `#/components/schemas/${refId}`;
      }
      getRequestBody(requestBody) {
        if (!requestBody) {
          return;
        }
        const { content } = requestBody, rest = __rest(requestBody, ["content"]);
        const requestBodyContent = this.getBodyContent(content);
        return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
      }
      getParameters(request) {
        if (!request) {
          return [];
        }
        const { query, params, headers, cookies } = request;
        const queryParameters = this.enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
        const pathParameters = this.enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
        const cookieParameters = this.enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
        const headerParameters = this.enhanceMissingParametersError(() => headers ? (0, zod_is_type_1.isZodType)(headers, "ZodObject") ? this.generateInlineParameters(headers, "header") : headers.flatMap((header) => this.generateInlineParameters(header, "header")) : [], { location: "header" });
        return [
          ...pathParameters,
          ...queryParameters,
          ...headerParameters,
          ...cookieParameters
        ];
      }
      generatePath(route) {
        const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
        const generatedResponses = (0, lodash_1.mapValues)(responses, (response) => {
          return this.getResponse(response);
        });
        const parameters = this.enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
        const routeDoc = {
          [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
            parameters: [...pathItemConfig.parameters || [], ...parameters]
          } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
        };
        return routeDoc;
      }
      generateSingleRoute(route) {
        const routeDoc = this.generatePath(route);
        this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
        return routeDoc;
      }
      getResponse(_a89) {
        var { content, headers } = _a89, rest = __rest(_a89, ["content", "headers"]);
        const responseContent = content ? { content: this.getBodyContent(content) } : {};
        if (!headers) {
          return Object.assign(Object.assign({}, rest), responseContent);
        }
        const responseHeaders = (0, zod_is_type_1.isZodType)(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
          // This is input data so it is okay to cast in the common generator
          // since this is the user's responsibility to keep it correct
          headers
        );
        return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
      }
      getResponseHeaders(headers) {
        const schemaShape = headers._def.shape();
        const responseHeaders = (0, lodash_1.mapValues)(schemaShape, (_) => this.generateSimpleParameter(_));
        return responseHeaders;
      }
      getBodyContent(content) {
        return (0, lodash_1.mapValues)(content, (config) => {
          if (!(0, zod_is_type_1.isAnyZodType)(config.schema)) {
            return config;
          }
          const { schema: configSchema } = config, rest = __rest(config, ["schema"]);
          const schema4 = this.generateSchemaWithRef(configSchema);
          return Object.assign({ schema: schema4 }, rest);
        });
      }
      getZodStringCheck(zodString, kind) {
        return zodString._def.checks.find((check2) => {
          return check2.kind === kind;
        });
      }
      /**
       * Attempts to map Zod strings to known formats
       * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
       */
      mapStringFormat(zodString) {
        if (zodString.isUUID) {
          return "uuid";
        }
        if (zodString.isEmail) {
          return "email";
        }
        if (zodString.isURL) {
          return "uri";
        }
        if (zodString.isDatetime) {
          return "date-time";
        }
        return void 0;
      }
      mapDiscriminator(zodObjects, discriminator) {
        if (zodObjects.some((obj) => this.getRefId(obj) === void 0)) {
          return void 0;
        }
        const mapping = {};
        zodObjects.forEach((obj) => {
          var _a89;
          const refId = this.getRefId(obj);
          const value = (_a89 = obj.shape) === null || _a89 === void 0 ? void 0 : _a89[discriminator];
          if ((0, zod_is_type_1.isZodType)(value, "ZodEnum")) {
            value._def.values.forEach((enumValue) => {
              mapping[enumValue] = this.generateSchemaRef(refId);
            });
            return;
          }
          const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
          if (typeof literalValue !== "string") {
            throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
          }
          mapping[literalValue] = this.generateSchemaRef(refId);
        });
        return {
          propertyName: discriminator,
          mapping
        };
      }
      mapNullableOfArray(objects, isNullable) {
        return this.versionSpecifics.mapNullableOfArray(objects, isNullable);
      }
      mapNullableType(type, isNullable) {
        return this.versionSpecifics.mapNullableType(type, isNullable);
      }
      getNumberChecks(checks) {
        return this.versionSpecifics.getNumberChecks(checks);
      }
      constructReferencedOpenAPISchema(zodSchema) {
        var _a89;
        const metadata = this.getMetadata(zodSchema);
        const innerSchema = this.unwrapChained(zodSchema);
        const defaultValue = this.getDefaultValue(zodSchema);
        const isNullableSchema = zodSchema.isNullable();
        if ((_a89 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a89 === void 0 ? void 0 : _a89.type) {
          return this.mapNullableType(metadata.metadata.type, isNullableSchema);
        }
        return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
      }
      toOpenAPISchema(zodSchema, isNullable, defaultValue) {
        var _a89, _b2, _c2, _d, _e2;
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNull")) {
          return this.versionSpecifics.nullType;
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodString")) {
          const regexCheck = this.getZodStringCheck(zodSchema, "regex");
          const length = (_a89 = this.getZodStringCheck(zodSchema, "length")) === null || _a89 === void 0 ? void 0 : _a89.value;
          const maxLength = Number.isFinite(zodSchema.minLength) ? (_b2 = zodSchema.minLength) !== null && _b2 !== void 0 ? _b2 : void 0 : void 0;
          const minLength = Number.isFinite(zodSchema.maxLength) ? (_c2 = zodSchema.maxLength) !== null && _c2 !== void 0 ? _c2 : void 0 : void 0;
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), {
            // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
            minLength: length !== null && length !== void 0 ? length : maxLength,
            maxLength: length !== null && length !== void 0 ? length : minLength,
            format: this.mapStringFormat(zodSchema),
            pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source,
            default: defaultValue
          });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNumber")) {
          return Object.assign(Object.assign(Object.assign({}, this.mapNullableType(zodSchema.isInt ? "integer" : "number", isNullable)), this.getNumberChecks(zodSchema._def.checks)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodBoolean")) {
          return Object.assign(Object.assign({}, this.mapNullableType("boolean", isNullable)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          const innerSchema = zodSchema._def.schema;
          return this.generateSchema(innerSchema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodLiteral")) {
          return Object.assign(Object.assign({}, this.mapNullableType(typeof zodSchema._def.value, isNullable)), { enum: [zodSchema._def.value], default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEnum")) {
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), { enum: zodSchema._def.values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodNativeEnum")) {
          const { type, values } = (0, enum_info_1.enumInfo)(zodSchema._def.values);
          if (type === "mixed") {
            throw new errors_1.ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
          }
          return Object.assign(Object.assign({}, this.mapNullableType(type === "numeric" ? "integer" : "string", isNullable)), { enum: values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodObject")) {
          return this.toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodArray")) {
          const itemType = zodSchema._def.type;
          return Object.assign(Object.assign({}, this.mapNullableType("array", isNullable)), { items: this.generateSchemaWithRef(itemType), minItems: (_d = zodSchema._def.minLength) === null || _d === void 0 ? void 0 : _d.value, maxItems: (_e2 = zodSchema._def.maxLength) === null || _e2 === void 0 ? void 0 : _e2.value, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodTuple")) {
          const { items } = zodSchema._def;
          const tupleLength = items.length;
          const schemas2 = items.map((schema4) => this.generateSchemaWithRef(schema4));
          const uniqueSchemas = (0, lodash_1.uniq)(schemas2);
          if (uniqueSchemas.length === 1) {
            return {
              type: "array",
              items: uniqueSchemas[0],
              minItems: tupleLength,
              maxItems: tupleLength
            };
          }
          return Object.assign(Object.assign({}, this.mapNullableType("array", isNullable)), { items: {
            anyOf: uniqueSchemas
          }, minItems: tupleLength, maxItems: tupleLength });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodUnion")) {
          const options = this.flattenUnionTypes(zodSchema);
          const schemas2 = options.map((schema4) => {
            const optionToGenerate = this.unwrapNullable(schema4);
            return this.generateSchemaWithRef(optionToGenerate);
          });
          return {
            anyOf: this.mapNullableOfArray(schemas2, isNullable),
            default: defaultValue
          };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDiscriminatedUnion")) {
          const options = [...zodSchema.options.values()];
          const optionSchema = options.map((schema4) => this.generateSchemaWithRef(schema4));
          if (isNullable) {
            return {
              oneOf: this.mapNullableOfArray(optionSchema, isNullable),
              default: defaultValue
            };
          }
          return {
            oneOf: optionSchema,
            discriminator: this.mapDiscriminator(options, zodSchema.discriminator),
            default: defaultValue
          };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodIntersection")) {
          const subtypes = this.flattenIntersectionTypes(zodSchema);
          const allOfSchema = {
            allOf: subtypes.map((schema4) => this.generateSchemaWithRef(schema4))
          };
          if (isNullable) {
            return {
              anyOf: this.mapNullableOfArray([allOfSchema], isNullable),
              default: defaultValue
            };
          }
          return Object.assign(Object.assign({}, allOfSchema), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodRecord")) {
          const propertiesType = zodSchema._def.valueType;
          return Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { additionalProperties: this.generateSchemaWithRef(propertiesType), default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodUnknown") || (0, zod_is_type_1.isZodType)(zodSchema, "ZodAny")) {
          return this.mapNullableType(void 0, isNullable);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDate")) {
          return Object.assign(Object.assign({}, this.mapNullableType("string", isNullable)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodPipeline")) {
          return this.toOpenAPISchema(zodSchema._def.in, isNullable, defaultValue);
        }
        const refId = this.getRefId(zodSchema);
        throw new errors_1.UnknownZodTypeError({
          currentSchema: zodSchema._def,
          schemaName: refId
        });
      }
      isOptionalSchema(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          return this.isOptionalSchema(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDefault")) {
          return this.isOptionalSchema(zodSchema._def.innerType);
        }
        return zodSchema.isOptional();
      }
      getDefaultValue(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodOptional") || (0, zod_is_type_1.isZodType)(zodSchema, "ZodNullable")) {
          return this.getDefaultValue(zodSchema.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodEffects")) {
          return this.getDefaultValue(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, "ZodDefault")) {
          return zodSchema._def.defaultValue();
        }
        return void 0;
      }
      requiredKeysOf(objectSchema) {
        return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !this.isOptionalSchema(type)).map(([key, _type]) => key);
      }
      toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue) {
        var _a89;
        const extendedFrom = (_a89 = this.getInternalMetadata(zodSchema)) === null || _a89 === void 0 ? void 0 : _a89.extendedFrom;
        const required = this.requiredKeysOf(zodSchema);
        const properties = (0, lodash_1.mapValues)(zodSchema._def.shape(), (_) => this.generateSchemaWithRef(_));
        if (!extendedFrom) {
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { default: defaultValue, properties }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema));
        }
        const parent = extendedFrom.schema;
        this.generateSchema(parent);
        const keysRequiredByParent = this.requiredKeysOf(parent);
        const propsOfParent = (0, lodash_1.mapValues)(parent === null || parent === void 0 ? void 0 : parent._def.shape(), (_) => this.generateSchemaWithRef(_));
        const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
          return !(0, lodash_1.objectEquals)(propsOfParent[key], type);
        }));
        const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
        const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, this.mapNullableType("object", isNullable)), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema));
        return {
          allOf: [
            { $ref: `#/components/schemas/${extendedFrom.refId}` },
            objectData
          ]
        };
      }
      generateAdditionalProperties(zodSchema) {
        const unknownKeysOption = zodSchema._def.unknownKeys;
        const catchallSchema = zodSchema._def.catchall;
        if ((0, zod_is_type_1.isZodType)(catchallSchema, "ZodNever")) {
          if (unknownKeysOption === "strict") {
            return { additionalProperties: false };
          }
          return {};
        }
        return { additionalProperties: this.generateSchemaWithRef(catchallSchema) };
      }
      flattenUnionTypes(schema4) {
        if (!(0, zod_is_type_1.isZodType)(schema4, "ZodUnion")) {
          return [schema4];
        }
        const options = schema4._def.options;
        return options.flatMap((option) => this.flattenUnionTypes(option));
      }
      flattenIntersectionTypes(schema4) {
        if (!(0, zod_is_type_1.isZodType)(schema4, "ZodIntersection")) {
          return [schema4];
        }
        const leftSubTypes = this.flattenIntersectionTypes(schema4._def.left);
        const rightSubTypes = this.flattenIntersectionTypes(schema4._def.right);
        return [...leftSubTypes, ...rightSubTypes];
      }
      unwrapNullable(schema4) {
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodNullable")) {
          return this.unwrapNullable(schema4.unwrap());
        }
        return schema4;
      }
      unwrapChained(schema4) {
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodOptional") || (0, zod_is_type_1.isZodType)(schema4, "ZodNullable") || (0, zod_is_type_1.isZodType)(schema4, "ZodBranded")) {
          return this.unwrapChained(schema4.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodDefault")) {
          return this.unwrapChained(schema4._def.innerType);
        }
        if ((0, zod_is_type_1.isZodType)(schema4, "ZodEffects")) {
          return this.unwrapChained(schema4._def.schema);
        }
        return schema4;
      }
      /**
       * A method that omits all custom keys added to the regular OpenAPI
       * metadata properties
       */
      buildSchemaMetadata(metadata) {
        return (0, lodash_1.omitBy)((0, lodash_1.omit)(metadata, ["param"]), lodash_1.isNil);
      }
      buildParameterMetadata(metadata) {
        return (0, lodash_1.omitBy)(metadata, lodash_1.isNil);
      }
      getMetadata(zodSchema) {
        var _a89;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        const zodDescription = (_a89 = zodSchema.description) !== null && _a89 !== void 0 ? _a89 : innerSchema.description;
        return {
          _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
          metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
        };
      }
      getInternalMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
        return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
      }
      getRefId(zodSchema) {
        var _a89;
        return (_a89 = this.getInternalMetadata(zodSchema)) === null || _a89 === void 0 ? void 0 : _a89.refId;
      }
      applySchemaMetadata(initialData, metadata) {
        return (0, lodash_1.omitBy)(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), lodash_1.isNil);
      }
      enhanceMissingParametersError(action, paramsToAdd) {
        try {
          return action();
        } catch (error) {
          if (error instanceof errors_1.MissingParameterDataError) {
            throw new errors_1.MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
          }
          throw error;
        }
      }
    };
    exports.OpenAPIGenerator = OpenAPIGenerator;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/specifics.js
var require_specifics = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/specifics.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV30Specifics = void 0;
    var OpenApiGeneratorV30Specifics = class {
      get nullType() {
        return { nullable: true };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check2) => {
          switch (check2.kind) {
            case "min":
              return check2.inclusive ? { minimum: check2.value } : { minimum: check2.value, exclusiveMinimum: true };
            case "max":
              return check2.inclusive ? { maximum: check2.value } : { maximum: check2.value, exclusiveMaximum: true };
            default:
              return {};
          }
        }));
      }
    };
    exports.OpenApiGeneratorV30Specifics = OpenApiGeneratorV30Specifics;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/openapi-generator.js
var require_openapi_generator2 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.0/openapi-generator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV3 = void 0;
    var openapi_generator_1 = require_openapi_generator();
    var specifics_1 = require_specifics();
    var OpenApiGeneratorV3 = class {
      constructor(definitions) {
        const specifics = new specifics_1.OpenApiGeneratorV30Specifics();
        this.generator = new openapi_generator_1.OpenAPIGenerator(definitions, specifics);
      }
      generateDocument(config) {
        const baseData = this.generator.generateDocumentData();
        return Object.assign(Object.assign({}, config), baseData);
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
    };
    exports.OpenApiGeneratorV3 = OpenApiGeneratorV3;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/specifics.js
var require_specifics2 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/specifics.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31Specifics = void 0;
    var OpenApiGeneratorV31Specifics = class {
      get nullType() {
        return { type: "null" };
      }
      mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
          return [...objects, this.nullType];
        }
        return objects;
      }
      mapNullableType(type, isNullable) {
        if (!type) {
          return {};
        }
        if (isNullable) {
          return {
            type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
          };
        }
        return {
          type
        };
      }
      getNumberChecks(checks) {
        return Object.assign({}, ...checks.map((check2) => {
          switch (check2.kind) {
            case "min":
              return check2.inclusive ? { minimum: check2.value } : { exclusiveMinimum: check2.value };
            case "max":
              return check2.inclusive ? { maximum: check2.value } : { exclusiveMaximum: check2.value };
            default:
              return {};
          }
        }));
      }
    };
    exports.OpenApiGeneratorV31Specifics = OpenApiGeneratorV31Specifics;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/openapi-generator.js
var require_openapi_generator3 = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/v3.1/openapi-generator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31 = void 0;
    var openapi_generator_1 = require_openapi_generator();
    var specifics_1 = require_specifics2();
    function isWebhookDefinition(definition) {
      return "type" in definition && definition.type === "webhook";
    }
    var OpenApiGeneratorV31 = class {
      constructor(definitions) {
        this.definitions = definitions;
        this.webhookRefs = {};
        const specifics = new specifics_1.OpenApiGeneratorV31Specifics();
        this.generator = new openapi_generator_1.OpenAPIGenerator(this.definitions, specifics);
      }
      generateDocument(config) {
        const baseDocument = this.generator.generateDocumentData();
        this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
        return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
      }
      generateComponents() {
        return this.generator.generateComponents();
      }
      generateSingleWebhook(route) {
        const routeDoc = this.generator.generatePath(route);
        this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
        return routeDoc;
      }
    };
    exports.OpenApiGeneratorV31 = OpenApiGeneratorV31;
  }
});

// node_modules/@asteasolutions/zod-to-openapi/dist/index.js
var require_dist = __commonJS({
  "node_modules/@asteasolutions/zod-to-openapi/dist/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc2 || ("get" in desc2 ? !m3.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenApiGeneratorV31 = exports.OpenApiGeneratorV3 = exports.OpenAPIV31 = exports.OpenAPIV3 = exports.OpenAPIRegistry = exports.extendZodWithOpenApi = void 0;
    var zod_extensions_1 = require_zod_extensions();
    Object.defineProperty(exports, "extendZodWithOpenApi", { enumerable: true, get: function() {
      return zod_extensions_1.extendZodWithOpenApi;
    } });
    __exportStar(require_openapi_metadata(), exports);
    var openapi_registry_1 = require_openapi_registry();
    Object.defineProperty(exports, "OpenAPIRegistry", { enumerable: true, get: function() {
      return openapi_registry_1.OpenAPIRegistry;
    } });
    exports.OpenAPIV3 = __importStar(require_oas30());
    exports.OpenAPIV31 = __importStar(require_oas31());
    var openapi_generator_1 = require_openapi_generator2();
    Object.defineProperty(exports, "OpenApiGeneratorV3", { enumerable: true, get: function() {
      return openapi_generator_1.OpenApiGeneratorV3;
    } });
    var openapi_generator_2 = require_openapi_generator3();
    Object.defineProperty(exports, "OpenApiGeneratorV31", { enumerable: true, get: function() {
      return openapi_generator_2.OpenApiGeneratorV31;
    } });
  }
});

// node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index2, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key = sourceKeys[index2];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string2, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string2;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject2;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    function formatError(exception, compact) {
      var where = "", message3 = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message3;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message3 + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var common = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string2, max) {
      return common.repeat(" ", max - string2.length) + string2;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i2, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i2 = 1; i2 <= options.linesBefore; i2++) {
        if (foundLineNo - i2 < 0)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i2],
          lineEnds[foundLineNo - i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i2 = 1; i2 <= options.linesAfter; i2++) {
        if (foundLineNo + i2 >= lineEnds.length)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i2],
          lineEnds[foundLineNo + i2],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map2) {
      var result = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema4, name) {
      var result = [];
      schema4[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index2, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema3(definition) {
      return this.extend(definition);
    }
    Schema3.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema3.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module.exports = Schema3;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Schema3 = require_schema();
    module.exports = new Schema3({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull2(object) {
      return object === null;
    }
    module.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var common = require_common();
    var Type = require_type();
    function isHexCode(c3) {
      return 48 <= c3 && c3 <= 57 || 65 <= c3 && c3 <= 70 || 97 <= c3 && c3 <= 102;
    }
    function isOctCode(c3) {
      return 48 <= c3 && c3 <= 55;
    }
    function isDecCode(c3) {
      return 48 <= c3 && c3 <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index2 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index2];
      if (ch === "-" || ch === "+") {
        ch = data[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max)
          return true;
        ch = data[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign2 = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign2 = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign2 * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign2 * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign2 * parseInt(value.slice(2), 8);
      }
      return sign2 * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign2;
      value = data.replace(/_/g, "").toLowerCase();
      sign2 = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign2 * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year2, month, day2, hour2, minute2, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year2 = +match[1];
      month = +match[2] - 1;
      day2 = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year2, month, day2));
      }
      hour2 = +match[4];
      minute2 = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year2, month, day2, hour2, minute2, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map2.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map2[bits >> 18 & 63];
          result += map2[bits >> 12 & 63];
          result += map2[bits >> 6 & 63];
          result += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      } else if (tail === 2) {
        result += map2[bits >> 10 & 63];
        result += map2[bits >> 4 & 63];
        result += map2[bits << 2 & 63];
        result += map2[64];
      } else if (tail === 1) {
        result += map2[bits >> 2 & 63];
        result += map2[bits << 4 & 63];
        result += map2[64];
        result += map2[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        keys = Object.keys(pair);
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c3) {
      return c3 === 10 || c3 === 13;
    }
    function is_WHITE_SPACE(c3) {
      return c3 === 9 || c3 === 32;
    }
    function is_WS_OR_EOL(c3) {
      return c3 === 9 || c3 === 32 || c3 === 10 || c3 === 13;
    }
    function is_FLOW_INDICATOR(c3) {
      return c3 === 44 || c3 === 91 || c3 === 93 || c3 === 123 || c3 === 125;
    }
    function fromHexCode(c3) {
      var lc2;
      if (48 <= c3 && c3 <= 57) {
        return c3 - 48;
      }
      lc2 = c3 | 32;
      if (97 <= lc2 && lc2 <= 102) {
        return lc2 - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c3) {
      if (c3 === 120) {
        return 2;
      }
      if (c3 === 117) {
        return 4;
      }
      if (c3 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c3) {
      if (48 <= c3 && c3 <= 57) {
        return c3 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c3) {
      return c3 === 48 ? "\0" : c3 === 97 ? "\x07" : c3 === 98 ? "\b" : c3 === 116 ? "	" : c3 === 9 ? "	" : c3 === 110 ? "\n" : c3 === 118 ? "\v" : c3 === 102 ? "\f" : c3 === 114 ? "\r" : c3 === 101 ? "\x1B" : c3 === 32 ? " " : c3 === 34 ? '"' : c3 === 47 ? "/" : c3 === 92 ? "\\" : c3 === 78 ? "\x85" : c3 === 95 ? "\xA0" : c3 === 76 ? "\u2028" : c3 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c3) {
      if (c3 <= 65535) {
        return String.fromCharCode(c3);
      }
      return String.fromCharCode(
        (c3 - 65536 >> 10) + 55296,
        (c3 - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
      simpleEscapeMap[i2] = simpleEscapeSequence(i2);
    }
    var i2;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message3) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message3, mark);
    }
    function throwError(state, message3) {
      throw generateError(state, message3);
    }
    function throwWarning(state, message3) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message3));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index2, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair2, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair2 = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair2 = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode2(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair2 = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode2(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair2) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode2(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode2(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode2(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode2(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode2(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema4, map2) {
      var result, keys, index2, length, tag, style, type;
      if (map2 === null)
        return {};
      result = {};
      keys = Object.keys(map2);
      for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
        tag = keys[index2];
        style = String(map2[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema4.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string2, handle, length;
      string2 = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string2.length) + string2;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string2, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
      while (position < length) {
        next = string2.indexOf("\n", position);
        if (next === -1) {
          line = string2.slice(position);
          position = length;
        } else {
          line = string2.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c3) {
      return c3 === CHAR_SPACE || c3 === CHAR_TAB;
    }
    function isPrintable(c3) {
      return 32 <= c3 && c3 <= 126 || 161 <= c3 && c3 <= 55295 && c3 !== 8232 && c3 !== 8233 || 57344 <= c3 && c3 <= 65533 && c3 !== CHAR_BOM || 65536 <= c3 && c3 <= 1114111;
    }
    function isNsCharOrWhitespace(c3) {
      return isPrintable(c3) && c3 !== CHAR_BOM && c3 !== CHAR_CARRIAGE_RETURN && c3 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c3, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c3);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c3);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET) && c3 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c3 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c3) {
      return isPrintable(c3) && c3 !== CHAR_BOM && !isWhitespace(c3) && c3 !== CHAR_MINUS && c3 !== CHAR_QUESTION && c3 !== CHAR_COLON && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET && c3 !== CHAR_SHARP && c3 !== CHAR_AMPERSAND && c3 !== CHAR_ASTERISK && c3 !== CHAR_EXCLAMATION && c3 !== CHAR_VERTICAL_LINE && c3 !== CHAR_EQUALS && c3 !== CHAR_GREATER_THAN && c3 !== CHAR_SINGLE_QUOTE && c3 !== CHAR_DOUBLE_QUOTE && c3 !== CHAR_PERCENT && c3 !== CHAR_COMMERCIAL_AT && c3 !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c3) {
      return !isWhitespace(c3) && c3 !== CHAR_COLON;
    }
    function codePointAt(string2, pos) {
      var first = string2.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
        second = string2.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string2) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string2);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i2;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string2, i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string2, i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string2)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string2)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string2, level, iskey, inblock) {
      state.dump = function() {
        if (string2.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string3) {
          return testImplicitResolving(state, string3);
        }
        switch (chooseScalarStyle(
          string2,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string2;
          case STYLE_SINGLE:
            return "'" + string2.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string2, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string2, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
      var clip = string2[string2.length - 1] === "\n";
      var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string2) {
      return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
    }
    function foldString(string2, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string2.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string2.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string2.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string2)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string2) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i2 = 0; i2 < string2.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string2, i2);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string2[i2];
          if (char >= 65536)
            result += string2[i2 + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index2, length, value;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        value = object[index2];
        if (state.replacer) {
          value = state.replacer.call(object, String(index2), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    module.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to2) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to2 + " instead, which is now safe by default.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core();
    module.exports.DEFAULT_SCHEMA = require_default();
    module.exports.load = loader.load;
    module.exports.loadAll = loader.loadAll;
    module.exports.dump = dumper.dump;
    module.exports.YAMLException = require_exception();
    module.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module.exports.safeLoad = renamed("safeLoad", "load");
    module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/serialize-error/index.js
var require_serialize_error = __commonJS({
  "node_modules/serialize-error/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var NonError = class extends Error {
      constructor(message3) {
        super(NonError._prepareSuperMessage(message3));
        Object.defineProperty(this, "name", {
          value: "NonError",
          configurable: true,
          writable: true
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, NonError);
        }
      }
      static _prepareSuperMessage(message3) {
        try {
          return JSON.stringify(message3);
        } catch {
          return String(message3);
        }
      }
    };
    var commonProperties = [
      { property: "name", enumerable: false },
      { property: "message", enumerable: false },
      { property: "stack", enumerable: false },
      { property: "code", enumerable: true }
    ];
    var isCalled = Symbol(".toJSON called");
    var toJSON = (from) => {
      from[isCalled] = true;
      const json = from.toJSON();
      delete from[isCalled];
      return json;
    };
    var destroyCircular = ({
      from,
      seen,
      to_,
      forceEnumerable,
      maxDepth,
      depth
    }) => {
      const to2 = to_ || (Array.isArray(from) ? [] : {});
      seen.push(from);
      if (depth >= maxDepth) {
        return to2;
      }
      if (typeof from.toJSON === "function" && from[isCalled] !== true) {
        return toJSON(from);
      }
      for (const [key, value] of Object.entries(from)) {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          to2[key] = "[object Buffer]";
          continue;
        }
        if (typeof value === "function") {
          continue;
        }
        if (!value || typeof value !== "object") {
          to2[key] = value;
          continue;
        }
        if (!seen.includes(from[key])) {
          depth++;
          to2[key] = destroyCircular({
            from: from[key],
            seen: seen.slice(),
            forceEnumerable,
            maxDepth,
            depth
          });
          continue;
        }
        to2[key] = "[Circular]";
      }
      for (const { property, enumerable } of commonProperties) {
        if (typeof from[property] === "string") {
          Object.defineProperty(to2, property, {
            value: from[property],
            enumerable: forceEnumerable ? true : enumerable,
            configurable: true,
            writable: true
          });
        }
      }
      return to2;
    };
    var serializeError2 = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (typeof value === "object" && value !== null) {
        return destroyCircular({
          from: value,
          seen: [],
          forceEnumerable: true,
          maxDepth,
          depth: 0
        });
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      return value;
    };
    var deserializeError = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (value instanceof Error) {
        return value;
      }
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const newError = new Error();
        destroyCircular({
          from: value,
          seen: [],
          to_: newError,
          maxDepth,
          depth: 0
        });
        return newError;
      }
      return new NonError(value);
    };
    module.exports = {
      serializeError: serializeError2,
      deserializeError
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    exports.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/digest.js
var digest, digest_default;
var init_digest = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/digest.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    digest = async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    };
    digest_default = digest;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i2 = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i2);
    i2 += buffer.length;
  });
  return buf;
}
function p2s(alg, p2sInput) {
  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf = new Uint8Array(4 + secret.length + value.length);
    buf.set(uint32be(iter + 1));
    buf.set(secret, 4);
    buf.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_digest();
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode2, decodeBase64, decode;
var init_base64url = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i2 = 0; i2 < unencoded.length; i2 += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i2, i2 + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode2 = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary2 = atob(encoded);
      const bytes = new Uint8Array(binary2.length);
      for (let i2 = 0; i2 < binary2.length; i2++) {
        bytes[i2] = binary2.charCodeAt(i2);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a89) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/errors.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message3) {
        var _a89;
        super(message3);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a89 = Error.captureStackTrace) === null || _a89 === void 0 ? void 0 : _a89.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message3, claim = "unspecified", reason = "unspecified") {
        super(message3);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message3, claim = "unspecified", reason = "unspecified") {
        super(message3);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/random.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/iv.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    init_random();
    iv_default = (alg) => random_default(new Uint8Array(bitLength(alg) >> 3));
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength, check_iv_length_default;
var init_check_iv_length = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    init_iv();
    checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    };
    check_iv_length_default = checkIvLength;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/check_cek_length.js
var checkCekLength, check_cek_length_default;
var init_check_cek_length = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    checkCekLength = (cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    };
    check_cek_length_default = checkCekLength;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var timingSafeEqual2, timing_safe_equal_default;
var init_timing_safe_equal = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    timingSafeEqual2 = (a2, b3) => {
      if (!(a2 instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b3 instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a2.length !== b3.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a2.length;
      let out = 0;
      let i2 = -1;
      while (++i2 < len) {
        out |= a2[i2] ^ b3[i2];
      }
      return out === 0;
    };
    timing_safe_equal_default = timingSafeEqual2;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/crypto_key.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag, expectedTag);
  } catch (_a89) {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch (_b2) {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag)));
  } catch (_a89) {
    throw new JWEDecryptionFailed();
  }
}
var decrypt, decrypt_default;
var init_decrypt = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors2();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    decrypt_default = decrypt;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/zlib.js
var inflate, deflate;
var init_zlib = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/zlib.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    inflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
    };
    deflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/is_object.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/bogus.js
var bogusWebCrypto, bogus_default;
var init_bogus = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/bogus.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var wrap, unwrap;
var init_aeskw = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    wrap = async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    };
    unwrap = async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/ecdhes.js
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_p2s.js
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt, decrypt2;
var init_pbes2kw = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    encrypt = async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode2(p2s2) };
    };
    decrypt2 = async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/subtle_rsaes.js
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2, decrypt3;
var init_rsaes = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    };
    decrypt3 = async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/cek.js
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/cek.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    init_random();
    cek_default = (alg) => random_default(new Uint8Array(bitLength2(alg) >> 3));
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/format_pem.js
var format_pem_default;
var init_format_pem = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/format_pem.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    format_pem_default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/asn1.js
function getElement(seq2) {
  let result = [];
  let next = 0;
  while (next < seq2.length) {
    let nextPart = parseElement(seq2.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes) {
  let position = 0;
  let tag = bytes[0] & 31;
  position++;
  if (tag === 31) {
    tag = 0;
    while (bytes[position] >= 128) {
      tag = tag * 128 + bytes[position] - 128;
      position++;
    }
    tag = tag * 128 + bytes[position] - 128;
    position++;
  }
  let length = 0;
  if (bytes[position] < 128) {
    length = bytes[position];
    position++;
  } else if (length === 128) {
    length = 0;
    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
      if (length > bytes.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length++;
    }
    const byteLength2 = position + length + 2;
    return {
      byteLength: byteLength2,
      contents: bytes.subarray(position, position + length),
      raw: bytes.subarray(0, byteLength2)
    };
  } else {
    let numberOfDigits = bytes[position] & 127;
    position++;
    length = 0;
    for (let i2 = 0; i2 < numberOfDigits; i2++) {
      length = length * 256 + bytes[position];
      position++;
    }
  }
  const byteLength = position + length;
  return {
    byteLength,
    contents: bytes.subarray(position, byteLength),
    raw: bytes.subarray(0, byteLength)
  };
}
function spkiFromX509(buf) {
  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
var genericExport, toSPKI, toPKCS8, findOid, getNamedCurve2, genericImport, fromPKCS8, fromSPKI, fromX509;
var init_asn1 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors2();
    init_is_key_like();
    genericExport = async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    };
    toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    findOid = (keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      let i2 = keyData.indexOf(oid[0], from);
      if (i2 === -1)
        return false;
      const sub = keyData.subarray(i2, i2 + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index2) => value === oid[index2]) || findOid(keyData, oid, i2 + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      var _a89;
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c3) => c3.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a89 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a89 !== void 0 ? _a89 : false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
    fromSPKI = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    };
    fromX509 = (pem, alg, options) => {
      let spki;
      try {
        spki = getSPKI(pem);
      } catch (cause) {
        throw new TypeError("Failed to parse the X.509 certificate", { cause });
      }
      return fromSPKI(spki, alg, options);
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse2, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    init_errors2();
    init_base64url();
    parse2 = async (jwk) => {
      var _a89, _b2;
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        (_a89 = jwk.ext) !== null && _a89 !== void 0 ? _a89 : false,
        (_b2 = jwk.key_ops) !== null && _b2 !== void 0 ? _b2 : keyUsages
      ];
      if (algorithm.name === "PBKDF2") {
        return webcrypto_default.subtle.importKey("raw", decode(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse2;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/import.js
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  return fromX509(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a89;
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a89 = jwk.ext) !== null && _a89 !== void 0 ? _a89 : false });
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/import.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors2();
    init_is_object();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/encrypt.js
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag };
}
var encrypt3, encrypt_default;
var init_encrypt = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors2();
    init_is_key_like();
    encrypt3 = async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    encrypt_default = encrypt3;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode2(iv), tag: encode2(tag) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
var init_aesgcmkw = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode(joseHeader.apu);
        } catch (_a89) {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode(joseHeader.apv);
        } catch (_b2) {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode(joseHeader.p2s);
      } catch (_c2) {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode(joseHeader.iv);
      } catch (_d) {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag;
      try {
        tag = decode(joseHeader.tag);
      } catch (_e2) {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg, key, encryptedKey, iv, tag);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors2();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    decrypt_key_management_default = decryptKeyManagement;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    validate_crit_default = validateCrit;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s2) => typeof s2 !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  var _a89;
  if (!isObject(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch (_b2) {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    if (!parsedProt || !parsedProt.zip) {
      throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    if (joseHeader.zip !== "DEF") {
      throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode(jwe.encrypted_key);
    } catch (_c2) {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  let iv;
  let tag;
  try {
    iv = decode(jwe.iv);
  } catch (_d) {
    throw new JWEInvalid("Failed to base64url decode the iv");
  }
  try {
    tag = decode(jwe.tag);
  } catch (_e2) {
    throw new JWEInvalid("Failed to base64url decode the tag");
  }
  const protectedHeader = encoder.encode((_a89 = jwe.protected) !== null && _a89 !== void 0 ? _a89 : "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode(jwe.ciphertext);
  } catch (_f) {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  let plaintext = await decrypt_default(enc, cek, ciphertext, iv, tag, additionalData);
  if (joseHeader.zip === "DEF") {
    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  }
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode(jwe.aad);
    } catch (_g) {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_decrypt();
    init_zlib();
    init_errors2();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader || void 0,
    tag: tag || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_decrypt2();
    init_errors2();
    init_buffer_utils();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/general/decrypt.js
async function generalDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch (_a89) {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_decrypt2();
    init_errors2();
    init_is_object();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode2(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/export.js
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/export.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x: x2, y: y2, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x: x2, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y2;
      if (apu)
        parameters.apu = encode2(apu);
      if (apv)
        parameters.apv = encode2(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors2();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    encrypt_key_management_default = encryptKeyManagement;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected, FlattenedEncrypt;
var init_encrypt2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_encrypt();
    init_zlib();
    init_iv();
    init_encrypt_key_management();
    init_errors2();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        if (this._aad) {
          aadMember = encode2(this._aad);
          additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
          ({ ciphertext, tag } = await encrypt_default(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: encode2(ciphertext),
          iv: encode2(this._iv),
          tag: encode2(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode2(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/general/encrypt.js
var IndividualRecipient, GeneralEncrypt;
var init_encrypt3 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encrypt2();
    init_errors2();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a89, _b2, _c2;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i2 = 0; i2 < this._recipients.length; i2++) {
          const recipient = this._recipients[i2];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = cek_default(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i2 = 0; i2 < this._recipients.length; i2++) {
          const recipient = this._recipients[i2];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i2 : void 0;
          if (i2 === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a89 = recipient.unprotectedHeader) === null || _a89 === void 0 ? void 0 : _a89.alg) || ((_b2 = this._protectedHeader) === null || _b2 === void 0 ? void 0 : _b2.alg) || ((_c2 = this._unprotectedHeader) === null || _c2 === void 0 ? void 0 : _c2.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = encode2(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/verify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch (_a89) {
        return false;
      }
    };
    verify_default = verify;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a89;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b2) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a89 = jws.protected) !== null && _a89 !== void 0 ? _a89 : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch (_c2) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_verify();
    init_errors2();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_verify2();
    init_errors2();
    init_buffer_utils();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/general/verify.js
async function generalVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch (_a89) {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_verify2();
    init_errors2();
    init_is_object();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/epoch.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/secs.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch (_a89) {
      }
      if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      if (maxTokenAge !== void 0)
        requiredClaims.push("iat");
      if (audience !== void 0)
        requiredClaims.push("aud");
      if (subject !== void 0)
        requiredClaims.push("sub");
      if (issuer !== void 0)
        requiredClaims.push("iss");
      for (const claim of new Set(requiredClaims.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a89;
  const verified = await compactVerify(jwt, key, options);
  if (((_a89 = verified.protectedHeader.crit) === null || _a89 === void 0 ? void 0 : _a89.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/verify.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_verify3();
    init_jwt_claims_set();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/decrypt.js
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_decrypt3();
    init_jwt_claims_set();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/compact/encrypt.js
var CompactEncrypt;
var init_encrypt4 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encrypt2();
    CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/sign.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors2();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode2(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode2(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/general/sign.js
var IndividualSignature, GeneralSign;
var init_sign4 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_sign2();
    init_errors2();
    IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i2 = 0; i2 < this._signatures.length; i2++) {
          const signature = this._signatures[i2];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i2 === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT;
var init_produce = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/produce.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: input };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: input };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input };
        }
        return this;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/sign.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_sign3();
    init_errors2();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a89;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a89 = this._protectedHeader) === null || _a89 === void 0 ? void 0 : _a89.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/encrypt.js
var EncryptJWT;
var init_encrypt5 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwk/thumbprint.js
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode2(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_digest();
    init_base64url();
    init_errors2();
    init_buffer_utils();
    init_is_object();
    check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwk/embedded.js
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token === null || token === void 0 ? void 0 : token.header
  };
  if (!isObject(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_import();
    init_is_object();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set2 = new LocalJWKSet(jwks);
  return async function(protectedHeader, token) {
    return set2.getKey(protectedHeader, token);
  };
}
var LocalJWKSet;
var init_local = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwks/local.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_import();
    init_errors2();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
          const error = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch (_a89) {
                continue;
              }
            }
          };
          throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors2();
    fetchJwks = async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a89) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function createRemoteJWKSet(url, options) {
  const set2 = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set2.getKey(protectedHeader, token);
  };
}
var RemoteJWKSet;
var init_remote = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwks/remote.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_fetch_jwks();
    init_errors2();
    init_local();
    RemoteJWKSet = class extends LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
          if (!isJWKSLike(json)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
          }
          this._jwks = { keys: json.keys };
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/unsecured.js
var UnsecuredJWT;
var init_unsecured = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    init_buffer_utils();
    init_errors2();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      encode() {
        const header = encode2(JSON.stringify({ alg: "none" }));
        const payload = encode2(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder.decode(decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch (_a89) {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode3
});
var encode3, decode2;
var init_base64url2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/base64url.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url();
    encode3 = encode2;
    decode2 = decode;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch (_a89) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (_a89) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b2) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors2();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/generate.js
async function generateSecret(alg, options) {
  var _a89;
  let length;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length = parseInt(alg.slice(-3), 10);
      algorithm = { name: "HMAC", hash: `SHA-${length}`, length };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-KW", length };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-GCM", length };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_a89 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a89 !== void 0 ? _a89 : false, keyUsages);
}
function getModulusLengthOption(options) {
  var _a89;
  const modulusLength = (_a89 = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a89 !== void 0 ? _a89 : 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  var _a89, _b2, _c2;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA":
      keyUsages = ["sign", "verify"];
      const crv = (_a89 = options === null || options === void 0 ? void 0 : options.crv) !== null && _a89 !== void 0 ? _a89 : "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv2 = (_b2 = options === null || options === void 0 ? void 0 : options.crv) !== null && _b2 !== void 0 ? _b2 : "P-256";
      switch (crv2) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv2 };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv2 };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_c2 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c2 !== void 0 ? _c2 : false, keyUsages);
}
var init_generate = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/generate.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_webcrypto();
    init_errors2();
    init_random();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_generate();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/generate_secret.js
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_generate();
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/runtime.js
var runtime_default;
var init_runtime = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/runtime/runtime.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    runtime_default = "WebCryptoAPI";
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/runtime.js
var runtime_default2;
var init_runtime2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/util/runtime.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_runtime();
    runtime_default2 = runtime_default;
  }
});

// ../node_modules/@upstash/qstash/node_modules/jose/dist/browser/index.js
var browser_exports2 = {};
__export(browser_exports2, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  cryptoRuntime: () => runtime_default2,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair2,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser2 = __esm({
  "../node_modules/@upstash/qstash/node_modules/jose/dist/browser/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors2();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/crypto-js/core.js
var require_core2 = __commonJS({
  "../node_modules/crypto-js/core.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder2) {
            return (encoder2 || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e3) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message3, cfg) {
              return new hasher.init(cfg).finalize(message3);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message3, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message3);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// ../node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "../node_modules/crypto-js/x64-core.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            var words = clone2.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// ../node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "../node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// ../node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "../node_modules/crypto-js/enc-utf16.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// ../node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "../node_modules/crypto-js/enc-base64.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map2 = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// ../node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "../node_modules/crypto-js/enc-base64url.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map2 = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  }
});

// ../node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "../node_modules/crypto-js/md5.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a2 = H[0];
            var b3 = H[1];
            var c3 = H[2];
            var d4 = H[3];
            a2 = FF(a2, b3, c3, d4, M_offset_0, 7, T2[0]);
            d4 = FF(d4, a2, b3, c3, M_offset_1, 12, T2[1]);
            c3 = FF(c3, d4, a2, b3, M_offset_2, 17, T2[2]);
            b3 = FF(b3, c3, d4, a2, M_offset_3, 22, T2[3]);
            a2 = FF(a2, b3, c3, d4, M_offset_4, 7, T2[4]);
            d4 = FF(d4, a2, b3, c3, M_offset_5, 12, T2[5]);
            c3 = FF(c3, d4, a2, b3, M_offset_6, 17, T2[6]);
            b3 = FF(b3, c3, d4, a2, M_offset_7, 22, T2[7]);
            a2 = FF(a2, b3, c3, d4, M_offset_8, 7, T2[8]);
            d4 = FF(d4, a2, b3, c3, M_offset_9, 12, T2[9]);
            c3 = FF(c3, d4, a2, b3, M_offset_10, 17, T2[10]);
            b3 = FF(b3, c3, d4, a2, M_offset_11, 22, T2[11]);
            a2 = FF(a2, b3, c3, d4, M_offset_12, 7, T2[12]);
            d4 = FF(d4, a2, b3, c3, M_offset_13, 12, T2[13]);
            c3 = FF(c3, d4, a2, b3, M_offset_14, 17, T2[14]);
            b3 = FF(b3, c3, d4, a2, M_offset_15, 22, T2[15]);
            a2 = GG(a2, b3, c3, d4, M_offset_1, 5, T2[16]);
            d4 = GG(d4, a2, b3, c3, M_offset_6, 9, T2[17]);
            c3 = GG(c3, d4, a2, b3, M_offset_11, 14, T2[18]);
            b3 = GG(b3, c3, d4, a2, M_offset_0, 20, T2[19]);
            a2 = GG(a2, b3, c3, d4, M_offset_5, 5, T2[20]);
            d4 = GG(d4, a2, b3, c3, M_offset_10, 9, T2[21]);
            c3 = GG(c3, d4, a2, b3, M_offset_15, 14, T2[22]);
            b3 = GG(b3, c3, d4, a2, M_offset_4, 20, T2[23]);
            a2 = GG(a2, b3, c3, d4, M_offset_9, 5, T2[24]);
            d4 = GG(d4, a2, b3, c3, M_offset_14, 9, T2[25]);
            c3 = GG(c3, d4, a2, b3, M_offset_3, 14, T2[26]);
            b3 = GG(b3, c3, d4, a2, M_offset_8, 20, T2[27]);
            a2 = GG(a2, b3, c3, d4, M_offset_13, 5, T2[28]);
            d4 = GG(d4, a2, b3, c3, M_offset_2, 9, T2[29]);
            c3 = GG(c3, d4, a2, b3, M_offset_7, 14, T2[30]);
            b3 = GG(b3, c3, d4, a2, M_offset_12, 20, T2[31]);
            a2 = HH(a2, b3, c3, d4, M_offset_5, 4, T2[32]);
            d4 = HH(d4, a2, b3, c3, M_offset_8, 11, T2[33]);
            c3 = HH(c3, d4, a2, b3, M_offset_11, 16, T2[34]);
            b3 = HH(b3, c3, d4, a2, M_offset_14, 23, T2[35]);
            a2 = HH(a2, b3, c3, d4, M_offset_1, 4, T2[36]);
            d4 = HH(d4, a2, b3, c3, M_offset_4, 11, T2[37]);
            c3 = HH(c3, d4, a2, b3, M_offset_7, 16, T2[38]);
            b3 = HH(b3, c3, d4, a2, M_offset_10, 23, T2[39]);
            a2 = HH(a2, b3, c3, d4, M_offset_13, 4, T2[40]);
            d4 = HH(d4, a2, b3, c3, M_offset_0, 11, T2[41]);
            c3 = HH(c3, d4, a2, b3, M_offset_3, 16, T2[42]);
            b3 = HH(b3, c3, d4, a2, M_offset_6, 23, T2[43]);
            a2 = HH(a2, b3, c3, d4, M_offset_9, 4, T2[44]);
            d4 = HH(d4, a2, b3, c3, M_offset_12, 11, T2[45]);
            c3 = HH(c3, d4, a2, b3, M_offset_15, 16, T2[46]);
            b3 = HH(b3, c3, d4, a2, M_offset_2, 23, T2[47]);
            a2 = II(a2, b3, c3, d4, M_offset_0, 6, T2[48]);
            d4 = II(d4, a2, b3, c3, M_offset_7, 10, T2[49]);
            c3 = II(c3, d4, a2, b3, M_offset_14, 15, T2[50]);
            b3 = II(b3, c3, d4, a2, M_offset_5, 21, T2[51]);
            a2 = II(a2, b3, c3, d4, M_offset_12, 6, T2[52]);
            d4 = II(d4, a2, b3, c3, M_offset_3, 10, T2[53]);
            c3 = II(c3, d4, a2, b3, M_offset_10, 15, T2[54]);
            b3 = II(b3, c3, d4, a2, M_offset_1, 21, T2[55]);
            a2 = II(a2, b3, c3, d4, M_offset_8, 6, T2[56]);
            d4 = II(d4, a2, b3, c3, M_offset_15, 10, T2[57]);
            c3 = II(c3, d4, a2, b3, M_offset_6, 15, T2[58]);
            b3 = II(b3, c3, d4, a2, M_offset_13, 21, T2[59]);
            a2 = II(a2, b3, c3, d4, M_offset_4, 6, T2[60]);
            d4 = II(d4, a2, b3, c3, M_offset_11, 10, T2[61]);
            c3 = II(c3, d4, a2, b3, M_offset_2, 15, T2[62]);
            b3 = II(b3, c3, d4, a2, M_offset_9, 21, T2[63]);
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c3 | 0;
            H[3] = H[3] + d4 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a2, b3, c3, d4, x2, s2, t2) {
          var n2 = a2 + (b3 & c3 | ~b3 & d4) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b3;
        }
        function GG(a2, b3, c3, d4, x2, s2, t2) {
          var n2 = a2 + (b3 & d4 | c3 & ~d4) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b3;
        }
        function HH(a2, b3, c3, d4, x2, s2, t2) {
          var n2 = a2 + (b3 ^ c3 ^ d4) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b3;
        }
        function II(a2, b3, c3, d4, x2, s2, t2) {
          var n2 = a2 + (c3 ^ (b3 | ~d4)) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b3;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// ../node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/crypto-js/sha1.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H = this._hash.words;
            var a2 = H[0];
            var b3 = H[1];
            var c3 = H[2];
            var d4 = H[3];
            var e3 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M2[offset + i2] | 0;
              } else {
                var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e3 + W[i2];
              if (i2 < 20) {
                t2 += (b3 & c3 | ~b3 & d4) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b3 ^ c3 ^ d4) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b3 & c3 | b3 & d4 | c3 & d4) - 1894007588;
              } else {
                t2 += (b3 ^ c3 ^ d4) - 899497514;
              }
              e3 = d4;
              d4 = c3;
              c3 = b3 << 30 | b3 >>> 2;
              b3 = a2;
              a2 = t2;
            }
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c3 | 0;
            H[3] = H[3] + d4 | 0;
            H[4] = H[4] + e3 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// ../node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "../node_modules/crypto-js/sha256.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K3 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K3[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b3 = H2[1];
            var c3 = H2[2];
            var d4 = H2[3];
            var e3 = H2[4];
            var f2 = H2[5];
            var g2 = H2[6];
            var h2 = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M2[offset + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e3 & f2 ^ ~e3 & g2;
              var maj = a2 & b3 ^ a2 & c3 ^ b3 & c3;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e3 << 26 | e3 >>> 6) ^ (e3 << 21 | e3 >>> 11) ^ (e3 << 7 | e3 >>> 25);
              var t1 = h2 + sigma1 + ch + K3[i2] + W[i2];
              var t2 = sigma0 + maj;
              h2 = g2;
              g2 = f2;
              f2 = e3;
              e3 = d4 + t1 | 0;
              d4 = c3;
              c3 = b3;
              b3 = a2;
              a2 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b3 | 0;
            H2[2] = H2[2] + c3 | 0;
            H2[3] = H2[3] + d4 | 0;
            H2[4] = H2[4] + e3 | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g2 | 0;
            H2[7] = H2[7] + h2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// ../node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "../node_modules/crypto-js/sha224.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// ../node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "../node_modules/crypto-js/sha512.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K3 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W[i2] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi = W[i2];
              if (i2 < 16) {
                Wih = Wi.high = M2[offset + i2 * 2] | 0;
                Wil = Wi.low = M2[offset + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K3[i2];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// ../node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "../node_modules/crypto-js/sha384.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// ../node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "../node_modules/crypto-js/sha3.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x2 = 1, y2 = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x2 + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x2 + 3 * y2) % 5;
            x2 = newX;
            y2 = newY;
          }
          for (var x2 = 0; x2 < 5; x2++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x2 + 5 * y2] = y2 + (2 * x2 + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j2 = 0; j2 < 7; j2++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j2) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T2[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M2, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M2[offset + 2 * i2];
              var M2i1 = M2[offset + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x2 = 0; x2 < 5; x2++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state[x2 + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T2[x2];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                var Tx4 = T2[(x2 + 4) % 5];
                var Tx1 = T2[(x2 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state[x2 + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T2[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T2[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x2 + 5 * y2;
                  var lane = state[laneIndex];
                  var TLane = T2[laneIndex];
                  var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y2];
                  var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            var state = clone2._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = state[i2].clone();
            }
            return clone2;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// ../node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "../node_modules/crypto-js/ripemd160.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr2 = _hr.words;
            var zl = _zl.words;
            var zr2 = _zr.words;
            var sl = _sl.words;
            var sr2 = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er2;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er2 = el = H[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al + M2[offset + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl[i2]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M2[offset + zr2[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr2[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr2[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr2[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr2[3];
              } else {
                t2 += f1(br, cr, dr) + hr2[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr2[i2]);
              t2 = t2 + er2 | 0;
              ar = er2;
              er2 = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er2 | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x2, y2, z2) {
          return x2 ^ y2 ^ z2;
        }
        function f2(x2, y2, z2) {
          return x2 & y2 | ~x2 & z2;
        }
        function f3(x2, y2, z2) {
          return (x2 | ~y2) ^ z2;
        }
        function f4(x2, y2, z2) {
          return x2 & z2 | y2 & ~z2;
        }
        function f5(x2, y2, z2) {
          return x2 ^ (y2 | ~z2);
        }
        function rotl(x2, n2) {
          return x2 << n2 | x2 >>> 32 - n2;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// ../node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "../node_modules/crypto-js/hmac.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// ../node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../node_modules/crypto-js/pbkdf2.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j2 = 0; j2 < blockWordsLength; j2++) {
                  blockWords[j2] ^= intermediateWords[j2];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// ../node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "../node_modules/crypto-js/evpkdf.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// ../node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "../node_modules/crypto-js/cipher-core.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message3, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message3, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message3, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message3);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message3, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message3, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// ../node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "../node_modules/crypto-js/mode-cfb.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// ../node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "../node_modules/crypto-js/mode-ctr.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// ../node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "../node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// ../node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "../node_modules/crypto-js/mode-ofb.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// ../node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "../node_modules/crypto-js/mode-ecb.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// ../node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "../node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// ../node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "../node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// ../node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "../node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// ../node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "../node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i2 = data.sigBytes - 1;
          for (var i2 = data.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data.sigBytes = i2 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// ../node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "../node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// ../node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "../node_modules/crypto-js/format-hex.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// ../node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "../node_modules/crypto-js/aes.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d4 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d4[i2] = i2 << 1;
            } else {
              d4[i2] = i2 << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d4[x2];
            var x4 = d4[x22];
            var x8 = d4[x4];
            var t2 = d4[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x2] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x2] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x2] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x2) {
              x2 = xi = 1;
            } else {
              x2 = x22 ^ d4[d4[d4[x8 ^ x22]]];
              xi ^= d4[d4[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset) {
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
            this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
          },
          _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset] ^ keySchedule[0];
            var s1 = M2[offset + 1] ^ keySchedule[1];
            var s2 = M2[offset + 2] ^ keySchedule[2];
            var s3 = M2[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset] = t0;
            M2[offset + 1] = t1;
            M2[offset + 2] = t2;
            M2[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// ../node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "../node_modules/crypto-js/tripledes.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._subKeys);
          },
          decryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M2, offset, subKeys) {
            this._lBlock = M2[offset];
            this._rBlock = M2[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M2[offset] = this._lBlock;
            M2[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset;
        }
        function exchangeRL(offset, mask) {
          var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M2, offset) {
            this._des1.encryptBlock(M2, offset);
            this._des2.decryptBlock(M2, offset);
            this._des3.encryptBlock(M2, offset);
          },
          decryptBlock: function(M2, offset) {
            this._des3.decryptBlock(M2, offset);
            this._des2.encryptBlock(M2, offset);
            this._des1.decryptBlock(M2, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// ../node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "../node_modules/crypto-js/rc4.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S3 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S3[i2] = i2;
            }
            for (var i2 = 0, j2 = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j2 = (j2 + S3[i2] + keyByte) % 256;
              var t2 = S3[i2];
              S3[i2] = S3[j2];
              S3[j2] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M2, offset) {
            M2[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S3 = this._S;
          var i2 = this._i;
          var j2 = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i2 = (i2 + 1) % 256;
            j2 = (j2 + S3[i2]) % 256;
            var t2 = S3[i2];
            S3[i2] = S3[j2];
            S3[j2] = t2;
            keystreamWord |= S3[(S3[i2] + S3[j2]) % 256] << 24 - n2 * 8;
          }
          this._i = i2;
          this._j = j2;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// ../node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "../node_modules/crypto-js/rabbit.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K3[i2] = (K3[i2] << 8 | K3[i2] >>> 24) & 16711935 | (K3[i2] << 24 | K3[i2] >>> 8) & 4278255360;
            }
            var X3 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C2 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X3[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X3 = this._X;
            nextState.call(this);
            S3[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S3[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S3[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S3[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S3[i2] = (S3[i2] << 8 | S3[i2] >>> 24) & 16711935 | (S3[i2] << 24 | S3[i2] >>> 8) & 4278255360;
              M2[offset + i2] ^= S3[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X3[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X3[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X3[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X3[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X3[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X3[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X3[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X3[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X3[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// ../node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "../node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            var X3 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C2 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X3[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X3 = this._X;
            nextState.call(this);
            S3[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S3[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S3[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S3[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S3[i2] = (S3[i2] << 8 | S3[i2] >>> 24) & 16711935 | (S3[i2] << 24 | S3[i2] >>> 8) & 4278255360;
              M2[offset + i2] ^= S3[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X3[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X3[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X3[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X3[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X3[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X3[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X3[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X3[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X3[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// ../node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "../node_modules/crypto-js/blowfish.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x2) {
          let a2 = x2 >> 24 & 255;
          let b3 = x2 >> 16 & 255;
          let c3 = x2 >> 8 & 255;
          let d4 = x2 & 255;
          let y2 = ctx.sbox[0][a2] + ctx.sbox[1][b3];
          y2 = y2 ^ ctx.sbox[2][c3];
          y2 = y2 + ctx.sbox[3][d4];
          return y2;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = 0; i2 < N; ++i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = N + 1; i2 > 1; --i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index2 = 0; index2 < N + 2; index2++) {
            ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i2 = 0; i2 < N + 2; i2 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i2] = Data1;
            ctx.pbox[i2 + 1] = Data2;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            for (let j2 = 0; j2 < 256; j2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i2][j2] = Data1;
              ctx.sbox[i2][j2 + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M2, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res.left;
            M2[offset + 1] = res.right;
          },
          decryptBlock: function(M2, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res.left;
            M2[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS.Blowfish;
    });
  }
});

// ../node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "../node_modules/crypto-js/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// ../node_modules/@upstash/qstash/dist/chunk-EROSIHWE.js
var require_chunk_EROSIHWE = __commonJS({
  "../node_modules/@upstash/qstash/dist/chunk-EROSIHWE.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __knownSymbol = (name, symbol) => {
      if (symbol = Symbol[name])
        return symbol;
      throw Error("Symbol." + name + " is not defined");
    };
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a2, b3) => {
      for (var prop in b3 || (b3 = {}))
        if (__hasOwnProp2.call(b3, prop))
          __defNormalProp2(a2, prop, b3[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b3)) {
          if (__propIsEnum.call(b3, prop))
            __defNormalProp2(a2, prop, b3[prop]);
        }
      return a2;
    };
    var __spreadProps = (a2, b3) => __defProps(a2, __getOwnPropDescs(b3));
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e3) {
            reject(e3);
          }
        };
        var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no2, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no2)))), method("next"), method("return"), it);
    var _jose = (init_browser2(), __toCommonJS(browser_exports2));
    var jose = _interopRequireWildcard(_jose);
    var _cryptojs = require_crypto_js();
    var crypto2 = _interopRequireWildcard(_cryptojs);
    var SignatureError = class extends Error {
      constructor(message3) {
        super(message3);
        this.name = "SignatureError";
      }
    };
    var Receiver = class {
      constructor(config) {
        this.currentSigningKey = config.currentSigningKey;
        this.nextSigningKey = config.nextSigningKey;
      }
      /**
       * Verify the signature of a request.
       *
       * Tries to verify the signature with the current signing key.
       * If that fails, maybe because you have rotated the keys recently, it will
       * try to verify the signature with the next signing key.
       *
       * If that fails, the signature is invalid and a `SignatureError` is thrown.
       */
      verify(req) {
        return __async(this, null, function* () {
          const isValid2 = yield this.verifyWithKey(this.currentSigningKey, req);
          if (isValid2) {
            return true;
          }
          return this.verifyWithKey(this.nextSigningKey, req);
        });
      }
      /**
       * Verify signature with a specific signing key
       */
      verifyWithKey(key, req) {
        return __async(this, null, function* () {
          const jwt = yield jose.jwtVerify(req.signature, new TextEncoder().encode(key), {
            issuer: "Upstash",
            clockTolerance: req.clockTolerance
          }).catch((e3) => {
            throw new SignatureError(e3.message);
          });
          const p4 = jwt.payload;
          if (typeof req.url !== "undefined" && p4.sub !== req.url) {
            throw new SignatureError(`invalid subject: ${p4.sub}, want: ${req.url}`);
          }
          const bodyHash = crypto2.SHA256(req.body).toString(crypto2.enc.Base64url);
          const padding = new RegExp(/=+$/);
          if (p4.body.replace(padding, "") !== bodyHash.replace(padding, "")) {
            throw new SignatureError(`body hash does not match, want: ${p4.body}, got: ${bodyHash}`);
          }
          return true;
        });
      }
    };
    exports.__spreadValues = __spreadValues;
    exports.__spreadProps = __spreadProps;
    exports.__async = __async;
    exports.__forAwait = __forAwait;
    exports.SignatureError = SignatureError;
    exports.Receiver = Receiver;
  }
});

// ../node_modules/@upstash/qstash/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/@upstash/qstash/dist/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunkEROSIHWEjs = require_chunk_EROSIHWE();
    var DLQ = class {
      constructor(http) {
        this.http = http;
      }
      /**
       * List messages in the dlq
       */
      listMessages(opts) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "dlq"],
            query: { cursor: opts == null ? void 0 : opts.cursor }
          });
        });
      }
      /**
       * Remove a message from the dlq using it's `dlqId`
       */
      delete(dlqMessageId) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "DELETE",
            path: ["v2", "dlq", dlqMessageId],
            parseResponseAsJson: false
            // there is no response
          });
        });
      }
    };
    var QstashError = class extends Error {
      constructor(message3) {
        super(message3);
        this.name = "QstashError";
      }
    };
    var QstashRatelimitError = class extends QstashError {
      constructor(args) {
        super(`You have been ratelimited. ${JSON.stringify(args)} `);
      }
    };
    var HttpClient = class {
      constructor(config) {
        var _a89, _b2, _c2;
        this.baseUrl = config.baseUrl.replace(/\/$/, "");
        this.authorization = config.authorization;
        if (typeof (config == null ? void 0 : config.retry) === "boolean" && (config == null ? void 0 : config.retry) === false) {
          this.retry = {
            attempts: 1,
            backoff: () => 0
          };
        } else {
          this.retry = {
            attempts: ((_a89 = config.retry) == null ? void 0 : _a89.retries) ? config.retry.retries + 1 : 5,
            backoff: (_c2 = (_b2 = config.retry) == null ? void 0 : _b2.backoff) != null ? _c2 : (retryCount) => Math.exp(retryCount) * 50
          };
        }
      }
      request(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          var _a89;
          const headers = new Headers(req.headers);
          headers.set("Authorization", this.authorization);
          const requestOptions = {
            method: req.method,
            headers,
            body: req.body,
            keepalive: req.keepalive
          };
          const url = new URL([this.baseUrl, ...(_a89 = req.path) != null ? _a89 : []].join("/"));
          if (req.query) {
            for (const [key, value] of Object.entries(req.query)) {
              if (typeof value !== "undefined") {
                url.searchParams.set(key, value.toString());
              }
            }
          }
          let res = null;
          let error = null;
          for (let i2 = 0; i2 < this.retry.attempts; i2++) {
            try {
              res = yield fetch(url.toString(), requestOptions);
              break;
            } catch (err) {
              error = err;
              yield new Promise((r2) => setTimeout(r2, this.retry.backoff(i2)));
            }
          }
          if (!res) {
            throw error != null ? error : new Error("Exhausted all retries");
          }
          if (res.status === 429) {
            throw new QstashRatelimitError({
              limit: res.headers.get("Burst-RateLimit-Limit"),
              remaining: res.headers.get("Burst-RateLimit-Remaining"),
              reset: res.headers.get("Burst-RateLimit-Reset")
            });
          }
          if (res.status < 200 || res.status >= 300) {
            const body = yield res.text();
            throw new QstashError(body.length > 0 ? body : `Error: status=${res.status}`);
          }
          if (req.parseResponseAsJson === false) {
            return void 0;
          } else {
            return yield res.json();
          }
        });
      }
    };
    var Messages = class {
      constructor(http) {
        this.http = http;
      }
      /**
       * Get a message
       */
      get(messageId) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "messages", messageId]
          });
        });
      }
      /**
       * Cancel a message
       */
      delete(messageId) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "DELETE",
            path: ["v2", "messages", messageId],
            parseResponseAsJson: false
          });
        });
      }
    };
    function prefixHeaders(headers) {
      const isIgnoredHeader = (header) => {
        const lowerCaseHeader = header.toLowerCase();
        return lowerCaseHeader.startsWith("content-type") || lowerCaseHeader.startsWith("upstash-");
      };
      const keysToBePrefixed = Array.from(headers.keys()).filter(
        (key) => !isIgnoredHeader(key)
      );
      for (const key of keysToBePrefixed) {
        const value = headers.get(key);
        if (value !== null) {
          headers.set(`Upstash-Forward-${key}`, value);
        }
        headers.delete(key);
      }
      return headers;
    }
    var Schedules = class {
      constructor(http) {
        this.http = http;
      }
      /**
       * Create a schedule
       */
      create(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          const headers = prefixHeaders(new Headers(req.headers));
          if (!headers.has("Content-Type")) {
            headers.set("Content-Type", "application/json");
          }
          headers.set("Upstash-Cron", req.cron);
          if (typeof req.method !== "undefined") {
            headers.set("Upstash-Method", req.method);
          }
          if (typeof req.delay !== "undefined") {
            headers.set("Upstash-Delay", `${req.delay.toFixed()}s`);
          }
          if (typeof req.retries !== "undefined") {
            headers.set("Upstash-Retries", req.retries.toFixed());
          }
          if (typeof req.callback !== "undefined") {
            headers.set("Upstash-Callback", req.callback);
          }
          if (typeof req.failureCallback !== "undefined") {
            headers.set("Upstash-Failure-Callback", req.failureCallback);
          }
          return yield this.http.request({
            method: "POST",
            headers,
            path: ["v2", "schedules", req.destination],
            body: req.body
          });
        });
      }
      /**
       * Get a schedule
       */
      get(scheduleId) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "schedules", scheduleId]
          });
        });
      }
      /**
       * List your schedules
       */
      list() {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "schedules"]
          });
        });
      }
      /**
       * Delete a schedule
       */
      delete(scheduleId) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "DELETE",
            path: ["v2", "schedules", scheduleId],
            parseResponseAsJson: false
          });
        });
      }
    };
    var Topics = class {
      constructor(http) {
        this.http = http;
      }
      /**
       * Create a new topic with the given name and endpoints
       */
      addEndpoints(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          yield this.http.request({
            method: "POST",
            path: ["v2", "topics", req.name, "endpoints"],
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ endpoints: req.endpoints }),
            parseResponseAsJson: false
          });
        });
      }
      /**
       * Remove endpoints from a topic.
       */
      removeEndpoints(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          yield this.http.request({
            method: "DELETE",
            path: ["v2", "topics", req.name, "endpoints"],
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ endpoints: req.endpoints }),
            parseResponseAsJson: false
          });
        });
      }
      /**
       * Get a list of all topics.
       */
      list() {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "topics"]
          });
        });
      }
      /**
       * Get a single topic
       */
      get(name) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "GET",
            path: ["v2", "topics", name]
          });
        });
      }
      /**
       * Delete a topic
       */
      delete(name) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          return yield this.http.request({
            method: "DELETE",
            path: ["v2", "topics", name],
            parseResponseAsJson: false
          });
        });
      }
    };
    var Client2 = class {
      constructor(config) {
        this.http = new HttpClient({
          retry: config.retry,
          baseUrl: config.baseUrl ? config.baseUrl.replace(/\/$/, "") : "https://qstash.upstash.io",
          authorization: `Bearer ${config.token}`
        });
      }
      /**
       * Access the topic API.
       *
       * Create, read, update or delete topics.
       */
      get topics() {
        return new Topics(this.http);
      }
      /**
       * Access the dlq API.
       *
       * List or remove messages from the DLQ.
       */
      get dlq() {
        return new DLQ(this.http);
      }
      /**
       * Access the message API.
       *
       * Read or cancel messages.
       */
      get messages() {
        return new Messages(this.http);
      }
      /**
       * Access the schedule API.
       *
       * Create, read or delete schedules.
       */
      get schedules() {
        return new Schedules(this.http);
      }
      publish(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          var _a89, _b2;
          const headers = prefixHeaders(new Headers(req.headers));
          headers.set("Upstash-Method", (_a89 = req.method) != null ? _a89 : "POST");
          if (typeof req.delay !== "undefined") {
            headers.set("Upstash-Delay", `${req.delay.toFixed()}s`);
          }
          if (typeof req.notBefore !== "undefined") {
            headers.set("Upstash-Not-Before", req.notBefore.toFixed());
          }
          if (typeof req.deduplicationId !== "undefined") {
            headers.set("Upstash-Deduplication-Id", req.deduplicationId);
          }
          if (typeof req.contentBasedDeduplication !== "undefined") {
            headers.set("Upstash-Content-Based-Deduplication", "true");
          }
          if (typeof req.retries !== "undefined") {
            headers.set("Upstash-Retries", req.retries.toFixed());
          }
          if (typeof req.callback !== "undefined") {
            headers.set("Upstash-Callback", req.callback);
          }
          if (typeof req.failureCallback !== "undefined") {
            headers.set("Upstash-Failure-Callback", req.failureCallback);
          }
          const res = yield this.http.request({
            path: ["v2", "publish", (_b2 = req.url) != null ? _b2 : req.topic],
            body: req.body,
            headers,
            method: "POST"
          });
          return res;
        });
      }
      /**
       * publishJSON is a utility wrapper around `publish` that automatically serializes the body
       * and sets the `Content-Type` header to `application/json`.
       */
      publishJSON(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          const headers = prefixHeaders(new Headers(req.headers));
          headers.set("Content-Type", "application/json");
          const res = yield this.publish(_chunkEROSIHWEjs.__spreadProps.call(void 0, _chunkEROSIHWEjs.__spreadValues.call(void 0, {}, req), {
            headers,
            body: JSON.stringify(req.body)
          }));
          return res;
        });
      }
      /**
       * Retrieve your logs.
       *
       * The logs endpoint is paginated and returns only 100 logs at a time.
       * If you want to receive more logs, you can use the cursor to paginate.
       *
       * The cursor is a unix timestamp with millisecond precision
       *
       * @example
       * ```ts
       * let cursor = Date.now()
       * const logs: Log[] = []
       * while (cursor > 0) {
       *   const res = await qstash.logs({ cursor })
       *   logs.push(...res.logs)
       *   cursor = res.cursor ?? 0
       * }
       * ```
       */
      events(req) {
        return _chunkEROSIHWEjs.__async.call(void 0, this, null, function* () {
          const query = {};
          if ((req == null ? void 0 : req.cursor) && req.cursor > 0) {
            query.cursor = req.cursor;
          }
          const res = yield this.http.request({
            path: ["v2", "events"],
            method: "GET",
            query
          });
          return res;
        });
      }
    };
    exports.Client = Client2;
    exports.Messages = Messages;
    exports.QstashError = QstashError;
    exports.QstashRatelimitError = QstashRatelimitError;
    exports.Receiver = _chunkEROSIHWEjs.Receiver;
    exports.Schedules = Schedules;
    exports.SignatureError = _chunkEROSIHWEjs.SignatureError;
    exports.Topics = Topics;
  }
});

// .wrangler/tmp/bundle-7bl23J/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-7bl23J/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();

// src/index.ts
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@cloudflare/itty-router-openapi/node_modules/itty-router/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var e = ({ base: e3 = "", routes: t2 = [] } = {}) => ({ __proto__: new Proxy({}, { get: (o2, s2, r2, n2) => (o3, ...a2) => t2.push([s2.toUpperCase(), RegExp(`^${(n2 = (e3 + o3).replace(/\/+(\/|$)/g, "$1")).replace(/(\/?\.?):(\w+)\+/g, "($1(?<$2>*))").replace(/(\/?\.?):(\w+)/g, "($1(?<$2>[^$1/]+?))").replace(/\./g, "\\.").replace(/(\/?)\*/g, "($1.*)?")}/*$`), a2, n2]) && r2 }), routes: t2, async handle(e4, ...o2) {
  let s2, r2, n2 = new URL(e4.url), a2 = e4.query = { __proto__: null };
  for (let [e5, t3] of n2.searchParams)
    a2[e5] = a2[e5] ? [].concat(a2[e5], t3) : t3;
  for (let [a3, c3, l3, i2] of t2)
    if ((a3 === e4.method || "ALL" === a3) && (r2 = n2.pathname.match(c3))) {
      e4.params = r2.groups || {}, e4.route = i2;
      for (let t3 of l3)
        if (null != (s2 = await t3(e4.proxy ?? e4, ...o2)))
          return s2;
    }
} });
var o = (e3 = "text/plain; charset=utf-8", t2) => (o2, { headers: s2 = {}, ...r2 } = {}) => void 0 === o2 || "Response" === o2?.constructor.name ? o2 : new Response(t2 ? t2(o2) : o2, { headers: { "content-type": e3, ...s2 }, ...r2 });
var s = o("application/json; charset=utf-8", JSON.stringify);
var c = o("text/plain; charset=utf-8", String);
var l = o("text/html");
var i = o("image/jpeg");
var p = o("image/png");
var d = o("image/webp");

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
var import_zod_to_openapi = __toESM(require_dist(), 1);

// node_modules/zod/lib/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message3;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message3 = "Required";
      } else {
        message3 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message3 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message3 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message3 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message3 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message3 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message3 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message3 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message3 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message3 = `${message3} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message3 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message3 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message3 = `Invalid ${issue.validation}`;
      } else {
        message3 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message3 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message3 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message3 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message3 = "Number must be finite";
      break;
    default:
      message3 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message3 };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message3) => typeof message3 === "string" ? { message: message3 } : message3 || {};
  errorUtil2.toString = (message3) => typeof message3 === "string" ? message3 : message3 === null || message3 === void 0 ? void 0 : message3.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a89;
    const ctx = {
      common: {
        issues: [],
        async: (_a89 = params === null || params === void 0 ? void 0 : params.async) !== null && _a89 !== void 0 ? _a89 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message3) {
    const getIssueProperties = (val) => {
      if (typeof message3 === "string" || typeof message3 === "undefined") {
        return { message: message3 };
      } else if (typeof message3 === "function") {
        return message3(val);
      } else {
        return message3;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a89) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message3) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message3)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message3) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message3) });
  }
  url(message3) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message3) });
  }
  emoji(message3) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message3) });
  }
  uuid(message3) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message3) });
  }
  cuid(message3) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message3) });
  }
  cuid2(message3) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message3) });
  }
  ulid(message3) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message3) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a89;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a89 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a89 !== void 0 ? _a89 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message3) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message3)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message3) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message3)
    });
  }
  endsWith(value, message3) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message3)
    });
  }
  min(minLength, message3) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message3)
    });
  }
  max(maxLength, message3) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message3)
    });
  }
  length(len, message3) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message3)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message3) {
    return this.min(1, errorUtil.errToObj(message3));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a89;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a89 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a89 !== void 0 ? _a89 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message3) {
    return this.setLimit("min", value, true, errorUtil.toString(message3));
  }
  gt(value, message3) {
    return this.setLimit("min", value, false, errorUtil.toString(message3));
  }
  lte(value, message3) {
    return this.setLimit("max", value, true, errorUtil.toString(message3));
  }
  lt(value, message3) {
    return this.setLimit("max", value, false, errorUtil.toString(message3));
  }
  setLimit(kind, value, inclusive, message3) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message3) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message3)
    });
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message3)
    });
  }
  finite(message3) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message3)
    });
  }
  safe(message3) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message3) {
    return this.setLimit("min", value, true, errorUtil.toString(message3));
  }
  gt(value, message3) {
    return this.setLimit("min", value, false, errorUtil.toString(message3));
  }
  lte(value, message3) {
    return this.setLimit("max", value, true, errorUtil.toString(message3));
  }
  lt(value, message3) {
    return this.setLimit("max", value, false, errorUtil.toString(message3));
  }
  setLimit(kind, value, inclusive, message3) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a89;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a89 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a89 !== void 0 ? _a89 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message3) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  max(maxDate, message3) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message3) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message3) }
    });
  }
  max(maxLength, message3) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message3) }
    });
  }
  length(len, message3) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message3) }
    });
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
};
ZodArray.create = (schema4, params) => {
  return new ZodArray({
    type: schema4,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema4) {
  if (schema4 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema4.shape) {
      const fieldSchema = schema4.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema4._def,
      shape: () => newShape
    });
  } else if (schema4 instanceof ZodArray) {
    return new ZodArray({
      ...schema4._def,
      type: deepPartialify(schema4.element)
    });
  } else if (schema4 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodTuple) {
    return ZodTuple.create(schema4.items.map((item) => deepPartialify(item)));
  } else {
    return schema4;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message3) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message3 !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a89, _b2, _c2, _d;
          const defaultError = (_c2 = (_b2 = (_a89 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a89, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message3).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema4) {
    return this.augment({ [key]: schema4 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b3) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b3);
  if (a2 === b3) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b3[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b3) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema4 = this._def.items[itemIndex] || this._def.rest;
      if (!schema4)
        return null;
      return schema4._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas2, params) => {
  if (!Array.isArray(schemas2)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas2,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message3) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message3) }
    });
  }
  max(maxSize, message3) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message3) }
    });
  }
  size(size, message3) {
    return this.min(size, message3).max(size, message3);
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e3) => {
          error.addIssue(makeArgsIssue(args, e3));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e3) => {
          error.addIssue(makeReturnsIssue(result, e3));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema4, params) => {
  return new ZodPromise({
    type: schema4,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema4, effect, params) => {
  return new ZodEffects({
    schema: schema4,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema4, params) => {
  return new ZodEffects({
    schema: schema4,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b3) {
    return new ZodPipeline({
      in: a2,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check2, params = {}, fatal) => {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a89, _b2;
      if (!check2(data)) {
        const p4 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a89 = p4.fatal) !== null && _a89 !== void 0 ? _a89 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p4 === "string" ? { message: p4 } : p4;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@cloudflare/itty-router-openapi/dist/index.mjs
function c2(A) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="SwaggerIU"/>
    <title>SwaggerUI</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui.css"/>
    <link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlMb//2ux//9or///ZKz//wlv5f8JcOf/CnXv/why7/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2vi/wZo3/9ytf//b7P//2uw//+BvP//DHbp/w568P8Md+//CnXv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApv4/8HbOH/lMf//3W3//9ytf//brL//w946v8SfvH/EHzw/w558P8AAAAAAAAAAAAAAAAAAAAAAAAAABF56f8Ndef/C3Dj/whs4f98u///eLn//3W3//+Evv//FoPx/xSA8f8SfvD/EHvw/wAAAAAAAAAAAAAAAA1EeF0WgOz/EXrp/w515v8LceT/lsn//3+9//97u///eLj//xaB7f8YhfL/FoLx/xSA8f8JP/deAAAAAAAAAAAgjfH/HIjw/xeB7P8Te+n/AAAAAAAAAACGwf//gr///369//+Iwf//HIny/xqH8v8YhfL/FYLx/wAAAAAnlfPlJJLy/yGO8v8cifD/GILt/wAAAAAAAAAAmMz//4nD//+Fwf//gb///xyJ8P8ejPP/HIny/xmH8v8XhPLnK5r0/yiW8/8lk/P/IpDy/wAAAAAAAAAAAAAAAAAAAACPx///jMX//4jD//+MxP//IpD0/yCO8/8di/P/G4ny/y6e9f8sm/T/KZj0/yaV8/8AAAAAAAAAAAAAAAAAAAAAlsz//5LJ//+Px///lMn//yaV9P8kkvT/IZD0/x+O8/8yo/blMKD1/y2d9f8qmfT/KJbz/wAAAAAAAAAAqdb//53Q//+Zzv//lsv//yiY8/8qmvX/KJf1/yWV9P8jkvTQAAAAADSl9v8xofX/Lp71/yyb9P8AAAAAAAAAAKfW//+k1P//oNL//6rW//8wofb/Lp72/yuc9f8pmfX/AAAAAAAAAAAcVHtcNab2/zKj9v8voPX/LZz0/7vh//+u2///qtj//6fW//8wofT/NKX3/zKj9/8voPb/F8/6XgAAAAAAAAAAAAAAADmr9/82qPf/M6T2/zCg9f+44f//td///7Hd//++4v//Oqz4/ziq+P81p/f/M6X3/wAAAAAAAAAAAAAAAAAAAAAAAAAAOqz4/zep9//M6///v+X//7vj//+44f//OKn1/z6x+f88rvn/Oaz4/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6x+f8qmfP/yOv//8bq///C5///z+z//0O3+v9Ctfr/QLP5/z2x+f8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0u///8jr///I6///yOv//zmq9f9Dt/r/Q7f6/0O3+v8AAAAAAAAAAAAAAAAAAAAA8A8AAOAHAADgBwAAwAMAAMADAACGAQAABgAAAA8AAAAPAAAABgAAAIYBAADAAwAAwAMAAOAHAADgBwAA8A8AAA==" />
</head>
<body>
<div id="swagger-ui"></div>
<script src="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui-bundle.js" crossorigin><\/script>
<script src="https://unpkg.com/swagger-ui-dist@5.1.3/swagger-ui-standalone-preset.js" crossorigin><\/script>
<script>
    window.onload = () => {
        window.ui = SwaggerUIBundle({
            url: '${A = A.replace(/\/+(\/|$)/g, "$1")}',
            dom_id: '#swagger-ui',
            deepLinking: true,
            presets: [
                SwaggerUIBundle.presets.apis
            ]
        });
    };
<\/script>
</body>
</html>`;
}
function u(A) {
  return `<!DOCTYPE html>
    <html>
    <head>
    <title>ReDocUI</title>
    <!-- needed for adaptive design -->
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlMb//2ux//9or///ZKz//wlv5f8JcOf/CnXv/why7/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2vi/wZo3/9ytf//b7P//2uw//+BvP//DHbp/w568P8Md+//CnXv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApv4/8HbOH/lMf//3W3//9ytf//brL//w946v8SfvH/EHzw/w558P8AAAAAAAAAAAAAAAAAAAAAAAAAABF56f8Ndef/C3Dj/whs4f98u///eLn//3W3//+Evv//FoPx/xSA8f8SfvD/EHvw/wAAAAAAAAAAAAAAAA1EeF0WgOz/EXrp/w515v8LceT/lsn//3+9//97u///eLj//xaB7f8YhfL/FoLx/xSA8f8JP/deAAAAAAAAAAAgjfH/HIjw/xeB7P8Te+n/AAAAAAAAAACGwf//gr///369//+Iwf//HIny/xqH8v8YhfL/FYLx/wAAAAAnlfPlJJLy/yGO8v8cifD/GILt/wAAAAAAAAAAmMz//4nD//+Fwf//gb///xyJ8P8ejPP/HIny/xmH8v8XhPLnK5r0/yiW8/8lk/P/IpDy/wAAAAAAAAAAAAAAAAAAAACPx///jMX//4jD//+MxP//IpD0/yCO8/8di/P/G4ny/y6e9f8sm/T/KZj0/yaV8/8AAAAAAAAAAAAAAAAAAAAAlsz//5LJ//+Px///lMn//yaV9P8kkvT/IZD0/x+O8/8yo/blMKD1/y2d9f8qmfT/KJbz/wAAAAAAAAAAqdb//53Q//+Zzv//lsv//yiY8/8qmvX/KJf1/yWV9P8jkvTQAAAAADSl9v8xofX/Lp71/yyb9P8AAAAAAAAAAKfW//+k1P//oNL//6rW//8wofb/Lp72/yuc9f8pmfX/AAAAAAAAAAAcVHtcNab2/zKj9v8voPX/LZz0/7vh//+u2///qtj//6fW//8wofT/NKX3/zKj9/8voPb/F8/6XgAAAAAAAAAAAAAAADmr9/82qPf/M6T2/zCg9f+44f//td///7Hd//++4v//Oqz4/ziq+P81p/f/M6X3/wAAAAAAAAAAAAAAAAAAAAAAAAAAOqz4/zep9//M6///v+X//7vj//+44f//OKn1/z6x+f88rvn/Oaz4/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6x+f8qmfP/yOv//8bq///C5///z+z//0O3+v9Ctfr/QLP5/z2x+f8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0u///8jr///I6///yOv//zmq9f9Dt/r/Q7f6/0O3+v8AAAAAAAAAAAAAAAAAAAAA8A8AAOAHAADgBwAAwAMAAMADAACGAQAABgAAAA8AAAAPAAAABgAAAIYBAADAAwAAwAMAAOAHAADgBwAA8A8AAA==" />

    <!--
    ReDoc doesn't change outer page styles
    -->
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
    </head>
    <body>
    <redoc spec-url="${A = A.replace(/\/+(\/|$)/g, "$1")}"></redoc>
    <script src="https://unpkg.com/redoc@2.0.0-rc.58/bundles/redoc.standalone.js"> <\/script>
    </body>
    </html>`;
}
var p2;
var l2;
var f;
!function(A) {
  A.V1 = "v1";
}(p2 || (p2 = {})), function(A) {
  A.NONE = "none", A.OAUTH = "oauth", A.SERVICE_HTTP = "service_http", A.USER_HTTP = "user_http";
}(l2 || (l2 = {})), function(A) {
  A.OPENAPI = "openapi";
}(f || (f = {}));
var d2 = class extends import_zod_to_openapi.OpenAPIRegistry {
  _definitions = [];
  merge(A) {
    for (const e3 of A._definitions)
      this._definitions.push({ ...e3 });
  }
};
var m = require_js_yaml();
function h(e3) {
  const n2 = new d2(), o2 = () => {
    let A = import_zod_to_openapi.OpenApiGeneratorV31;
    "3" === e3?.openapiVersion && (A = import_zod_to_openapi.OpenApiGeneratorV3);
    return new A(n2.definitions).generateDocument({ openapi: "3" === e3?.openapiVersion ? "3.0.3" : "3.1.0", info: { version: e3?.schema?.info?.version || "1.0.0", title: e3?.schema?.info?.title || "OpenAPI", ...e3?.schema?.info }, ...e3?.schema });
  }, a2 = (e3?.baseRouter || e)({ base: e3?.base, routes: e3?.routes }), i2 = new Proxy(a2, { get: (A, t2, r2, i3) => "original" === t2 ? a2 : "schema" === t2 ? o2() : "registry" === t2 ? n2 : (o3, ...a3) => {
    if ("handle" !== t2) {
      if (1 === a3.length && a3[0].registry) {
        const A2 = a3[0];
        n2.merge(A2.registry);
      } else if ("all" !== t2) {
        const A2 = ((e3?.base || "") + o3).replaceAll(/\/+(\/|$)/g, "$1").replaceAll(/:(\w+)/g, "{$1}");
        let r3, i4;
        for (const A3 of a3)
          if (A3.name && (i4 = `${t2.toString()}_${A3.name}`), A3.getSchemaZod) {
            r3 = A3.getSchemaZod();
            break;
          }
        if (void 0 === i4 && (i4 = `${t2.toString()}_${o3.replaceAll("/", "_")}`), void 0 === r3) {
          r3 = { operationId: i4, responses: { 200: { description: "Object with user data." } } };
          const A3 = ((e3?.base || "") + o3).match(/:(\w+)/g);
          A3 && (r3.request = { params: z.object(A3.reduce((A4, e4) => Object.assign(A4, { [e4.replace(":", "")]: z.string() }), {})) });
        } else if (!r3.operationId) {
          if (false === e3?.generateOperationIds && !r3.operationId)
            throw new Error(`Route ${o3} don't have operationId set!`);
          r3.operationId = i4;
        }
        n2.registerPath({ ...r3, method: t2.toString(), path: A2 });
      }
    }
    return Reflect.get(A, t2, r2)(o3, ...a3.map((A2) => A2.handle ? A2.handle : A2.isRoute ? (...e4) => new A2({}).execute(...e4) : A2));
  } });
  return null !== e3?.docs_url && null !== e3?.openapi_url && a2.get(e3?.docs_url || "/docs", () => new Response(c2((e3?.base || "") + (e3?.openapi_url || "/openapi.json")), { headers: { "content-type": "text/html; charset=UTF-8" }, status: 200 })), null !== e3?.redoc_url && null !== e3?.openapi_url && a2.get(e3?.redoc_url || "/redocs", () => new Response(u((e3?.base || "") + (e3?.openapi_url || "/openapi.json")), { headers: { "content-type": "text/html; charset=UTF-8" }, status: 200 })), null !== e3?.openapi_url && (a2.get(e3?.openapi_url || "/openapi.json", () => new Response(JSON.stringify(o2()), { headers: { "content-type": "application/json;charset=UTF-8" }, status: 200 })), a2.get((e3?.openapi_url || "/openapi.json").replace(".json", ".yaml"), () => new Response(m.dump(o2()), { headers: { "content-type": "text/yaml;charset=UTF-8" }, status: 200 }))), e3?.aiPlugin && null !== e3?.openapi_url && a2.get("/.well-known/ai-plugin.json", (A) => {
    const t2 = { type: f.OPENAPI, has_user_authentication: false, url: e3?.openapi_url || "/openapi.json", ...e3?.aiPlugin?.api };
    return t2.url.startsWith("http") || (t2.url = `https://${A.headers.get("host")}${t2.url}`), new Response(JSON.stringify({ schema_version: p2.V1, auth: { type: l2.NONE }, ...e3?.aiPlugin, api: t2 }), { headers: { "content-type": "application/json;charset=UTF-8" }, status: 200 });
  }), i2;
}
function g(A) {
  return void 0 !== A._def;
}
function y(A, e3) {
  return "ZodArray" === A._def.typeName || "ZodArray" === A._def.innerType?._def.typeName || "ZodArray" === A._def.schema?._def.innerType?._def.typeName;
}
function w(A, e3) {
  if (e3 = e3 || {}, null === A)
    return new q({ required: false, ...e3 });
  if (g(A))
    return e3 ? v(A, e3) : A;
  if (true === A.generator)
    return new A(e3);
  if (A === String)
    return new q(e3);
  if ("string" == typeof A)
    return new q({ example: A });
  if (A === Number)
    return new j(e3);
  if ("number" == typeof A)
    return new j({ example: A });
  if (A === Boolean)
    return new S(e3);
  if ("boolean" == typeof A)
    return new S({ example: A });
  if (A === Date)
    return new O(e3);
  if (Array.isArray(A)) {
    if (0 === A.length)
      throw new Error("Arr must have a type");
    return new b(A[0], e3);
  }
  if ("object" == typeof A)
    return new P(A, e3);
  throw new Error(`${A} not implemented`);
}
function v(A, e3) {
  return false === (e3 = e3 || {}).required && (A = A.optional()), e3.description && (A = A.describe(e3.description)), e3.default && (A = A.default(e3.default)), e3.example && (A = A.openapi({ example: e3.example })), e3.format && (A = A.openapi({ format: e3.format })), A;
}
void 0 === z.string().openapi && (0, import_zod_to_openapi.extendZodWithOpenApi)(z);
var b = class {
  constructor(A, e3) {
    return v(w(A).array(), e3);
  }
};
__publicField(b, "generator", true);
var P = class {
  constructor(A, e3) {
    const t2 = {};
    for (const [e4, r2] of Object.entries(A))
      t2[e4] = w(r2);
    return v(z.object(t2), e3);
  }
};
__publicField(P, "generator", true);
var j = class {
  constructor(A) {
    return v(z.number().or(z.string()).pipe(z.coerce.number()), A).openapi({ type: "number" });
  }
};
__publicField(j, "generator", true);
var q = class {
  constructor(A) {
    return v(z.string(), A);
  }
};
__publicField(q, "generator", true);
var O = class {
  constructor(A) {
    return v(z.string().datetime({ message: "Must be in the following format: YYYY-mm-ddTHH:MM:ssZ" }), A);
  }
};
__publicField(O, "generator", true);
var S = class {
  constructor(A) {
    return v(z.coerce.string().toLowerCase().pipe(z.enum(["true", "false"]).transform((A2) => "true" === A2)), A).openapi({ type: "boolean" });
  }
};
__publicField(S, "generator", true);
function M(A, e3 = {}) {
  return { name: e3.name, location: "query", type: w(A, e3) };
}
function Z(A, e3) {
  const { searchParams: t2 } = new URL(A.url);
  if (0 === t2.size)
    return null;
  const r2 = {};
  for (let [A2, n2] of t2.entries())
    "" === n2 && (n2 = null), void 0 === r2[A2] ? r2[A2] = n2 : Array.isArray(r2[A2]) ? r2[A2].push(n2) : r2[A2] = [r2[A2], n2], e3 && e3.shape[A2] && (y(e3.shape[A2]) && !Array.isArray(r2[A2]) ? r2[A2] = [r2[A2]] : y(e3.shape[A2]));
  return r2;
}
function X(A, e3) {
  return new Response(JSON.stringify(A), { headers: { "content-type": "application/json;charset=UTF-8" }, status: e3?.status ? e3.status : 200, ...e3 });
}
var K = class {
  handle(A, ...e3) {
    throw new Error("Method not implemented.");
  }
  params;
  constructor(A) {
    this.params = A;
  }
  static getSchema() {
    return this.schema;
  }
  schema() {
    return this.__proto__.constructor.schema;
  }
  getSchema() {
    return this.__proto__.constructor.getSchema();
  }
  getSchemaZod() {
    return this.__proto__.constructor.getSchemaZod();
  }
  static getSchemaZod() {
    const A = { ...this.getSchema() };
    let e3 = {}, t2 = A.requestBody;
    const r2 = {}, n2 = {};
    t2 && t2.$customRequestBody ? n2.requestBody = t2.content : t2 && (g(t2) || (t2 = w(t2)), t2 = { content: { "application/json": { schema: t2 } } }, e3.body = t2), A.responses || (A.responses = { 200: { description: "Successfull response", schema: {} } });
    for (const [e4, t3] of Object.entries(A.responses)) {
      let A2 = t3.schema || {};
      g(A2) || (A2 = w(A2));
      const n3 = t3.contentType || "application/json";
      r2[e4] = { description: t3.description, content: { [n3]: { schema: A2 } } };
    }
    if (A.parameters) {
      let t3 = A.parameters;
      const r3 = {};
      Array.isArray(t3) && (t3 = t3.reduce((A2, e4) => Object.assign(A2, { [e4.name]: e4 }), {}));
      for (const [A2, e4] of Object.entries(t3))
        r3[e4.location] || (r3[e4.location] = {}), r3[e4.location][A2] = e4.type;
      for (const [A2, e4] of Object.entries(r3))
        r3[A2] = z.object(e4);
      e3 = { ...e3, ...r3 };
    }
    return delete A.requestBody, delete A.parameters, delete A.responses, { ...A, request: { ...e3 }, responses: r2, ...n2 };
  }
  handleValidationError(A) {
    return X({ errors: A, success: false, result: {} }, { status: 400 });
  }
  async execute(...A) {
    const { data: e3, errors: t2 } = await this.validateRequest(A[0]);
    if (t2)
      return this.handleValidationError(t2);
    A.push(e3);
    const r2 = await this.handle(...A);
    return r2 instanceof Response || "object" != typeof r2 ? r2 : X(r2);
  }
  extractQueryParameters(A, e3) {
    return Z(A, e3);
  }
  async validateRequest(A) {
    const e3 = this.__proto__.constructor.getSchemaZod(), t2 = {}, r2 = {};
    e3.request?.params && (r2.params = e3.request?.params, t2.params = A.params), e3.request?.query && (r2.query = e3.request?.query, t2.query = {}), e3.request?.headers && (r2.headers = e3.request?.headers, t2.headers = {});
    const n2 = this.extractQueryParameters(A, e3.request?.query);
    if (n2 && (t2.query = n2), e3.request?.headers) {
      t2.headers = {};
      for (const r3 of Object.keys(e3.request?.headers.shape))
        t2.headers[r3] = A.headers.get(r3);
    }
    if ("get" !== A.method.toLowerCase() && e3.request?.body && e3.request?.body.content["application/json"] && e3.request?.body.content["application/json"].schema) {
      r2.body = e3.request.body.content["application/json"].schema;
      try {
        t2.body = await A.json();
      } catch (A2) {
        t2.body = {};
      }
    }
    let o2 = z.object(r2);
    void 0 !== this.params?.raiseUnknownParameters && true !== this.params?.raiseUnknownParameters || (o2 = o2.strict());
    const a2 = o2.safeParse(t2);
    return { data: a2.success ? a2.data : void 0, errors: a2.success ? void 0 : a2.error.issues };
  }
};
__publicField(K, "isRoute", true);
__publicField(K, "schema");

// src/endpoints/zendeskEvents.ts
init_checked_fetch();
init_modules_watch_stub();

// lib/drizzle.ts
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/neon-http/driver.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/@neondatabase/serverless/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var Xs = Object.create;
var Ie = Object.defineProperty;
var eo = Object.getOwnPropertyDescriptor;
var to = Object.getOwnPropertyNames;
var ro = Object.getPrototypeOf;
var no = Object.prototype.hasOwnProperty;
var io = (r2, e3, t2) => e3 in r2 ? Ie(r2, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e3] = t2;
var a = (r2, e3) => Ie(r2, "name", { value: e3, configurable: true });
var K2 = (r2, e3) => () => (r2 && (e3 = r2(r2 = 0)), e3);
var I = (r2, e3) => () => (e3 || r2((e3 = { exports: {} }).exports, e3), e3.exports);
var X2 = (r2, e3) => {
  for (var t2 in e3)
    Ie(r2, t2, { get: e3[t2], enumerable: true });
};
var _n = (r2, e3, t2, n2) => {
  if (e3 && typeof e3 == "object" || typeof e3 == "function")
    for (let i2 of to(e3))
      !no.call(r2, i2) && i2 !== t2 && Ie(r2, i2, { get: () => e3[i2], enumerable: !(n2 = eo(e3, i2)) || n2.enumerable });
  return r2;
};
var We = (r2, e3, t2) => (t2 = r2 != null ? Xs(ro(r2)) : {}, _n(e3 || !r2 || !r2.__esModule ? Ie(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var k = (r2) => _n(Ie({}, "__esModule", { value: true }), r2);
var T = (r2, e3, t2) => (io(r2, typeof e3 != "symbol" ? e3 + "" : e3, t2), t2);
var In = I((it) => {
  "use strict";
  p3();
  it.byteLength = oo;
  it.toByteArray = uo;
  it.fromByteArray = lo;
  var oe = [], ee = [], so = typeof Uint8Array < "u" ? Uint8Array : Array, It = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Ee = 0, An = It.length; Ee < An; ++Ee)
    oe[Ee] = It[Ee], ee[It.charCodeAt(Ee)] = Ee;
  var Ee, An;
  ee[45] = 62;
  ee[95] = 63;
  function Cn(r2) {
    var e3 = r2.length;
    if (e3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t2 = r2.indexOf("=");
    t2 === -1 && (t2 = e3);
    var n2 = t2 === e3 ? 0 : 4 - t2 % 4;
    return [t2, n2];
  }
  a(
    Cn,
    "getLens"
  );
  function oo(r2) {
    var e3 = Cn(r2), t2 = e3[0], n2 = e3[1];
    return (t2 + n2) * 3 / 4 - n2;
  }
  a(oo, "byteLength");
  function ao(r2, e3, t2) {
    return (e3 + t2) * 3 / 4 - t2;
  }
  a(ao, "_byteLength");
  function uo(r2) {
    var e3, t2 = Cn(r2), n2 = t2[0], i2 = t2[1], s2 = new so(ao(r2, n2, i2)), o2 = 0, u2 = i2 > 0 ? n2 - 4 : n2, c3;
    for (c3 = 0; c3 < u2; c3 += 4)
      e3 = ee[r2.charCodeAt(c3)] << 18 | ee[r2.charCodeAt(c3 + 1)] << 12 | ee[r2.charCodeAt(c3 + 2)] << 6 | ee[r2.charCodeAt(c3 + 3)], s2[o2++] = e3 >> 16 & 255, s2[o2++] = e3 >> 8 & 255, s2[o2++] = e3 & 255;
    return i2 === 2 && (e3 = ee[r2.charCodeAt(c3)] << 2 | ee[r2.charCodeAt(c3 + 1)] >> 4, s2[o2++] = e3 & 255), i2 === 1 && (e3 = ee[r2.charCodeAt(
      c3
    )] << 10 | ee[r2.charCodeAt(c3 + 1)] << 4 | ee[r2.charCodeAt(c3 + 2)] >> 2, s2[o2++] = e3 >> 8 & 255, s2[o2++] = e3 & 255), s2;
  }
  a(uo, "toByteArray");
  function co(r2) {
    return oe[r2 >> 18 & 63] + oe[r2 >> 12 & 63] + oe[r2 >> 6 & 63] + oe[r2 & 63];
  }
  a(co, "tripletToBase64");
  function ho(r2, e3, t2) {
    for (var n2, i2 = [], s2 = e3; s2 < t2; s2 += 3)
      n2 = (r2[s2] << 16 & 16711680) + (r2[s2 + 1] << 8 & 65280) + (r2[s2 + 2] & 255), i2.push(co(n2));
    return i2.join(
      ""
    );
  }
  a(ho, "encodeChunk");
  function lo(r2) {
    for (var e3, t2 = r2.length, n2 = t2 % 3, i2 = [], s2 = 16383, o2 = 0, u2 = t2 - n2; o2 < u2; o2 += s2)
      i2.push(ho(r2, o2, o2 + s2 > u2 ? u2 : o2 + s2));
    return n2 === 1 ? (e3 = r2[t2 - 1], i2.push(oe[e3 >> 2] + oe[e3 << 4 & 63] + "==")) : n2 === 2 && (e3 = (r2[t2 - 2] << 8) + r2[t2 - 1], i2.push(oe[e3 >> 10] + oe[e3 >> 4 & 63] + oe[e3 << 2 & 63] + "=")), i2.join("");
  }
  a(lo, "fromByteArray");
});
var Tn = I((Tt) => {
  p3();
  Tt.read = function(r2, e3, t2, n2, i2) {
    var s2, o2, u2 = i2 * 8 - n2 - 1, c3 = (1 << u2) - 1, h2 = c3 >> 1, l3 = -7, y2 = t2 ? i2 - 1 : 0, E = t2 ? -1 : 1, _ = r2[e3 + y2];
    for (y2 += E, s2 = _ & (1 << -l3) - 1, _ >>= -l3, l3 += u2; l3 > 0; s2 = s2 * 256 + r2[e3 + y2], y2 += E, l3 -= 8)
      ;
    for (o2 = s2 & (1 << -l3) - 1, s2 >>= -l3, l3 += n2; l3 > 0; o2 = o2 * 256 + r2[e3 + y2], y2 += E, l3 -= 8)
      ;
    if (s2 === 0)
      s2 = 1 - h2;
    else {
      if (s2 === c3)
        return o2 ? NaN : (_ ? -1 : 1) * (1 / 0);
      o2 = o2 + Math.pow(2, n2), s2 = s2 - h2;
    }
    return (_ ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
  };
  Tt.write = function(r2, e3, t2, n2, i2, s2) {
    var o2, u2, c3, h2 = s2 * 8 - i2 - 1, l3 = (1 << h2) - 1, y2 = l3 >> 1, E = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, _ = n2 ? 0 : s2 - 1, P2 = n2 ? 1 : -1, N = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
    for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (u2 = isNaN(e3) ? 1 : 0, o2 = l3) : (o2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (c3 = Math.pow(2, -o2)) < 1 && (o2--, c3 *= 2), o2 + y2 >= 1 ? e3 += E / c3 : e3 += E * Math.pow(2, 1 - y2), e3 * c3 >= 2 && (o2++, c3 /= 2), o2 + y2 >= l3 ? (u2 = 0, o2 = l3) : o2 + y2 >= 1 ? (u2 = (e3 * c3 - 1) * Math.pow(
      2,
      i2
    ), o2 = o2 + y2) : (u2 = e3 * Math.pow(2, y2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; r2[t2 + _] = u2 & 255, _ += P2, u2 /= 256, i2 -= 8)
      ;
    for (o2 = o2 << i2 | u2, h2 += i2; h2 > 0; r2[t2 + _] = o2 & 255, _ += P2, o2 /= 256, h2 -= 8)
      ;
    r2[t2 + _ - P2] |= N * 128;
  };
});
var Gn = I((Le) => {
  "use strict";
  p3();
  var Pt = In(), Pe = Tn(), Pn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Le.Buffer = f2;
  Le.SlowBuffer = wo;
  Le.INSPECT_MAX_BYTES = 50;
  var st = 2147483647;
  Le.kMaxLength = st;
  f2.TYPED_ARRAY_SUPPORT = fo();
  !f2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function fo() {
    try {
      let r2 = new Uint8Array(1), e3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(r2, e3), r2.foo() === 42;
    } catch {
      return false;
    }
  }
  a(fo, "typedArraySupport");
  Object.defineProperty(
    f2.prototype,
    "parent",
    { enumerable: true, get: function() {
      if (f2.isBuffer(this))
        return this.buffer;
    } }
  );
  Object.defineProperty(f2.prototype, "offset", { enumerable: true, get: function() {
    if (f2.isBuffer(
      this
    ))
      return this.byteOffset;
  } });
  function le(r2) {
    if (r2 > st)
      throw new RangeError('The value "' + r2 + '" is invalid for option "size"');
    let e3 = new Uint8Array(r2);
    return Object.setPrototypeOf(e3, f2.prototype), e3;
  }
  a(le, "createBuffer");
  function f2(r2, e3, t2) {
    if (typeof r2 == "number") {
      if (typeof e3 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Ft(r2);
    }
    return Fn(r2, e3, t2);
  }
  a(f2, "Buffer");
  f2.poolSize = 8192;
  function Fn(r2, e3, t2) {
    if (typeof r2 == "string")
      return yo(r2, e3);
    if (ArrayBuffer.isView(r2))
      return mo(r2);
    if (r2 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r2);
    if (ae(r2, ArrayBuffer) || r2 && ae(r2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ae(r2, SharedArrayBuffer) || r2 && ae(r2.buffer, SharedArrayBuffer)))
      return Lt(
        r2,
        e3,
        t2
      );
    if (typeof r2 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n2 = r2.valueOf && r2.valueOf();
    if (n2 != null && n2 !== r2)
      return f2.from(n2, e3, t2);
    let i2 = go(r2);
    if (i2)
      return i2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r2[Symbol.toPrimitive] == "function")
      return f2.from(r2[Symbol.toPrimitive](
        "string"
      ), e3, t2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r2);
  }
  a(
    Fn,
    "from"
  );
  f2.from = function(r2, e3, t2) {
    return Fn(r2, e3, t2);
  };
  Object.setPrototypeOf(
    f2.prototype,
    Uint8Array.prototype
  );
  Object.setPrototypeOf(f2, Uint8Array);
  function Mn(r2) {
    if (typeof r2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (r2 < 0)
      throw new RangeError(
        'The value "' + r2 + '" is invalid for option "size"'
      );
  }
  a(Mn, "assertSize");
  function po(r2, e3, t2) {
    return Mn(r2), r2 <= 0 ? le(r2) : e3 !== void 0 ? typeof t2 == "string" ? le(r2).fill(e3, t2) : le(r2).fill(
      e3
    ) : le(r2);
  }
  a(po, "alloc");
  f2.alloc = function(r2, e3, t2) {
    return po(r2, e3, t2);
  };
  function Ft(r2) {
    return Mn(r2), le(r2 < 0 ? 0 : Mt(r2) | 0);
  }
  a(Ft, "allocUnsafe");
  f2.allocUnsafe = function(r2) {
    return Ft(
      r2
    );
  };
  f2.allocUnsafeSlow = function(r2) {
    return Ft(r2);
  };
  function yo(r2, e3) {
    if ((typeof e3 != "string" || e3 === "") && (e3 = "utf8"), !f2.isEncoding(e3))
      throw new TypeError("Unknown encoding: " + e3);
    let t2 = Dn(r2, e3) | 0, n2 = le(t2), i2 = n2.write(r2, e3);
    return i2 !== t2 && (n2 = n2.slice(0, i2)), n2;
  }
  a(yo, "fromString");
  function Bt(r2) {
    let e3 = r2.length < 0 ? 0 : Mt(r2.length) | 0, t2 = le(e3);
    for (let n2 = 0; n2 < e3; n2 += 1)
      t2[n2] = r2[n2] & 255;
    return t2;
  }
  a(Bt, "fromArrayLike");
  function mo(r2) {
    if (ae(r2, Uint8Array)) {
      let e3 = new Uint8Array(r2);
      return Lt(e3.buffer, e3.byteOffset, e3.byteLength);
    }
    return Bt(
      r2
    );
  }
  a(mo, "fromArrayView");
  function Lt(r2, e3, t2) {
    if (e3 < 0 || r2.byteLength < e3)
      throw new RangeError(
        '"offset" is outside of buffer bounds'
      );
    if (r2.byteLength < e3 + (t2 || 0))
      throw new RangeError(
        '"length" is outside of buffer bounds'
      );
    let n2;
    return e3 === void 0 && t2 === void 0 ? n2 = new Uint8Array(
      r2
    ) : t2 === void 0 ? n2 = new Uint8Array(r2, e3) : n2 = new Uint8Array(r2, e3, t2), Object.setPrototypeOf(
      n2,
      f2.prototype
    ), n2;
  }
  a(Lt, "fromArrayBuffer");
  function go(r2) {
    if (f2.isBuffer(r2)) {
      let e3 = Mt(
        r2.length
      ) | 0, t2 = le(e3);
      return t2.length === 0 || r2.copy(t2, 0, 0, e3), t2;
    }
    if (r2.length !== void 0)
      return typeof r2.length != "number" || Ot(r2.length) ? le(0) : Bt(r2);
    if (r2.type === "Buffer" && Array.isArray(r2.data))
      return Bt(r2.data);
  }
  a(go, "fromObject");
  function Mt(r2) {
    if (r2 >= st)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + st.toString(16) + " bytes");
    return r2 | 0;
  }
  a(Mt, "checked");
  function wo(r2) {
    return +r2 != r2 && (r2 = 0), f2.alloc(+r2);
  }
  a(wo, "SlowBuffer");
  f2.isBuffer = a(function(e3) {
    return e3 != null && e3._isBuffer === true && e3 !== f2.prototype;
  }, "isBuffer");
  f2.compare = a(function(e3, t2) {
    if (ae(e3, Uint8Array) && (e3 = f2.from(e3, e3.offset, e3.byteLength)), ae(t2, Uint8Array) && (t2 = f2.from(t2, t2.offset, t2.byteLength)), !f2.isBuffer(e3) || !f2.isBuffer(t2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t2)
      return 0;
    let n2 = e3.length, i2 = t2.length;
    for (let s2 = 0, o2 = Math.min(n2, i2); s2 < o2; ++s2)
      if (e3[s2] !== t2[s2]) {
        n2 = e3[s2], i2 = t2[s2];
        break;
      }
    return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
  }, "compare");
  f2.isEncoding = a(function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  f2.concat = a(function(e3, t2) {
    if (!Array.isArray(e3))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e3.length === 0)
      return f2.alloc(0);
    let n2;
    if (t2 === void 0)
      for (t2 = 0, n2 = 0; n2 < e3.length; ++n2)
        t2 += e3[n2].length;
    let i2 = f2.allocUnsafe(t2), s2 = 0;
    for (n2 = 0; n2 < e3.length; ++n2) {
      let o2 = e3[n2];
      if (ae(o2, Uint8Array))
        s2 + o2.length > i2.length ? (f2.isBuffer(
          o2
        ) || (o2 = f2.from(o2)), o2.copy(i2, s2)) : Uint8Array.prototype.set.call(i2, o2, s2);
      else if (f2.isBuffer(
        o2
      ))
        o2.copy(i2, s2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      s2 += o2.length;
    }
    return i2;
  }, "concat");
  function Dn(r2, e3) {
    if (f2.isBuffer(r2))
      return r2.length;
    if (ArrayBuffer.isView(r2) || ae(r2, ArrayBuffer))
      return r2.byteLength;
    if (typeof r2 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r2);
    let t2 = r2.length, n2 = arguments.length > 2 && arguments[2] === true;
    if (!n2 && t2 === 0)
      return 0;
    let i2 = false;
    for (; ; )
      switch (e3) {
        case "ascii":
        case "latin1":
        case "binary":
          return t2;
        case "utf8":
        case "utf-8":
          return Rt(r2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t2 * 2;
        case "hex":
          return t2 >>> 1;
        case "base64":
          return Hn(r2).length;
        default:
          if (i2)
            return n2 ? -1 : Rt(r2).length;
          e3 = ("" + e3).toLowerCase(), i2 = true;
      }
  }
  a(Dn, "byteLength");
  f2.byteLength = Dn;
  function bo(r2, e3, t2) {
    let n2 = false;
    if ((e3 === void 0 || e3 < 0) && (e3 = 0), e3 > this.length || ((t2 === void 0 || t2 > this.length) && (t2 = this.length), t2 <= 0) || (t2 >>>= 0, e3 >>>= 0, t2 <= e3))
      return "";
    for (r2 || (r2 = "utf8"); ; )
      switch (r2) {
        case "hex":
          return Po(
            this,
            e3,
            t2
          );
        case "utf8":
        case "utf-8":
          return kn(this, e3, t2);
        case "ascii":
          return Io(
            this,
            e3,
            t2
          );
        case "latin1":
        case "binary":
          return To(this, e3, t2);
        case "base64":
          return Ao(
            this,
            e3,
            t2
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Bo(this, e3, t2);
        default:
          if (n2)
            throw new TypeError("Unknown encoding: " + r2);
          r2 = (r2 + "").toLowerCase(), n2 = true;
      }
  }
  a(
    bo,
    "slowToString"
  );
  f2.prototype._isBuffer = true;
  function ve(r2, e3, t2) {
    let n2 = r2[e3];
    r2[e3] = r2[t2], r2[t2] = n2;
  }
  a(ve, "swap");
  f2.prototype.swap16 = a(function() {
    let e3 = this.length;
    if (e3 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t2 = 0; t2 < e3; t2 += 2)
      ve(this, t2, t2 + 1);
    return this;
  }, "swap16");
  f2.prototype.swap32 = a(function() {
    let e3 = this.length;
    if (e3 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t2 = 0; t2 < e3; t2 += 4)
      ve(this, t2, t2 + 3), ve(this, t2 + 1, t2 + 2);
    return this;
  }, "swap32");
  f2.prototype.swap64 = a(function() {
    let e3 = this.length;
    if (e3 % 8 !== 0)
      throw new RangeError(
        "Buffer size must be a multiple of 64-bits"
      );
    for (let t2 = 0; t2 < e3; t2 += 8)
      ve(this, t2, t2 + 7), ve(this, t2 + 1, t2 + 6), ve(this, t2 + 2, t2 + 5), ve(this, t2 + 3, t2 + 4);
    return this;
  }, "swap64");
  f2.prototype.toString = a(function() {
    let e3 = this.length;
    return e3 === 0 ? "" : arguments.length === 0 ? kn(
      this,
      0,
      e3
    ) : bo.apply(this, arguments);
  }, "toString");
  f2.prototype.toLocaleString = f2.prototype.toString;
  f2.prototype.equals = a(function(e3) {
    if (!f2.isBuffer(e3))
      throw new TypeError(
        "Argument must be a Buffer"
      );
    return this === e3 ? true : f2.compare(this, e3) === 0;
  }, "equals");
  f2.prototype.inspect = a(function() {
    let e3 = "", t2 = Le.INSPECT_MAX_BYTES;
    return e3 = this.toString(
      "hex",
      0,
      t2
    ).replace(/(.{2})/g, "$1 ").trim(), this.length > t2 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, "inspect");
  Pn && (f2.prototype[Pn] = f2.prototype.inspect);
  f2.prototype.compare = a(function(e3, t2, n2, i2, s2) {
    if (ae(e3, Uint8Array) && (e3 = f2.from(e3, e3.offset, e3.byteLength)), !f2.isBuffer(e3))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e3 ? e3.length : 0), i2 === void 0 && (i2 = 0), s2 === void 0 && (s2 = this.length), t2 < 0 || n2 > e3.length || i2 < 0 || s2 > this.length)
      throw new RangeError("out of range index");
    if (i2 >= s2 && t2 >= n2)
      return 0;
    if (i2 >= s2)
      return -1;
    if (t2 >= n2)
      return 1;
    if (t2 >>>= 0, n2 >>>= 0, i2 >>>= 0, s2 >>>= 0, this === e3)
      return 0;
    let o2 = s2 - i2, u2 = n2 - t2, c3 = Math.min(o2, u2), h2 = this.slice(i2, s2), l3 = e3.slice(t2, n2);
    for (let y2 = 0; y2 < c3; ++y2)
      if (h2[y2] !== l3[y2]) {
        o2 = h2[y2], u2 = l3[y2];
        break;
      }
    return o2 < u2 ? -1 : u2 < o2 ? 1 : 0;
  }, "compare");
  function On(r2, e3, t2, n2, i2) {
    if (r2.length === 0)
      return -1;
    if (typeof t2 == "string" ? (n2 = t2, t2 = 0) : t2 > 2147483647 ? t2 = 2147483647 : t2 < -2147483648 && (t2 = -2147483648), t2 = +t2, Ot(t2) && (t2 = i2 ? 0 : r2.length - 1), t2 < 0 && (t2 = r2.length + t2), t2 >= r2.length) {
      if (i2)
        return -1;
      t2 = r2.length - 1;
    } else if (t2 < 0)
      if (i2)
        t2 = 0;
      else
        return -1;
    if (typeof e3 == "string" && (e3 = f2.from(e3, n2)), f2.isBuffer(e3))
      return e3.length === 0 ? -1 : Bn(r2, e3, t2, n2, i2);
    if (typeof e3 == "number")
      return e3 = e3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(r2, e3, t2) : Uint8Array.prototype.lastIndexOf.call(r2, e3, t2) : Bn(
        r2,
        [e3],
        t2,
        n2,
        i2
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  a(On, "bidirectionalIndexOf");
  function Bn(r2, e3, t2, n2, i2) {
    let s2 = 1, o2 = r2.length, u2 = e3.length;
    if (n2 !== void 0 && (n2 = String(n2).toLowerCase(), n2 === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
      if (r2.length < 2 || e3.length < 2)
        return -1;
      s2 = 2, o2 /= 2, u2 /= 2, t2 /= 2;
    }
    function c3(l3, y2) {
      return s2 === 1 ? l3[y2] : l3.readUInt16BE(y2 * s2);
    }
    a(c3, "read");
    let h2;
    if (i2) {
      let l3 = -1;
      for (h2 = t2; h2 < o2; h2++)
        if (c3(r2, h2) === c3(e3, l3 === -1 ? 0 : h2 - l3)) {
          if (l3 === -1 && (l3 = h2), h2 - l3 + 1 === u2)
            return l3 * s2;
        } else
          l3 !== -1 && (h2 -= h2 - l3), l3 = -1;
    } else
      for (t2 + u2 > o2 && (t2 = o2 - u2), h2 = t2; h2 >= 0; h2--) {
        let l3 = true;
        for (let y2 = 0; y2 < u2; y2++)
          if (c3(r2, h2 + y2) !== c3(e3, y2)) {
            l3 = false;
            break;
          }
        if (l3)
          return h2;
      }
    return -1;
  }
  a(Bn, "arrayIndexOf");
  f2.prototype.includes = a(function(e3, t2, n2) {
    return this.indexOf(e3, t2, n2) !== -1;
  }, "includes");
  f2.prototype.indexOf = a(function(e3, t2, n2) {
    return On(this, e3, t2, n2, true);
  }, "indexOf");
  f2.prototype.lastIndexOf = a(function(e3, t2, n2) {
    return On(this, e3, t2, n2, false);
  }, "lastIndexOf");
  function So(r2, e3, t2, n2) {
    t2 = Number(t2) || 0;
    let i2 = r2.length - t2;
    n2 ? (n2 = Number(n2), n2 > i2 && (n2 = i2)) : n2 = i2;
    let s2 = e3.length;
    n2 > s2 / 2 && (n2 = s2 / 2);
    let o2;
    for (o2 = 0; o2 < n2; ++o2) {
      let u2 = parseInt(e3.substr(o2 * 2, 2), 16);
      if (Ot(u2))
        return o2;
      r2[t2 + o2] = u2;
    }
    return o2;
  }
  a(So, "hexWrite");
  function xo(r2, e3, t2, n2) {
    return ot(Rt(
      e3,
      r2.length - t2
    ), r2, t2, n2);
  }
  a(xo, "utf8Write");
  function Eo(r2, e3, t2, n2) {
    return ot(Mo(e3), r2, t2, n2);
  }
  a(Eo, "asciiWrite");
  function vo(r2, e3, t2, n2) {
    return ot(Hn(e3), r2, t2, n2);
  }
  a(vo, "base64Write");
  function _o(r2, e3, t2, n2) {
    return ot(Do(e3, r2.length - t2), r2, t2, n2);
  }
  a(_o, "ucs2Write");
  f2.prototype.write = a(function(e3, t2, n2, i2) {
    if (t2 === void 0)
      i2 = "utf8", n2 = this.length, t2 = 0;
    else if (n2 === void 0 && typeof t2 == "string")
      i2 = t2, n2 = this.length, t2 = 0;
    else if (isFinite(t2))
      t2 = t2 >>> 0, isFinite(n2) ? (n2 = n2 >>> 0, i2 === void 0 && (i2 = "utf8")) : (i2 = n2, n2 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s2 = this.length - t2;
    if ((n2 === void 0 || n2 > s2) && (n2 = s2), e3.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError(
        "Attempt to write outside buffer bounds"
      );
    i2 || (i2 = "utf8");
    let o2 = false;
    for (; ; )
      switch (i2) {
        case "hex":
          return So(this, e3, t2, n2);
        case "utf8":
        case "utf-8":
          return xo(this, e3, t2, n2);
        case "ascii":
        case "latin1":
        case "binary":
          return Eo(this, e3, t2, n2);
        case "base64":
          return vo(
            this,
            e3,
            t2,
            n2
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _o(this, e3, t2, n2);
        default:
          if (o2)
            throw new TypeError("Unknown encoding: " + i2);
          i2 = ("" + i2).toLowerCase(), o2 = true;
      }
  }, "write");
  f2.prototype.toJSON = a(function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  }, "toJSON");
  function Ao(r2, e3, t2) {
    return e3 === 0 && t2 === r2.length ? Pt.fromByteArray(r2) : Pt.fromByteArray(r2.slice(e3, t2));
  }
  a(Ao, "base64Slice");
  function kn(r2, e3, t2) {
    t2 = Math.min(r2.length, t2);
    let n2 = [], i2 = e3;
    for (; i2 < t2; ) {
      let s2 = r2[i2], o2 = null, u2 = s2 > 239 ? 4 : s2 > 223 ? 3 : s2 > 191 ? 2 : 1;
      if (i2 + u2 <= t2) {
        let c3, h2, l3, y2;
        switch (u2) {
          case 1:
            s2 < 128 && (o2 = s2);
            break;
          case 2:
            c3 = r2[i2 + 1], (c3 & 192) === 128 && (y2 = (s2 & 31) << 6 | c3 & 63, y2 > 127 && (o2 = y2));
            break;
          case 3:
            c3 = r2[i2 + 1], h2 = r2[i2 + 2], (c3 & 192) === 128 && (h2 & 192) === 128 && (y2 = (s2 & 15) << 12 | (c3 & 63) << 6 | h2 & 63, y2 > 2047 && (y2 < 55296 || y2 > 57343) && (o2 = y2));
            break;
          case 4:
            c3 = r2[i2 + 1], h2 = r2[i2 + 2], l3 = r2[i2 + 3], (c3 & 192) === 128 && (h2 & 192) === 128 && (l3 & 192) === 128 && (y2 = (s2 & 15) << 18 | (c3 & 63) << 12 | (h2 & 63) << 6 | l3 & 63, y2 > 65535 && y2 < 1114112 && (o2 = y2));
        }
      }
      o2 === null ? (o2 = 65533, u2 = 1) : o2 > 65535 && (o2 -= 65536, n2.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | o2 & 1023), n2.push(o2), i2 += u2;
    }
    return Co(n2);
  }
  a(kn, "utf8Slice");
  var Ln = 4096;
  function Co(r2) {
    let e3 = r2.length;
    if (e3 <= Ln)
      return String.fromCharCode.apply(String, r2);
    let t2 = "", n2 = 0;
    for (; n2 < e3; )
      t2 += String.fromCharCode.apply(String, r2.slice(n2, n2 += Ln));
    return t2;
  }
  a(Co, "decodeCodePointsArray");
  function Io(r2, e3, t2) {
    let n2 = "";
    t2 = Math.min(r2.length, t2);
    for (let i2 = e3; i2 < t2; ++i2)
      n2 += String.fromCharCode(r2[i2] & 127);
    return n2;
  }
  a(Io, "asciiSlice");
  function To(r2, e3, t2) {
    let n2 = "";
    t2 = Math.min(r2.length, t2);
    for (let i2 = e3; i2 < t2; ++i2)
      n2 += String.fromCharCode(r2[i2]);
    return n2;
  }
  a(To, "latin1Slice");
  function Po(r2, e3, t2) {
    let n2 = r2.length;
    (!e3 || e3 < 0) && (e3 = 0), (!t2 || t2 < 0 || t2 > n2) && (t2 = n2);
    let i2 = "";
    for (let s2 = e3; s2 < t2; ++s2)
      i2 += Oo[r2[s2]];
    return i2;
  }
  a(Po, "hexSlice");
  function Bo(r2, e3, t2) {
    let n2 = r2.slice(e3, t2), i2 = "";
    for (let s2 = 0; s2 < n2.length - 1; s2 += 2)
      i2 += String.fromCharCode(n2[s2] + n2[s2 + 1] * 256);
    return i2;
  }
  a(Bo, "utf16leSlice");
  f2.prototype.slice = a(function(e3, t2) {
    let n2 = this.length;
    e3 = ~~e3, t2 = t2 === void 0 ? n2 : ~~t2, e3 < 0 ? (e3 += n2, e3 < 0 && (e3 = 0)) : e3 > n2 && (e3 = n2), t2 < 0 ? (t2 += n2, t2 < 0 && (t2 = 0)) : t2 > n2 && (t2 = n2), t2 < e3 && (t2 = e3);
    let i2 = this.subarray(
      e3,
      t2
    );
    return Object.setPrototypeOf(i2, f2.prototype), i2;
  }, "slice");
  function U(r2, e3, t2) {
    if (r2 % 1 !== 0 || r2 < 0)
      throw new RangeError("offset is not uint");
    if (r2 + e3 > t2)
      throw new RangeError(
        "Trying to access beyond buffer length"
      );
  }
  a(U, "checkOffset");
  f2.prototype.readUintLE = f2.prototype.readUIntLE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3], s2 = 1, o2 = 0;
    for (; ++o2 < t2 && (s2 *= 256); )
      i2 += this[e3 + o2] * s2;
    return i2;
  }, "readUIntLE");
  f2.prototype.readUintBE = f2.prototype.readUIntBE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3 + --t2], s2 = 1;
    for (; t2 > 0 && (s2 *= 256); )
      i2 += this[e3 + --t2] * s2;
    return i2;
  }, "readUIntBE");
  f2.prototype.readUint8 = f2.prototype.readUInt8 = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 1, this.length), this[e3];
  }, "readUInt8");
  f2.prototype.readUint16LE = f2.prototype.readUInt16LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, "readUInt16LE");
  f2.prototype.readUint16BE = f2.prototype.readUInt16BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, "readUInt16BE");
  f2.prototype.readUint32LE = f2.prototype.readUInt32LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + this[e3 + 3] * 16777216;
  }, "readUInt32LE");
  f2.prototype.readUint32BE = f2.prototype.readUInt32BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] * 16777216 + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, "readUInt32BE");
  f2.prototype.readBigUInt64LE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = t2 + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 24, s2 = this[++e3] + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + n2 * 2 ** 24;
    return BigInt(i2) + (BigInt(s2) << BigInt(32));
  }, "readBigUInt64LE"));
  f2.prototype.readBigUInt64BE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = t2 * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + this[++e3], s2 = this[++e3] * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + n2;
    return (BigInt(
      i2
    ) << BigInt(32)) + BigInt(s2);
  }, "readBigUInt64BE"));
  f2.prototype.readIntLE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = this[e3], s2 = 1, o2 = 0;
    for (; ++o2 < t2 && (s2 *= 256); )
      i2 += this[e3 + o2] * s2;
    return s2 *= 128, i2 >= s2 && (i2 -= Math.pow(2, 8 * t2)), i2;
  }, "readIntLE");
  f2.prototype.readIntBE = a(function(e3, t2, n2) {
    e3 = e3 >>> 0, t2 = t2 >>> 0, n2 || U(e3, t2, this.length);
    let i2 = t2, s2 = 1, o2 = this[e3 + --i2];
    for (; i2 > 0 && (s2 *= 256); )
      o2 += this[e3 + --i2] * s2;
    return s2 *= 128, o2 >= s2 && (o2 -= Math.pow(2, 8 * t2)), o2;
  }, "readIntBE");
  f2.prototype.readInt8 = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 1, this.length), this[e3] & 128 ? (255 - this[e3] + 1) * -1 : this[e3];
  }, "readInt8");
  f2.prototype.readInt16LE = a(function(e3, t2) {
    e3 = e3 >>> 0, t2 || U(e3, 2, this.length);
    let n2 = this[e3] | this[e3 + 1] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  }, "readInt16LE");
  f2.prototype.readInt16BE = a(
    function(e3, t2) {
      e3 = e3 >>> 0, t2 || U(e3, 2, this.length);
      let n2 = this[e3 + 1] | this[e3] << 8;
      return n2 & 32768 ? n2 | 4294901760 : n2;
    },
    "readInt16BE"
  );
  f2.prototype.readInt32LE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, "readInt32LE");
  f2.prototype.readInt32BE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, "readInt32BE");
  f2.prototype.readBigInt64LE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(
      e3,
      this.length - 8
    );
    let i2 = this[e3 + 4] + this[e3 + 5] * 2 ** 8 + this[e3 + 6] * 2 ** 16 + (n2 << 24);
    return (BigInt(
      i2
    ) << BigInt(32)) + BigInt(t2 + this[++e3] * 2 ** 8 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 24);
  }, "readBigInt64LE"));
  f2.prototype.readBigInt64BE = me(a(function(e3) {
    e3 = e3 >>> 0, Be(e3, "offset");
    let t2 = this[e3], n2 = this[e3 + 7];
    (t2 === void 0 || n2 === void 0) && je(e3, this.length - 8);
    let i2 = (t2 << 24) + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + this[++e3];
    return (BigInt(i2) << BigInt(32)) + BigInt(
      this[++e3] * 2 ** 24 + this[++e3] * 2 ** 16 + this[++e3] * 2 ** 8 + n2
    );
  }, "readBigInt64BE"));
  f2.prototype.readFloatLE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), Pe.read(
      this,
      e3,
      true,
      23,
      4
    );
  }, "readFloatLE");
  f2.prototype.readFloatBE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 4, this.length), Pe.read(this, e3, false, 23, 4);
  }, "readFloatBE");
  f2.prototype.readDoubleLE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 8, this.length), Pe.read(this, e3, true, 52, 8);
  }, "readDoubleLE");
  f2.prototype.readDoubleBE = a(function(e3, t2) {
    return e3 = e3 >>> 0, t2 || U(e3, 8, this.length), Pe.read(this, e3, false, 52, 8);
  }, "readDoubleBE");
  function z2(r2, e3, t2, n2, i2, s2) {
    if (!f2.isBuffer(
      r2
    ))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e3 > i2 || e3 < s2)
      throw new RangeError('"value" argument is out of bounds');
    if (t2 + n2 > r2.length)
      throw new RangeError(
        "Index out of range"
      );
  }
  a(z2, "checkInt");
  f2.prototype.writeUintLE = f2.prototype.writeUIntLE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      z2(
        this,
        e3,
        t2,
        n2,
        u2,
        0
      );
    }
    let s2 = 1, o2 = 0;
    for (this[t2] = e3 & 255; ++o2 < n2 && (s2 *= 256); )
      this[t2 + o2] = e3 / s2 & 255;
    return t2 + n2;
  }, "writeUIntLE");
  f2.prototype.writeUintBE = f2.prototype.writeUIntBE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      z2(this, e3, t2, n2, u2, 0);
    }
    let s2 = n2 - 1, o2 = 1;
    for (this[t2 + s2] = e3 & 255; --s2 >= 0 && (o2 *= 256); )
      this[t2 + s2] = e3 / o2 & 255;
    return t2 + n2;
  }, "writeUIntBE");
  f2.prototype.writeUint8 = f2.prototype.writeUInt8 = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 1, 255, 0), this[t2] = e3 & 255, t2 + 1;
  }, "writeUInt8");
  f2.prototype.writeUint16LE = f2.prototype.writeUInt16LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      2,
      65535,
      0
    ), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, t2 + 2;
  }, "writeUInt16LE");
  f2.prototype.writeUint16BE = f2.prototype.writeUInt16BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      2,
      65535,
      0
    ), this[t2] = e3 >>> 8, this[t2 + 1] = e3 & 255, t2 + 2;
  }, "writeUInt16BE");
  f2.prototype.writeUint32LE = f2.prototype.writeUInt32LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      4,
      4294967295,
      0
    ), this[t2 + 3] = e3 >>> 24, this[t2 + 2] = e3 >>> 16, this[t2 + 1] = e3 >>> 8, this[t2] = e3 & 255, t2 + 4;
  }, "writeUInt32LE");
  f2.prototype.writeUint32BE = f2.prototype.writeUInt32BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 4294967295, 0), this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = e3 & 255, t2 + 4;
  }, "writeUInt32BE");
  function Un(r2, e3, t2, n2, i2) {
    jn(
      e3,
      n2,
      i2,
      r2,
      t2,
      7
    );
    let s2 = Number(e3 & BigInt(4294967295));
    r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2, s2 = s2 >> 8, r2[t2++] = s2;
    let o2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
    return r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, o2 = o2 >> 8, r2[t2++] = o2, t2;
  }
  a(Un, "wrtBigUInt64LE");
  function qn(r2, e3, t2, n2, i2) {
    jn(e3, n2, i2, r2, t2, 7);
    let s2 = Number(e3 & BigInt(4294967295));
    r2[t2 + 7] = s2, s2 = s2 >> 8, r2[t2 + 6] = s2, s2 = s2 >> 8, r2[t2 + 5] = s2, s2 = s2 >> 8, r2[t2 + 4] = s2;
    let o2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
    return r2[t2 + 3] = o2, o2 = o2 >> 8, r2[t2 + 2] = o2, o2 = o2 >> 8, r2[t2 + 1] = o2, o2 = o2 >> 8, r2[t2] = o2, t2 + 8;
  }
  a(qn, "wrtBigUInt64BE");
  f2.prototype.writeBigUInt64LE = me(a(function(e3, t2 = 0) {
    return Un(this, e3, t2, BigInt(0), BigInt(
      "0xffffffffffffffff"
    ));
  }, "writeBigUInt64LE"));
  f2.prototype.writeBigUInt64BE = me(a(function(e3, t2 = 0) {
    return qn(this, e3, t2, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64BE"));
  f2.prototype.writeIntLE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, !i2) {
      let c3 = Math.pow(
        2,
        8 * n2 - 1
      );
      z2(this, e3, t2, n2, c3 - 1, -c3);
    }
    let s2 = 0, o2 = 1, u2 = 0;
    for (this[t2] = e3 & 255; ++s2 < n2 && (o2 *= 256); )
      e3 < 0 && u2 === 0 && this[t2 + s2 - 1] !== 0 && (u2 = 1), this[t2 + s2] = (e3 / o2 >> 0) - u2 & 255;
    return t2 + n2;
  }, "writeIntLE");
  f2.prototype.writeIntBE = a(function(e3, t2, n2, i2) {
    if (e3 = +e3, t2 = t2 >>> 0, !i2) {
      let c3 = Math.pow(
        2,
        8 * n2 - 1
      );
      z2(this, e3, t2, n2, c3 - 1, -c3);
    }
    let s2 = n2 - 1, o2 = 1, u2 = 0;
    for (this[t2 + s2] = e3 & 255; --s2 >= 0 && (o2 *= 256); )
      e3 < 0 && u2 === 0 && this[t2 + s2 + 1] !== 0 && (u2 = 1), this[t2 + s2] = (e3 / o2 >> 0) - u2 & 255;
    return t2 + n2;
  }, "writeIntBE");
  f2.prototype.writeInt8 = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(
      this,
      e3,
      t2,
      1,
      127,
      -128
    ), e3 < 0 && (e3 = 255 + e3 + 1), this[t2] = e3 & 255, t2 + 1;
  }, "writeInt8");
  f2.prototype.writeInt16LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 2, 32767, -32768), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, t2 + 2;
  }, "writeInt16LE");
  f2.prototype.writeInt16BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 2, 32767, -32768), this[t2] = e3 >>> 8, this[t2 + 1] = e3 & 255, t2 + 2;
  }, "writeInt16BE");
  f2.prototype.writeInt32LE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 2147483647, -2147483648), this[t2] = e3 & 255, this[t2 + 1] = e3 >>> 8, this[t2 + 2] = e3 >>> 16, this[t2 + 3] = e3 >>> 24, t2 + 4;
  }, "writeInt32LE");
  f2.prototype.writeInt32BE = a(function(e3, t2, n2) {
    return e3 = +e3, t2 = t2 >>> 0, n2 || z2(this, e3, t2, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = e3 & 255, t2 + 4;
  }, "writeInt32BE");
  f2.prototype.writeBigInt64LE = me(a(function(e3, t2 = 0) {
    return Un(this, e3, t2, -BigInt(
      "0x8000000000000000"
    ), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  f2.prototype.writeBigInt64BE = me(a(function(e3, t2 = 0) {
    return qn(this, e3, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64BE"));
  function Nn(r2, e3, t2, n2, i2, s2) {
    if (t2 + n2 > r2.length)
      throw new RangeError("Index out of range");
    if (t2 < 0)
      throw new RangeError(
        "Index out of range"
      );
  }
  a(Nn, "checkIEEE754");
  function Qn(r2, e3, t2, n2, i2) {
    return e3 = +e3, t2 = t2 >>> 0, i2 || Nn(r2, e3, t2, 4, 34028234663852886e22, -34028234663852886e22), Pe.write(
      r2,
      e3,
      t2,
      n2,
      23,
      4
    ), t2 + 4;
  }
  a(Qn, "writeFloat");
  f2.prototype.writeFloatLE = a(function(e3, t2, n2) {
    return Qn(
      this,
      e3,
      t2,
      true,
      n2
    );
  }, "writeFloatLE");
  f2.prototype.writeFloatBE = a(function(e3, t2, n2) {
    return Qn(
      this,
      e3,
      t2,
      false,
      n2
    );
  }, "writeFloatBE");
  function Wn(r2, e3, t2, n2, i2) {
    return e3 = +e3, t2 = t2 >>> 0, i2 || Nn(
      r2,
      e3,
      t2,
      8,
      17976931348623157e292,
      -17976931348623157e292
    ), Pe.write(r2, e3, t2, n2, 52, 8), t2 + 8;
  }
  a(Wn, "writeDouble");
  f2.prototype.writeDoubleLE = a(function(e3, t2, n2) {
    return Wn(
      this,
      e3,
      t2,
      true,
      n2
    );
  }, "writeDoubleLE");
  f2.prototype.writeDoubleBE = a(function(e3, t2, n2) {
    return Wn(
      this,
      e3,
      t2,
      false,
      n2
    );
  }, "writeDoubleBE");
  f2.prototype.copy = a(function(e3, t2, n2, i2) {
    if (!f2.isBuffer(
      e3
    ))
      throw new TypeError("argument should be a Buffer");
    if (n2 || (n2 = 0), !i2 && i2 !== 0 && (i2 = this.length), t2 >= e3.length && (t2 = e3.length), t2 || (t2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2 || e3.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length)
      throw new RangeError("Index out of range");
    if (i2 < 0)
      throw new RangeError(
        "sourceEnd out of bounds"
      );
    i2 > this.length && (i2 = this.length), e3.length - t2 < i2 - n2 && (i2 = e3.length - t2 + n2);
    let s2 = i2 - n2;
    return this === e3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t2, n2, i2) : Uint8Array.prototype.set.call(e3, this.subarray(n2, i2), t2), s2;
  }, "copy");
  f2.prototype.fill = a(function(e3, t2, n2, i2) {
    if (typeof e3 == "string") {
      if (typeof t2 == "string" ? (i2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (i2 = n2, n2 = this.length), i2 !== void 0 && typeof i2 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i2 == "string" && !f2.isEncoding(i2))
        throw new TypeError("Unknown encoding: " + i2);
      if (e3.length === 1) {
        let o2 = e3.charCodeAt(0);
        (i2 === "utf8" && o2 < 128 || i2 === "latin1") && (e3 = o2);
      }
    } else
      typeof e3 == "number" ? e3 = e3 & 255 : typeof e3 == "boolean" && (e3 = Number(e3));
    if (t2 < 0 || this.length < t2 || this.length < n2)
      throw new RangeError("Out of range index");
    if (n2 <= t2)
      return this;
    t2 = t2 >>> 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e3 || (e3 = 0);
    let s2;
    if (typeof e3 == "number")
      for (s2 = t2; s2 < n2; ++s2)
        this[s2] = e3;
    else {
      let o2 = f2.isBuffer(e3) ? e3 : f2.from(e3, i2), u2 = o2.length;
      if (u2 === 0)
        throw new TypeError(
          'The value "' + e3 + '" is invalid for argument "value"'
        );
      for (s2 = 0; s2 < n2 - t2; ++s2)
        this[s2 + t2] = o2[s2 % u2];
    }
    return this;
  }, "fill");
  var Te = {};
  function Dt(r2, e3, t2) {
    var n2;
    Te[r2] = (n2 = class extends t2 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: e3.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${r2}]`, this.stack, delete this.name;
      }
      get code() {
        return r2;
      }
      set code(s2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: s2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${r2}]: ${this.message}`;
      }
    }, a(n2, "NodeError"), n2);
  }
  a(Dt, "E");
  Dt("ERR_BUFFER_OUT_OF_BOUNDS", function(r2) {
    return r2 ? `${r2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Dt("ERR_INVALID_ARG_TYPE", function(r2, e3) {
    return `The "${r2}" argument must be of type number. Received type ${typeof e3}`;
  }, TypeError);
  Dt("ERR_OUT_OF_RANGE", function(r2, e3, t2) {
    let n2 = `The value of "${r2}" is out of range.`, i2 = t2;
    return Number.isInteger(t2) && Math.abs(t2) > 2 ** 32 ? i2 = Rn(String(t2)) : typeof t2 == "bigint" && (i2 = String(t2), (t2 > BigInt(2) ** BigInt(32) || t2 < -(BigInt(2) ** BigInt(32))) && (i2 = Rn(i2)), i2 += "n"), n2 += ` It must be ${e3}. Received ${i2}`, n2;
  }, RangeError);
  function Rn(r2) {
    let e3 = "", t2 = r2.length, n2 = r2[0] === "-" ? 1 : 0;
    for (; t2 >= n2 + 4; t2 -= 3)
      e3 = `_${r2.slice(t2 - 3, t2)}${e3}`;
    return `${r2.slice(
      0,
      t2
    )}${e3}`;
  }
  a(Rn, "addNumericalSeparator");
  function Lo(r2, e3, t2) {
    Be(e3, "offset"), (r2[e3] === void 0 || r2[e3 + t2] === void 0) && je(e3, r2.length - (t2 + 1));
  }
  a(Lo, "checkBounds");
  function jn(r2, e3, t2, n2, i2, s2) {
    if (r2 > t2 || r2 < e3) {
      let o2 = typeof e3 == "bigint" ? "n" : "", u2;
      throw s2 > 3 ? e3 === 0 || e3 === BigInt(0) ? u2 = `>= 0${o2} and < 2${o2} ** ${(s2 + 1) * 8}${o2}` : u2 = `>= -(2${o2} ** ${(s2 + 1) * 8 - 1}${o2}) and < 2 ** ${(s2 + 1) * 8 - 1}${o2}` : u2 = `>= ${e3}${o2} and <= ${t2}${o2}`, new Te.ERR_OUT_OF_RANGE(
        "value",
        u2,
        r2
      );
    }
    Lo(n2, i2, s2);
  }
  a(jn, "checkIntBI");
  function Be(r2, e3) {
    if (typeof r2 != "number")
      throw new Te.ERR_INVALID_ARG_TYPE(e3, "number", r2);
  }
  a(Be, "validateNumber");
  function je(r2, e3, t2) {
    throw Math.floor(r2) !== r2 ? (Be(r2, t2), new Te.ERR_OUT_OF_RANGE(
      t2 || "offset",
      "an integer",
      r2
    )) : e3 < 0 ? new Te.ERR_BUFFER_OUT_OF_BOUNDS() : new Te.ERR_OUT_OF_RANGE(t2 || "offset", `>= ${t2 ? 1 : 0} and <= ${e3}`, r2);
  }
  a(je, "boundsError");
  var Ro = /[^+/0-9A-Za-z-_]/g;
  function Fo(r2) {
    if (r2 = r2.split("=")[0], r2 = r2.trim().replace(Ro, ""), r2.length < 2)
      return "";
    for (; r2.length % 4 !== 0; )
      r2 = r2 + "=";
    return r2;
  }
  a(Fo, "base64clean");
  function Rt(r2, e3) {
    e3 = e3 || 1 / 0;
    let t2, n2 = r2.length, i2 = null, s2 = [];
    for (let o2 = 0; o2 < n2; ++o2) {
      if (t2 = r2.charCodeAt(o2), t2 > 55295 && t2 < 57344) {
        if (!i2) {
          if (t2 > 56319) {
            (e3 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          } else if (o2 + 1 === n2) {
            (e3 -= 3) > -1 && s2.push(239, 191, 189);
            continue;
          }
          i2 = t2;
          continue;
        }
        if (t2 < 56320) {
          (e3 -= 3) > -1 && s2.push(
            239,
            191,
            189
          ), i2 = t2;
          continue;
        }
        t2 = (i2 - 55296 << 10 | t2 - 56320) + 65536;
      } else
        i2 && (e3 -= 3) > -1 && s2.push(
          239,
          191,
          189
        );
      if (i2 = null, t2 < 128) {
        if ((e3 -= 1) < 0)
          break;
        s2.push(t2);
      } else if (t2 < 2048) {
        if ((e3 -= 2) < 0)
          break;
        s2.push(t2 >> 6 | 192, t2 & 63 | 128);
      } else if (t2 < 65536) {
        if ((e3 -= 3) < 0)
          break;
        s2.push(t2 >> 12 | 224, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else if (t2 < 1114112) {
        if ((e3 -= 4) < 0)
          break;
        s2.push(t2 >> 18 | 240, t2 >> 12 & 63 | 128, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return s2;
  }
  a(
    Rt,
    "utf8ToBytes"
  );
  function Mo(r2) {
    let e3 = [];
    for (let t2 = 0; t2 < r2.length; ++t2)
      e3.push(r2.charCodeAt(
        t2
      ) & 255);
    return e3;
  }
  a(Mo, "asciiToBytes");
  function Do(r2, e3) {
    let t2, n2, i2, s2 = [];
    for (let o2 = 0; o2 < r2.length && !((e3 -= 2) < 0); ++o2)
      t2 = r2.charCodeAt(o2), n2 = t2 >> 8, i2 = t2 % 256, s2.push(i2), s2.push(n2);
    return s2;
  }
  a(Do, "utf16leToBytes");
  function Hn(r2) {
    return Pt.toByteArray(Fo(r2));
  }
  a(Hn, "base64ToBytes");
  function ot(r2, e3, t2, n2) {
    let i2;
    for (i2 = 0; i2 < n2 && !(i2 + t2 >= e3.length || i2 >= r2.length); ++i2)
      e3[i2 + t2] = r2[i2];
    return i2;
  }
  a(ot, "blitBuffer");
  function ae(r2, e3) {
    return r2 instanceof e3 || r2 != null && r2.constructor != null && r2.constructor.name != null && r2.constructor.name === e3.name;
  }
  a(ae, "isInstance");
  function Ot(r2) {
    return r2 !== r2;
  }
  a(Ot, "numberIsNaN");
  var Oo = function() {
    let r2 = "0123456789abcdef", e3 = new Array(256);
    for (let t2 = 0; t2 < 16; ++t2) {
      let n2 = t2 * 16;
      for (let i2 = 0; i2 < 16; ++i2)
        e3[n2 + i2] = r2[t2] + r2[i2];
    }
    return e3;
  }();
  function me(r2) {
    return typeof BigInt > "u" ? ko : r2;
  }
  a(me, "defineBigIntMethod");
  function ko() {
    throw new Error("BigInt not supported");
  }
  a(ko, "BufferBigIntNotDefined");
});
var b2;
var S2;
var v2;
var w2;
var d3;
var m2;
var p3 = K2(() => {
  "use strict";
  b2 = globalThis, S2 = globalThis.setImmediate ?? ((r2) => setTimeout(
    r2,
    0
  )), v2 = globalThis.clearImmediate ?? ((r2) => clearTimeout(r2)), w2 = globalThis.crypto ?? {};
  w2.subtle ?? (w2.subtle = {});
  d3 = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : Gn().Buffer, m2 = globalThis.process ?? {};
  m2.env ?? (m2.env = {});
  try {
    m2.nextTick(() => {
    });
  } catch {
    let e3 = Promise.resolve();
    m2.nextTick = e3.then.bind(e3);
  }
});
var ge = I((Jc, kt) => {
  "use strict";
  p3();
  var Re = typeof Reflect == "object" ? Reflect : null, $n = Re && typeof Re.apply == "function" ? Re.apply : a(function(e3, t2, n2) {
    return Function.prototype.apply.call(e3, t2, n2);
  }, "ReflectApply"), at;
  Re && typeof Re.ownKeys == "function" ? at = Re.ownKeys : Object.getOwnPropertySymbols ? at = a(function(e3) {
    return Object.getOwnPropertyNames(
      e3
    ).concat(Object.getOwnPropertySymbols(e3));
  }, "ReflectOwnKeys") : at = a(function(e3) {
    return Object.getOwnPropertyNames(e3);
  }, "ReflectOwnKeys");
  function Uo(r2) {
    console && console.warn && console.warn(r2);
  }
  a(Uo, "ProcessEmitWarning");
  var Vn = Number.isNaN || a(function(e3) {
    return e3 !== e3;
  }, "NumberIsNaN");
  function B() {
    B.init.call(this);
  }
  a(B, "EventEmitter");
  kt.exports = B;
  kt.exports.once = Wo;
  B.EventEmitter = B;
  B.prototype._events = void 0;
  B.prototype._eventsCount = 0;
  B.prototype._maxListeners = void 0;
  var Kn = 10;
  function ut(r2) {
    if (typeof r2 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r2);
  }
  a(ut, "checkListener");
  Object.defineProperty(B, "defaultMaxListeners", { enumerable: true, get: function() {
    return Kn;
  }, set: function(r2) {
    if (typeof r2 != "number" || r2 < 0 || Vn(r2))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r2 + ".");
    Kn = r2;
  } });
  B.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  B.prototype.setMaxListeners = a(function(e3) {
    if (typeof e3 != "number" || e3 < 0 || Vn(
      e3
    ))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    return this._maxListeners = e3, this;
  }, "setMaxListeners");
  function zn(r2) {
    return r2._maxListeners === void 0 ? B.defaultMaxListeners : r2._maxListeners;
  }
  a(zn, "_getMaxListeners");
  B.prototype.getMaxListeners = a(
    function() {
      return zn(this);
    },
    "getMaxListeners"
  );
  B.prototype.emit = a(function(e3) {
    for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
      t2.push(arguments[n2]);
    var i2 = e3 === "error", s2 = this._events;
    if (s2 !== void 0)
      i2 = i2 && s2.error === void 0;
    else if (!i2)
      return false;
    if (i2) {
      var o2;
      if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error)
        throw o2;
      var u2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
      throw u2.context = o2, u2;
    }
    var c3 = s2[e3];
    if (c3 === void 0)
      return false;
    if (typeof c3 == "function")
      $n(c3, this, t2);
    else
      for (var h2 = c3.length, l3 = ei(c3, h2), n2 = 0; n2 < h2; ++n2)
        $n(l3[n2], this, t2);
    return true;
  }, "emit");
  function Yn(r2, e3, t2, n2) {
    var i2, s2, o2;
    if (ut(t2), s2 = r2._events, s2 === void 0 ? (s2 = r2._events = /* @__PURE__ */ Object.create(null), r2._eventsCount = 0) : (s2.newListener !== void 0 && (r2.emit("newListener", e3, t2.listener ? t2.listener : t2), s2 = r2._events), o2 = s2[e3]), o2 === void 0)
      o2 = s2[e3] = t2, ++r2._eventsCount;
    else if (typeof o2 == "function" ? o2 = s2[e3] = n2 ? [t2, o2] : [o2, t2] : n2 ? o2.unshift(t2) : o2.push(t2), i2 = zn(r2), i2 > 0 && o2.length > i2 && !o2.warned) {
      o2.warned = true;
      var u2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u2.name = "MaxListenersExceededWarning", u2.emitter = r2, u2.type = e3, u2.count = o2.length, Uo(u2);
    }
    return r2;
  }
  a(Yn, "_addListener");
  B.prototype.addListener = a(function(e3, t2) {
    return Yn(
      this,
      e3,
      t2,
      false
    );
  }, "addListener");
  B.prototype.on = B.prototype.addListener;
  B.prototype.prependListener = a(function(e3, t2) {
    return Yn(this, e3, t2, true);
  }, "prependListener");
  function qo() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  a(qo, "onceWrapper");
  function Zn(r2, e3, t2) {
    var n2 = {
      fired: false,
      wrapFn: void 0,
      target: r2,
      type: e3,
      listener: t2
    }, i2 = qo.bind(n2);
    return i2.listener = t2, n2.wrapFn = i2, i2;
  }
  a(Zn, "_onceWrap");
  B.prototype.once = a(function(e3, t2) {
    return ut(t2), this.on(e3, Zn(this, e3, t2)), this;
  }, "once");
  B.prototype.prependOnceListener = a(function(e3, t2) {
    return ut(t2), this.prependListener(e3, Zn(this, e3, t2)), this;
  }, "prependOnceListener");
  B.prototype.removeListener = a(function(e3, t2) {
    var n2, i2, s2, o2, u2;
    if (ut(t2), i2 = this._events, i2 === void 0)
      return this;
    if (n2 = i2[e3], n2 === void 0)
      return this;
    if (n2 === t2 || n2.listener === t2)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[e3], i2.removeListener && this.emit("removeListener", e3, n2.listener || t2));
    else if (typeof n2 != "function") {
      for (s2 = -1, o2 = n2.length - 1; o2 >= 0; o2--)
        if (n2[o2] === t2 || n2[o2].listener === t2) {
          u2 = n2[o2].listener, s2 = o2;
          break;
        }
      if (s2 < 0)
        return this;
      s2 === 0 ? n2.shift() : No(n2, s2), n2.length === 1 && (i2[e3] = n2[0]), i2.removeListener !== void 0 && this.emit(
        "removeListener",
        e3,
        u2 || t2
      );
    }
    return this;
  }, "removeListener");
  B.prototype.off = B.prototype.removeListener;
  B.prototype.removeAllListeners = a(function(e3) {
    var t2, n2, i2;
    if (n2 = this._events, n2 === void 0)
      return this;
    if (n2.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n2[e3] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e3]), this;
    if (arguments.length === 0) {
      var s2 = Object.keys(n2), o2;
      for (i2 = 0; i2 < s2.length; ++i2)
        o2 = s2[i2], o2 !== "removeListener" && this.removeAllListeners(o2);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t2 = n2[e3], typeof t2 == "function")
      this.removeListener(e3, t2);
    else if (t2 !== void 0)
      for (i2 = t2.length - 1; i2 >= 0; i2--)
        this.removeListener(e3, t2[i2]);
    return this;
  }, "removeAllListeners");
  function Jn(r2, e3, t2) {
    var n2 = r2._events;
    if (n2 === void 0)
      return [];
    var i2 = n2[e3];
    return i2 === void 0 ? [] : typeof i2 == "function" ? t2 ? [i2.listener || i2] : [i2] : t2 ? Qo(i2) : ei(i2, i2.length);
  }
  a(Jn, "_listeners");
  B.prototype.listeners = a(function(e3) {
    return Jn(this, e3, true);
  }, "listeners");
  B.prototype.rawListeners = a(function(e3) {
    return Jn(this, e3, false);
  }, "rawListeners");
  B.listenerCount = function(r2, e3) {
    return typeof r2.listenerCount == "function" ? r2.listenerCount(e3) : Xn.call(r2, e3);
  };
  B.prototype.listenerCount = Xn;
  function Xn(r2) {
    var e3 = this._events;
    if (e3 !== void 0) {
      var t2 = e3[r2];
      if (typeof t2 == "function")
        return 1;
      if (t2 !== void 0)
        return t2.length;
    }
    return 0;
  }
  a(Xn, "listenerCount");
  B.prototype.eventNames = a(function() {
    return this._eventsCount > 0 ? at(this._events) : [];
  }, "eventNames");
  function ei(r2, e3) {
    for (var t2 = new Array(e3), n2 = 0; n2 < e3; ++n2)
      t2[n2] = r2[n2];
    return t2;
  }
  a(ei, "arrayClone");
  function No(r2, e3) {
    for (; e3 + 1 < r2.length; e3++)
      r2[e3] = r2[e3 + 1];
    r2.pop();
  }
  a(No, "spliceOne");
  function Qo(r2) {
    for (var e3 = new Array(r2.length), t2 = 0; t2 < e3.length; ++t2)
      e3[t2] = r2[t2].listener || r2[t2];
    return e3;
  }
  a(Qo, "unwrapListeners");
  function Wo(r2, e3) {
    return new Promise(
      function(t2, n2) {
        function i2(o2) {
          r2.removeListener(e3, s2), n2(o2);
        }
        a(i2, "errorListener");
        function s2() {
          typeof r2.removeListener == "function" && r2.removeListener("error", i2), t2([].slice.call(
            arguments
          ));
        }
        a(s2, "resolver"), ti(r2, e3, s2, { once: true }), e3 !== "error" && jo(r2, i2, { once: true });
      }
    );
  }
  a(Wo, "once");
  function jo(r2, e3, t2) {
    typeof r2.on == "function" && ti(r2, "error", e3, t2);
  }
  a(
    jo,
    "addErrorHandlerIfEventEmitter"
  );
  function ti(r2, e3, t2, n2) {
    if (typeof r2.on == "function")
      n2.once ? r2.once(e3, t2) : r2.on(e3, t2);
    else if (typeof r2.addEventListener == "function")
      r2.addEventListener(
        e3,
        a(function i2(s2) {
          n2.once && r2.removeEventListener(e3, i2), t2(s2);
        }, "wrapListener")
      );
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r2);
  }
  a(ti, "eventTargetAgnosticAddListener");
});
var He = {};
X2(He, { default: () => Ho });
var Ho;
var Ge = K2(() => {
  "use strict";
  p3();
  Ho = {};
});
function $e(r2) {
  let e3 = 1779033703, t2 = 3144134277, n2 = 1013904242, i2 = 2773480762, s2 = 1359893119, o2 = 2600822924, u2 = 528734635, c3 = 1541459225, h2 = 0, l3 = 0, y2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], E = a(
    (A, g2) => A >>> g2 | A << 32 - g2,
    "rrot"
  ), _ = new Uint32Array(64), P2 = new Uint8Array(64), N = a(() => {
    for (let L = 0, G = 0; L < 16; L++, G += 4)
      _[L] = P2[G] << 24 | P2[G + 1] << 16 | P2[G + 2] << 8 | P2[G + 3];
    for (let L = 16; L < 64; L++) {
      let G = E(_[L - 15], 7) ^ E(_[L - 15], 18) ^ _[L - 15] >>> 3, ce = E(_[L - 2], 17) ^ E(_[L - 2], 19) ^ _[L - 2] >>> 10;
      _[L] = _[L - 16] + G + _[L - 7] + ce | 0;
    }
    let A = e3, g2 = t2, D = n2, H = i2, Q = s2, W = o2, ue = u2, de = c3;
    for (let L = 0; L < 64; L++) {
      let G = E(
        Q,
        6
      ) ^ E(Q, 11) ^ E(Q, 25), ce = Q & W ^ ~Q & ue, ye = de + G + ce + y2[L] + _[L] | 0, xe = E(A, 2) ^ E(A, 13) ^ E(A, 22), he = A & g2 ^ A & D ^ g2 & D, ie = xe + he | 0;
      de = ue, ue = W, W = Q, Q = H + ye | 0, H = D, D = g2, g2 = A, A = ye + ie | 0;
    }
    e3 = e3 + A | 0, t2 = t2 + g2 | 0, n2 = n2 + D | 0, i2 = i2 + H | 0, s2 = s2 + Q | 0, o2 = o2 + W | 0, u2 = u2 + ue | 0, c3 = c3 + de | 0, l3 = 0;
  }, "process"), J = a((A) => {
    typeof A == "string" && (A = new TextEncoder().encode(A));
    for (let g2 = 0; g2 < A.length; g2++)
      P2[l3++] = A[g2], l3 === 64 && N();
    h2 += A.length;
  }, "add"), pe = a(() => {
    if (P2[l3++] = 128, l3 == 64 && N(), l3 + 8 > 64) {
      for (; l3 < 64; )
        P2[l3++] = 0;
      N();
    }
    for (; l3 < 58; )
      P2[l3++] = 0;
    let A = h2 * 8;
    P2[l3++] = A / 1099511627776 & 255, P2[l3++] = A / 4294967296 & 255, P2[l3++] = A >>> 24, P2[l3++] = A >>> 16 & 255, P2[l3++] = A >>> 8 & 255, P2[l3++] = A & 255, N();
    let g2 = new Uint8Array(32);
    return g2[0] = e3 >>> 24, g2[1] = e3 >>> 16 & 255, g2[2] = e3 >>> 8 & 255, g2[3] = e3 & 255, g2[4] = t2 >>> 24, g2[5] = t2 >>> 16 & 255, g2[6] = t2 >>> 8 & 255, g2[7] = t2 & 255, g2[8] = n2 >>> 24, g2[9] = n2 >>> 16 & 255, g2[10] = n2 >>> 8 & 255, g2[11] = n2 & 255, g2[12] = i2 >>> 24, g2[13] = i2 >>> 16 & 255, g2[14] = i2 >>> 8 & 255, g2[15] = i2 & 255, g2[16] = s2 >>> 24, g2[17] = s2 >>> 16 & 255, g2[18] = s2 >>> 8 & 255, g2[19] = s2 & 255, g2[20] = o2 >>> 24, g2[21] = o2 >>> 16 & 255, g2[22] = o2 >>> 8 & 255, g2[23] = o2 & 255, g2[24] = u2 >>> 24, g2[25] = u2 >>> 16 & 255, g2[26] = u2 >>> 8 & 255, g2[27] = u2 & 255, g2[28] = c3 >>> 24, g2[29] = c3 >>> 16 & 255, g2[30] = c3 >>> 8 & 255, g2[31] = c3 & 255, g2;
  }, "digest");
  return r2 === void 0 ? { add: J, digest: pe } : (J(r2), pe());
}
var ri = K2(
  () => {
    "use strict";
    p3();
    a($e, "sha256");
  }
);
var O2;
var Ke;
var ni = K2(() => {
  "use strict";
  p3();
  O2 = class O3 {
    constructor() {
      T(
        this,
        "_dataLength",
        0
      );
      T(this, "_bufferLength", 0);
      T(this, "_state", new Int32Array(4));
      T(
        this,
        "_buffer",
        new ArrayBuffer(68)
      );
      T(this, "_buffer8");
      T(this, "_buffer32");
      this._buffer8 = new Uint8Array(
        this._buffer,
        0,
        68
      ), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashByteArray(e3, t2 = false) {
      return this.onePassHasher.start().appendByteArray(e3).end(t2);
    }
    static hashStr(e3, t2 = false) {
      return this.onePassHasher.start().appendStr(e3).end(t2);
    }
    static hashAsciiStr(e3, t2 = false) {
      return this.onePassHasher.start().appendAsciiStr(e3).end(t2);
    }
    static _hex(e3) {
      let t2 = O3.hexChars, n2 = O3.hexOut, i2, s2, o2, u2;
      for (u2 = 0; u2 < 4; u2 += 1)
        for (s2 = u2 * 8, i2 = e3[u2], o2 = 0; o2 < 8; o2 += 2)
          n2[s2 + 1 + o2] = t2.charAt(i2 & 15), i2 >>>= 4, n2[s2 + 0 + o2] = t2.charAt(i2 & 15), i2 >>>= 4;
      return n2.join("");
    }
    static _md5cycle(e3, t2) {
      let n2 = e3[0], i2 = e3[1], s2 = e3[2], o2 = e3[3];
      n2 += (i2 & s2 | ~i2 & o2) + t2[0] - 680876936 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[1] - 389564586 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[2] + 606105819 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[3] - 1044525330 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[4] - 176418897 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[5] + 1200080426 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[6] - 1473231341 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[7] - 45705983 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[8] + 1770035416 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[9] - 1958414417 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[10] - 42063 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[11] - 1990404162 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & s2 | ~i2 & o2) + t2[12] + 1804603682 | 0, n2 = (n2 << 7 | n2 >>> 25) + i2 | 0, o2 += (n2 & i2 | ~n2 & s2) + t2[13] - 40341101 | 0, o2 = (o2 << 12 | o2 >>> 20) + n2 | 0, s2 += (o2 & n2 | ~o2 & i2) + t2[14] - 1502002290 | 0, s2 = (s2 << 17 | s2 >>> 15) + o2 | 0, i2 += (s2 & o2 | ~s2 & n2) + t2[15] + 1236535329 | 0, i2 = (i2 << 22 | i2 >>> 10) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[1] - 165796510 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[6] - 1069501632 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[11] + 643717713 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[0] - 373897302 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[5] - 701558691 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[10] + 38016083 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[15] - 660478335 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[4] - 405537848 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[9] + 568446438 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[14] - 1019803690 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[3] - 187363961 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[8] + 1163531501 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 & o2 | s2 & ~o2) + t2[13] - 1444681467 | 0, n2 = (n2 << 5 | n2 >>> 27) + i2 | 0, o2 += (n2 & s2 | i2 & ~s2) + t2[2] - 51403784 | 0, o2 = (o2 << 9 | o2 >>> 23) + n2 | 0, s2 += (o2 & i2 | n2 & ~i2) + t2[7] + 1735328473 | 0, s2 = (s2 << 14 | s2 >>> 18) + o2 | 0, i2 += (s2 & n2 | o2 & ~n2) + t2[12] - 1926607734 | 0, i2 = (i2 << 20 | i2 >>> 12) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[5] - 378558 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[8] - 2022574463 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[11] + 1839030562 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[14] - 35309556 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[1] - 1530992060 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[4] + 1272893353 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[7] - 155497632 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[10] - 1094730640 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[13] + 681279174 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[0] - 358537222 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[3] - 722521979 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[6] + 76029189 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (i2 ^ s2 ^ o2) + t2[9] - 640364487 | 0, n2 = (n2 << 4 | n2 >>> 28) + i2 | 0, o2 += (n2 ^ i2 ^ s2) + t2[12] - 421815835 | 0, o2 = (o2 << 11 | o2 >>> 21) + n2 | 0, s2 += (o2 ^ n2 ^ i2) + t2[15] + 530742520 | 0, s2 = (s2 << 16 | s2 >>> 16) + o2 | 0, i2 += (s2 ^ o2 ^ n2) + t2[2] - 995338651 | 0, i2 = (i2 << 23 | i2 >>> 9) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[0] - 198630844 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[7] + 1126891415 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[14] - 1416354905 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[5] - 57434055 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[12] + 1700485571 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[3] - 1894986606 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[10] - 1051523 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[1] - 2054922799 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[8] + 1873313359 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[15] - 30611744 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[6] - 1560198380 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[13] + 1309151649 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, n2 += (s2 ^ (i2 | ~o2)) + t2[4] - 145523070 | 0, n2 = (n2 << 6 | n2 >>> 26) + i2 | 0, o2 += (i2 ^ (n2 | ~s2)) + t2[11] - 1120210379 | 0, o2 = (o2 << 10 | o2 >>> 22) + n2 | 0, s2 += (n2 ^ (o2 | ~i2)) + t2[2] + 718787259 | 0, s2 = (s2 << 15 | s2 >>> 17) + o2 | 0, i2 += (o2 ^ (s2 | ~n2)) + t2[9] - 343485551 | 0, i2 = (i2 << 21 | i2 >>> 11) + s2 | 0, e3[0] = n2 + e3[0] | 0, e3[1] = i2 + e3[1] | 0, e3[2] = s2 + e3[2] | 0, e3[3] = o2 + e3[3] | 0;
    }
    start() {
      return this._dataLength = 0, this._bufferLength = 0, this._state.set(O3.stateIdentity), this;
    }
    appendStr(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2;
      for (o2 = 0; o2 < e3.length; o2 += 1) {
        if (s2 = e3.charCodeAt(o2), s2 < 128)
          t2[i2++] = s2;
        else if (s2 < 2048)
          t2[i2++] = (s2 >>> 6) + 192, t2[i2++] = s2 & 63 | 128;
        else if (s2 < 55296 || s2 > 56319)
          t2[i2++] = (s2 >>> 12) + 224, t2[i2++] = s2 >>> 6 & 63 | 128, t2[i2++] = s2 & 63 | 128;
        else {
          if (s2 = (s2 - 55296) * 1024 + (e3.charCodeAt(++o2) - 56320) + 65536, s2 > 1114111)
            throw new Error("Unicode standard supports code points up to U+10FFFF");
          t2[i2++] = (s2 >>> 18) + 240, t2[i2++] = s2 >>> 12 & 63 | 128, t2[i2++] = s2 >>> 6 & 63 | 128, t2[i2++] = s2 & 63 | 128;
        }
        i2 >= 64 && (this._dataLength += 64, O3._md5cycle(this._state, n2), i2 -= 64, n2[0] = n2[16]);
      }
      return this._bufferLength = i2, this;
    }
    appendAsciiStr(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2 = 0;
      for (; ; ) {
        for (s2 = Math.min(e3.length - o2, 64 - i2); s2--; )
          t2[i2++] = e3.charCodeAt(o2++);
        if (i2 < 64)
          break;
        this._dataLength += 64, O3._md5cycle(
          this._state,
          n2
        ), i2 = 0;
      }
      return this._bufferLength = i2, this;
    }
    appendByteArray(e3) {
      let t2 = this._buffer8, n2 = this._buffer32, i2 = this._bufferLength, s2, o2 = 0;
      for (; ; ) {
        for (s2 = Math.min(e3.length - o2, 64 - i2); s2--; )
          t2[i2++] = e3[o2++];
        if (i2 < 64)
          break;
        this._dataLength += 64, O3._md5cycle(
          this._state,
          n2
        ), i2 = 0;
      }
      return this._bufferLength = i2, this;
    }
    getState() {
      let e3 = this._state;
      return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e3[0], e3[1], e3[2], e3[3]] };
    }
    setState(e3) {
      let t2 = e3.buffer, n2 = e3.state, i2 = this._state, s2;
      for (this._dataLength = e3.length, this._bufferLength = e3.buflen, i2[0] = n2[0], i2[1] = n2[1], i2[2] = n2[2], i2[3] = n2[3], s2 = 0; s2 < t2.length; s2 += 1)
        this._buffer8[s2] = t2.charCodeAt(s2);
    }
    end(e3 = false) {
      let t2 = this._bufferLength, n2 = this._buffer8, i2 = this._buffer32, s2 = (t2 >> 2) + 1;
      this._dataLength += t2;
      let o2 = this._dataLength * 8;
      if (n2[t2] = 128, n2[t2 + 1] = n2[t2 + 2] = n2[t2 + 3] = 0, i2.set(O3.buffer32Identity.subarray(s2), s2), t2 > 55 && (O3._md5cycle(this._state, i2), i2.set(O3.buffer32Identity)), o2 <= 4294967295)
        i2[14] = o2;
      else {
        let u2 = o2.toString(16).match(/(.*?)(.{0,8})$/);
        if (u2 === null)
          return;
        let c3 = parseInt(
          u2[2],
          16
        ), h2 = parseInt(u2[1], 16) || 0;
        i2[14] = c3, i2[15] = h2;
      }
      return O3._md5cycle(this._state, i2), e3 ? this._state : O3._hex(this._state);
    }
  };
  a(O2, "Md5"), T(O2, "stateIdentity", new Int32Array(
    [1732584193, -271733879, -1732584194, 271733878]
  )), T(O2, "buffer32Identity", new Int32Array(
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  )), T(O2, "hexChars", "0123456789abcdef"), T(O2, "hexOut", []), T(O2, "onePassHasher", new O2());
  Ke = O2;
});
var Ut = {};
X2(Ut, { createHash: () => $o, createHmac: () => Ko, randomBytes: () => Go });
function Go(r2) {
  return w2.getRandomValues(d3.alloc(r2));
}
function $o(r2) {
  if (r2 === "sha256")
    return { update: function(e3) {
      return { digest: function() {
        return d3.from($e(e3));
      } };
    } };
  if (r2 === "md5")
    return { update: function(e3) {
      return { digest: function() {
        return typeof e3 == "string" ? Ke.hashStr(e3) : Ke.hashByteArray(
          e3
        );
      } };
    } };
  throw new Error(`Hash type '${r2}' not supported`);
}
function Ko(r2, e3) {
  if (r2 !== "sha256")
    throw new Error(`Only sha256 is supported (requested: '${r2}')`);
  return {
    update: function(t2) {
      return { digest: function() {
        typeof e3 == "string" && (e3 = new TextEncoder().encode(e3)), typeof t2 == "string" && (t2 = new TextEncoder().encode(t2));
        let n2 = e3.length;
        if (n2 > 64)
          e3 = $e(e3);
        else if (n2 < 64) {
          let c3 = new Uint8Array(64);
          c3.set(e3), e3 = c3;
        }
        let i2 = new Uint8Array(
          64
        ), s2 = new Uint8Array(64);
        for (let c3 = 0; c3 < 64; c3++)
          i2[c3] = 54 ^ e3[c3], s2[c3] = 92 ^ e3[c3];
        let o2 = new Uint8Array(
          t2.length + 64
        );
        o2.set(i2, 0), o2.set(t2, 64);
        let u2 = new Uint8Array(96);
        return u2.set(s2, 0), u2.set($e(o2), 64), d3.from($e(u2));
      } };
    }
  };
}
var qt = K2(() => {
  "use strict";
  p3();
  ri();
  ni();
  a(Go, "randomBytes");
  a($o, "createHash");
  a(Ko, "createHmac");
});
var Qt = I((ii) => {
  "use strict";
  p3();
  ii.parse = function(r2, e3) {
    return new Nt(r2, e3).parse();
  };
  var ct = class ct2 {
    constructor(e3, t2) {
      this.source = e3, this.transform = t2 || Vo, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var e3 = this.source[this.position++];
      return e3 === "\\" ? { value: this.source[this.position++], escaped: true } : { value: e3, escaped: false };
    }
    record(e3) {
      this.recorded.push(e3);
    }
    newEntry(e3) {
      var t2;
      (this.recorded.length > 0 || e3) && (t2 = this.recorded.join(""), t2 === "NULL" && !e3 && (t2 = null), t2 !== null && (t2 = this.transform(t2)), this.entries.push(
        t2
      ), this.recorded = []);
    }
    consumeDimensions() {
      if (this.source[0] === "[")
        for (; !this.isEof(); ) {
          var e3 = this.nextCharacter();
          if (e3.value === "=")
            break;
        }
    }
    parse(e3) {
      var t2, n2, i2;
      for (this.consumeDimensions(); !this.isEof(); )
        if (t2 = this.nextCharacter(), t2.value === "{" && !i2)
          this.dimension++, this.dimension > 1 && (n2 = new ct2(this.source.substr(this.position - 1), this.transform), this.entries.push(
            n2.parse(true)
          ), this.position += n2.position - 2);
        else if (t2.value === "}" && !i2) {
          if (this.dimension--, !this.dimension && (this.newEntry(), e3))
            return this.entries;
        } else
          t2.value === '"' && !t2.escaped ? (i2 && this.newEntry(true), i2 = !i2) : t2.value === "," && !i2 ? this.newEntry() : this.record(
            t2.value
          );
      if (this.dimension !== 0)
        throw new Error("array dimension not balanced");
      return this.entries;
    }
  };
  a(ct, "ArrayParser");
  var Nt = ct;
  function Vo(r2) {
    return r2;
  }
  a(Vo, "identity");
});
var Wt = I((yh, si) => {
  p3();
  var zo = Qt();
  si.exports = { create: function(r2, e3) {
    return { parse: function() {
      return zo.parse(r2, e3);
    } };
  } };
});
var ui = I((gh, ai) => {
  "use strict";
  p3();
  var Yo = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, Zo = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, Jo = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, Xo = /^-?infinity$/;
  ai.exports = a(function(e3) {
    if (Xo.test(e3))
      return Number(e3.replace("i", "I"));
    var t2 = Yo.exec(e3);
    if (!t2)
      return ea(e3) || null;
    var n2 = !!t2[8], i2 = parseInt(t2[1], 10);
    n2 && (i2 = oi(i2));
    var s2 = parseInt(
      t2[2],
      10
    ) - 1, o2 = t2[3], u2 = parseInt(t2[4], 10), c3 = parseInt(t2[5], 10), h2 = parseInt(t2[6], 10), l3 = t2[7];
    l3 = l3 ? 1e3 * parseFloat(l3) : 0;
    var y2, E = ta(e3);
    return E != null ? (y2 = new Date(Date.UTC(
      i2,
      s2,
      o2,
      u2,
      c3,
      h2,
      l3
    )), jt(i2) && y2.setUTCFullYear(i2), E !== 0 && y2.setTime(y2.getTime() - E)) : (y2 = new Date(
      i2,
      s2,
      o2,
      u2,
      c3,
      h2,
      l3
    ), jt(i2) && y2.setFullYear(i2)), y2;
  }, "parseDate");
  function ea(r2) {
    var e3 = Zo.exec(r2);
    if (e3) {
      var t2 = parseInt(e3[1], 10), n2 = !!e3[4];
      n2 && (t2 = oi(t2));
      var i2 = parseInt(
        e3[2],
        10
      ) - 1, s2 = e3[3], o2 = new Date(t2, i2, s2);
      return jt(t2) && o2.setFullYear(t2), o2;
    }
  }
  a(ea, "getDate");
  function ta(r2) {
    if (r2.endsWith("+00"))
      return 0;
    var e3 = Jo.exec(r2.split(" ")[1]);
    if (e3) {
      var t2 = e3[1];
      if (t2 === "Z")
        return 0;
      var n2 = t2 === "-" ? -1 : 1, i2 = parseInt(e3[2], 10) * 3600 + parseInt(
        e3[3] || 0,
        10
      ) * 60 + parseInt(e3[4] || 0, 10);
      return i2 * n2 * 1e3;
    }
  }
  a(ta, "timeZoneOffset");
  function oi(r2) {
    return -(r2 - 1);
  }
  a(oi, "bcYearToNegativeYear");
  function jt(r2) {
    return r2 >= 0 && r2 < 100;
  }
  a(
    jt,
    "is0To99"
  );
});
var hi = I((Sh, ci) => {
  p3();
  ci.exports = na;
  var ra = Object.prototype.hasOwnProperty;
  function na(r2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var n2 in t2)
        ra.call(
          t2,
          n2
        ) && (r2[n2] = t2[n2]);
    }
    return r2;
  }
  a(na, "extend");
});
var pi = I((vh, fi) => {
  "use strict";
  p3();
  var ia = hi();
  fi.exports = Fe;
  function Fe(r2) {
    if (!(this instanceof Fe))
      return new Fe(r2);
    ia(this, ma(r2));
  }
  a(Fe, "PostgresInterval");
  var sa = ["seconds", "minutes", "hours", "days", "months", "years"];
  Fe.prototype.toPostgres = function() {
    var r2 = sa.filter(this.hasOwnProperty, this);
    return this.milliseconds && r2.indexOf("seconds") < 0 && r2.push("seconds"), r2.length === 0 ? "0" : r2.map(function(e3) {
      var t2 = this[e3] || 0;
      return e3 === "seconds" && this.milliseconds && (t2 = (t2 + this.milliseconds / 1e3).toFixed(6).replace(
        /\.?0+$/,
        ""
      )), t2 + " " + e3;
    }, this).join(" ");
  };
  var oa = { years: "Y", months: "M", days: "D", hours: "H", minutes: "M", seconds: "S" }, aa = ["years", "months", "days"], ua = ["hours", "minutes", "seconds"];
  Fe.prototype.toISOString = Fe.prototype.toISO = function() {
    var r2 = aa.map(t2, this).join(""), e3 = ua.map(t2, this).join("");
    return "P" + r2 + "T" + e3;
    function t2(n2) {
      var i2 = this[n2] || 0;
      return n2 === "seconds" && this.milliseconds && (i2 = (i2 + this.milliseconds / 1e3).toFixed(6).replace(
        /0+$/,
        ""
      )), i2 + oa[n2];
    }
  };
  var Ht = "([+-]?\\d+)", ca = Ht + "\\s+years?", ha = Ht + "\\s+mons?", la = Ht + "\\s+days?", fa = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", pa = new RegExp([
    ca,
    ha,
    la,
    fa
  ].map(function(r2) {
    return "(" + r2 + ")?";
  }).join("\\s*")), li = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  }, da = ["hours", "minutes", "seconds", "milliseconds"];
  function ya(r2) {
    var e3 = r2 + "000000".slice(r2.length);
    return parseInt(
      e3,
      10
    ) / 1e3;
  }
  a(ya, "parseMilliseconds");
  function ma(r2) {
    if (!r2)
      return {};
    var e3 = pa.exec(
      r2
    ), t2 = e3[8] === "-";
    return Object.keys(li).reduce(function(n2, i2) {
      var s2 = li[i2], o2 = e3[s2];
      return !o2 || (o2 = i2 === "milliseconds" ? ya(o2) : parseInt(o2, 10), !o2) || (t2 && ~da.indexOf(i2) && (o2 *= -1), n2[i2] = o2), n2;
    }, {});
  }
  a(ma, "parse");
});
var yi = I((Ch, di) => {
  "use strict";
  p3();
  di.exports = a(function(e3) {
    if (/^\\x/.test(e3))
      return new d3(
        e3.substr(2),
        "hex"
      );
    for (var t2 = "", n2 = 0; n2 < e3.length; )
      if (e3[n2] !== "\\")
        t2 += e3[n2], ++n2;
      else if (/[0-7]{3}/.test(e3.substr(n2 + 1, 3)))
        t2 += String.fromCharCode(parseInt(e3.substr(n2 + 1, 3), 8)), n2 += 4;
      else {
        for (var i2 = 1; n2 + i2 < e3.length && e3[n2 + i2] === "\\"; )
          i2++;
        for (var s2 = 0; s2 < Math.floor(i2 / 2); ++s2)
          t2 += "\\";
        n2 += Math.floor(i2 / 2) * 2;
      }
    return new d3(t2, "binary");
  }, "parseBytea");
});
var Ei = I((Ph, xi) => {
  p3();
  var Ve = Qt(), ze = Wt(), ht = ui(), gi = pi(), wi = yi();
  function lt2(r2) {
    return a(function(t2) {
      return t2 === null ? t2 : r2(t2);
    }, "nullAllowed");
  }
  a(lt2, "allowNull");
  function bi(r2) {
    return r2 === null ? r2 : r2 === "TRUE" || r2 === "t" || r2 === "true" || r2 === "y" || r2 === "yes" || r2 === "on" || r2 === "1";
  }
  a(bi, "parseBool");
  function ga(r2) {
    return r2 ? Ve.parse(r2, bi) : null;
  }
  a(ga, "parseBoolArray");
  function wa(r2) {
    return parseInt(r2, 10);
  }
  a(wa, "parseBaseTenInt");
  function Gt(r2) {
    return r2 ? Ve.parse(r2, lt2(wa)) : null;
  }
  a(Gt, "parseIntegerArray");
  function ba(r2) {
    return r2 ? Ve.parse(r2, lt2(function(e3) {
      return Si(e3).trim();
    })) : null;
  }
  a(ba, "parseBigIntegerArray");
  var Sa = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = zt(t2)), t2;
    });
    return e3.parse();
  }, "parsePointArray"), $t = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = parseFloat(t2)), t2;
    });
    return e3.parse();
  }, "parseFloatArray"), te = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2);
    return e3.parse();
  }, "parseStringArray"), Kt = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = ht(t2)), t2;
    });
    return e3.parse();
  }, "parseDateArray"), xa = a(function(r2) {
    if (!r2)
      return null;
    var e3 = ze.create(r2, function(t2) {
      return t2 !== null && (t2 = gi(t2)), t2;
    });
    return e3.parse();
  }, "parseIntervalArray"), Ea = a(function(r2) {
    return r2 ? Ve.parse(r2, lt2(wi)) : null;
  }, "parseByteAArray"), Vt = a(function(r2) {
    return parseInt(
      r2,
      10
    );
  }, "parseInteger"), Si = a(function(r2) {
    var e3 = String(r2);
    return /^\d+$/.test(e3) ? e3 : r2;
  }, "parseBigInteger"), mi = a(
    function(r2) {
      return r2 ? Ve.parse(r2, lt2(JSON.parse)) : null;
    },
    "parseJsonArray"
  ), zt = a(function(r2) {
    return r2[0] !== "(" ? null : (r2 = r2.substring(1, r2.length - 1).split(","), { x: parseFloat(r2[0]), y: parseFloat(r2[1]) });
  }, "parsePoint"), va = a(function(r2) {
    if (r2[0] !== "<" && r2[1] !== "(")
      return null;
    for (var e3 = "(", t2 = "", n2 = false, i2 = 2; i2 < r2.length - 1; i2++) {
      if (n2 || (e3 += r2[i2]), r2[i2] === ")") {
        n2 = true;
        continue;
      } else if (!n2)
        continue;
      r2[i2] !== "," && (t2 += r2[i2]);
    }
    var s2 = zt(e3);
    return s2.radius = parseFloat(t2), s2;
  }, "parseCircle"), _a89 = a(function(r2) {
    r2(
      20,
      Si
    ), r2(21, Vt), r2(23, Vt), r2(26, Vt), r2(700, parseFloat), r2(701, parseFloat), r2(16, bi), r2(
      1082,
      ht
    ), r2(1114, ht), r2(1184, ht), r2(600, zt), r2(651, te), r2(718, va), r2(1e3, ga), r2(1001, Ea), r2(
      1005,
      Gt
    ), r2(1007, Gt), r2(1028, Gt), r2(1016, ba), r2(1017, Sa), r2(1021, $t), r2(1022, $t), r2(1231, $t), r2(1014, te), r2(1015, te), r2(1008, te), r2(1009, te), r2(1040, te), r2(1041, te), r2(1115, Kt), r2(
      1182,
      Kt
    ), r2(1185, Kt), r2(1186, gi), r2(1187, xa), r2(17, wi), r2(114, JSON.parse.bind(JSON)), r2(
      3802,
      JSON.parse.bind(JSON)
    ), r2(199, mi), r2(3807, mi), r2(3907, te), r2(2951, te), r2(791, te), r2(
      1183,
      te
    ), r2(1270, te);
  }, "init");
  xi.exports = { init: _a89 };
});
var _i = I((Rh, vi) => {
  "use strict";
  p3();
  var Y = 1e6;
  function Aa(r2) {
    var e3 = r2.readInt32BE(
      0
    ), t2 = r2.readUInt32BE(4), n2 = "";
    e3 < 0 && (e3 = ~e3 + (t2 === 0), t2 = ~t2 + 1 >>> 0, n2 = "-");
    var i2 = "", s2, o2, u2, c3, h2, l3;
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    {
      if (s2 = e3 % Y, e3 = e3 / Y >>> 0, o2 = 4294967296 * s2 + t2, t2 = o2 / Y >>> 0, u2 = "" + (o2 - Y * t2), t2 === 0 && e3 === 0)
        return n2 + u2 + i2;
      for (c3 = "", h2 = 6 - u2.length, l3 = 0; l3 < h2; l3++)
        c3 += "0";
      i2 = c3 + u2 + i2;
    }
    return s2 = e3 % Y, o2 = 4294967296 * s2 + t2, u2 = "" + o2 % Y, n2 + u2 + i2;
  }
  a(Aa, "readInt8");
  vi.exports = Aa;
});
var Pi = I((Dh, Ti) => {
  p3();
  var Ca = _i(), R = a(function(r2, e3, t2, n2, i2) {
    t2 = t2 || 0, n2 = n2 || false, i2 = i2 || function(_, P2, N) {
      return _ * Math.pow(2, N) + P2;
    };
    var s2 = t2 >> 3, o2 = a(function(_) {
      return n2 ? ~_ & 255 : _;
    }, "inv"), u2 = 255, c3 = 8 - t2 % 8;
    e3 < c3 && (u2 = 255 << 8 - e3 & 255, c3 = e3), t2 && (u2 = u2 >> t2 % 8);
    var h2 = 0;
    t2 % 8 + e3 >= 8 && (h2 = i2(0, o2(r2[s2]) & u2, c3));
    for (var l3 = e3 + t2 >> 3, y2 = s2 + 1; y2 < l3; y2++)
      h2 = i2(h2, o2(r2[y2]), 8);
    var E = (e3 + t2) % 8;
    return E > 0 && (h2 = i2(h2, o2(r2[l3]) >> 8 - E, E)), h2;
  }, "parseBits"), Ii = a(function(r2, e3, t2) {
    var n2 = Math.pow(2, t2 - 1) - 1, i2 = R(r2, 1), s2 = R(r2, t2, 1);
    if (s2 === 0)
      return 0;
    var o2 = 1, u2 = a(function(h2, l3, y2) {
      h2 === 0 && (h2 = 1);
      for (var E = 1; E <= y2; E++)
        o2 /= 2, (l3 & 1 << y2 - E) > 0 && (h2 += o2);
      return h2;
    }, "parsePrecisionBits"), c3 = R(r2, e3, t2 + 1, false, u2);
    return s2 == Math.pow(2, t2 + 1) - 1 ? c3 === 0 ? i2 === 0 ? 1 / 0 : -1 / 0 : NaN : (i2 === 0 ? 1 : -1) * Math.pow(2, s2 - n2) * c3;
  }, "parseFloatFromBits"), Ia = a(function(r2) {
    return R(r2, 1) == 1 ? -1 * (R(r2, 15, 1, true) + 1) : R(r2, 15, 1);
  }, "parseInt16"), Ai = a(function(r2) {
    return R(r2, 1) == 1 ? -1 * (R(
      r2,
      31,
      1,
      true
    ) + 1) : R(r2, 31, 1);
  }, "parseInt32"), Ta = a(function(r2) {
    return Ii(r2, 23, 8);
  }, "parseFloat32"), Pa = a(function(r2) {
    return Ii(r2, 52, 11);
  }, "parseFloat64"), Ba = a(function(r2) {
    var e3 = R(r2, 16, 32);
    if (e3 == 49152)
      return NaN;
    for (var t2 = Math.pow(1e4, R(r2, 16, 16)), n2 = 0, i2 = [], s2 = R(r2, 16), o2 = 0; o2 < s2; o2++)
      n2 += R(r2, 16, 64 + 16 * o2) * t2, t2 /= 1e4;
    var u2 = Math.pow(10, R(r2, 16, 48));
    return (e3 === 0 ? 1 : -1) * Math.round(n2 * u2) / u2;
  }, "parseNumeric"), Ci = a(function(r2, e3) {
    var t2 = R(
      e3,
      1
    ), n2 = R(e3, 63, 1), i2 = new Date((t2 === 0 ? 1 : -1) * n2 / 1e3 + 9466848e5);
    return r2 || i2.setTime(i2.getTime() + i2.getTimezoneOffset() * 6e4), i2.usec = n2 % 1e3, i2.getMicroSeconds = function() {
      return this.usec;
    }, i2.setMicroSeconds = function(s2) {
      this.usec = s2;
    }, i2.getUTCMicroSeconds = function() {
      return this.usec;
    }, i2;
  }, "parseDate"), Ye = a(function(r2) {
    for (var e3 = R(r2, 32), t2 = R(r2, 32, 32), n2 = R(r2, 32, 64), i2 = 96, s2 = [], o2 = 0; o2 < e3; o2++)
      s2[o2] = R(r2, 32, i2), i2 += 32, i2 += 32;
    var u2 = a(function(h2) {
      var l3 = R(r2, 32, i2);
      if (i2 += 32, l3 == 4294967295)
        return null;
      var y2;
      if (h2 == 23 || h2 == 20)
        return y2 = R(r2, l3 * 8, i2), i2 += l3 * 8, y2;
      if (h2 == 25)
        return y2 = r2.toString(this.encoding, i2 >> 3, (i2 += l3 << 3) >> 3), y2;
      console.log("ERROR: ElementType not implemented: " + h2);
    }, "parseElement"), c3 = a(function(h2, l3) {
      var y2 = [], E;
      if (h2.length > 1) {
        var _ = h2.shift();
        for (E = 0; E < _; E++)
          y2[E] = c3(h2, l3);
        h2.unshift(
          _
        );
      } else
        for (E = 0; E < h2[0]; E++)
          y2[E] = u2(l3);
      return y2;
    }, "parse");
    return c3(s2, n2);
  }, "parseArray"), La = a(function(r2) {
    return r2.toString("utf8");
  }, "parseText"), Ra = a(function(r2) {
    return r2 === null ? null : R(r2, 8) > 0;
  }, "parseBool"), Fa = a(function(r2) {
    r2(20, Ca), r2(21, Ia), r2(23, Ai), r2(
      26,
      Ai
    ), r2(1700, Ba), r2(700, Ta), r2(701, Pa), r2(16, Ra), r2(1114, Ci.bind(null, false)), r2(1184, Ci.bind(
      null,
      true
    )), r2(1e3, Ye), r2(1007, Ye), r2(1016, Ye), r2(1008, Ye), r2(1009, Ye), r2(25, La);
  }, "init");
  Ti.exports = { init: Fa };
});
var Li = I((Uh, Bi) => {
  p3();
  Bi.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});
var Xe = I((Je) => {
  p3();
  var Ma = Ei(), Da = Pi(), Oa = Wt(), ka = Li();
  Je.getTypeParser = Ua;
  Je.setTypeParser = qa;
  Je.arrayParser = Oa;
  Je.builtins = ka;
  var Ze = { text: {}, binary: {} };
  function Ri(r2) {
    return String(
      r2
    );
  }
  a(Ri, "noParse");
  function Ua(r2, e3) {
    return e3 = e3 || "text", Ze[e3] && Ze[e3][r2] || Ri;
  }
  a(
    Ua,
    "getTypeParser"
  );
  function qa(r2, e3, t2) {
    typeof e3 == "function" && (t2 = e3, e3 = "text"), Ze[e3][r2] = t2;
  }
  a(qa, "setTypeParser");
  Ma.init(function(r2, e3) {
    Ze.text[r2] = e3;
  });
  Da.init(function(r2, e3) {
    Ze.binary[r2] = e3;
  });
});
var et = I((jh, Yt) => {
  "use strict";
  p3();
  Yt.exports = {
    host: "localhost",
    user: m2.platform === "win32" ? m2.env.USERNAME : m2.env.USER,
    database: void 0,
    password: null,
    connectionString: void 0,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 3e4,
    client_encoding: "",
    ssl: false,
    application_name: void 0,
    fallback_application_name: void 0,
    options: void 0,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var Me = Xe(), Na = Me.getTypeParser(
    20,
    "text"
  ), Qa = Me.getTypeParser(1016, "text");
  Yt.exports.__defineSetter__("parseInt8", function(r2) {
    Me.setTypeParser(20, "text", r2 ? Me.getTypeParser(23, "text") : Na), Me.setTypeParser(1016, "text", r2 ? Me.getTypeParser(1007, "text") : Qa);
  });
});
var tt = I((Gh, Mi) => {
  "use strict";
  p3();
  var Wa = (qt(), k(Ut)), ja = et();
  function Ha(r2) {
    var e3 = r2.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + e3 + '"';
  }
  a(Ha, "escapeElement");
  function Fi(r2) {
    for (var e3 = "{", t2 = 0; t2 < r2.length; t2++)
      t2 > 0 && (e3 = e3 + ","), r2[t2] === null || typeof r2[t2] > "u" ? e3 = e3 + "NULL" : Array.isArray(r2[t2]) ? e3 = e3 + Fi(r2[t2]) : r2[t2] instanceof d3 ? e3 += "\\\\x" + r2[t2].toString("hex") : e3 += Ha(ft(r2[t2]));
    return e3 = e3 + "}", e3;
  }
  a(Fi, "arrayString");
  var ft = a(function(r2, e3) {
    if (r2 == null)
      return null;
    if (r2 instanceof d3)
      return r2;
    if (ArrayBuffer.isView(r2)) {
      var t2 = d3.from(r2.buffer, r2.byteOffset, r2.byteLength);
      return t2.length === r2.byteLength ? t2 : t2.slice(
        r2.byteOffset,
        r2.byteOffset + r2.byteLength
      );
    }
    return r2 instanceof Date ? ja.parseInputDatesAsUTC ? Ka(r2) : $a(r2) : Array.isArray(r2) ? Fi(r2) : typeof r2 == "object" ? Ga(r2, e3) : r2.toString();
  }, "prepareValue");
  function Ga(r2, e3) {
    if (r2 && typeof r2.toPostgres == "function") {
      if (e3 = e3 || [], e3.indexOf(r2) !== -1)
        throw new Error('circular reference detected while preparing "' + r2 + '" for query');
      return e3.push(r2), ft(r2.toPostgres(ft), e3);
    }
    return JSON.stringify(r2);
  }
  a(Ga, "prepareObject");
  function j2(r2, e3) {
    for (r2 = "" + r2; r2.length < e3; )
      r2 = "0" + r2;
    return r2;
  }
  a(
    j2,
    "pad"
  );
  function $a(r2) {
    var e3 = -r2.getTimezoneOffset(), t2 = r2.getFullYear(), n2 = t2 < 1;
    n2 && (t2 = Math.abs(t2) + 1);
    var i2 = j2(t2, 4) + "-" + j2(r2.getMonth() + 1, 2) + "-" + j2(r2.getDate(), 2) + "T" + j2(r2.getHours(), 2) + ":" + j2(r2.getMinutes(), 2) + ":" + j2(r2.getSeconds(), 2) + "." + j2(
      r2.getMilliseconds(),
      3
    );
    return e3 < 0 ? (i2 += "-", e3 *= -1) : i2 += "+", i2 += j2(Math.floor(e3 / 60), 2) + ":" + j2(e3 % 60, 2), n2 && (i2 += " BC"), i2;
  }
  a($a, "dateToString");
  function Ka(r2) {
    var e3 = r2.getUTCFullYear(), t2 = e3 < 1;
    t2 && (e3 = Math.abs(e3) + 1);
    var n2 = j2(e3, 4) + "-" + j2(r2.getUTCMonth() + 1, 2) + "-" + j2(r2.getUTCDate(), 2) + "T" + j2(r2.getUTCHours(), 2) + ":" + j2(r2.getUTCMinutes(), 2) + ":" + j2(r2.getUTCSeconds(), 2) + "." + j2(r2.getUTCMilliseconds(), 3);
    return n2 += "+00:00", t2 && (n2 += " BC"), n2;
  }
  a(Ka, "dateToStringUTC");
  function Va(r2, e3, t2) {
    return r2 = typeof r2 == "string" ? { text: r2 } : r2, e3 && (typeof e3 == "function" ? r2.callback = e3 : r2.values = e3), t2 && (r2.callback = t2), r2;
  }
  a(Va, "normalizeQueryConfig");
  var Zt = a(function(r2) {
    return Wa.createHash("md5").update(r2, "utf-8").digest("hex");
  }, "md5"), za = a(function(r2, e3, t2) {
    var n2 = Zt(e3 + r2), i2 = Zt(d3.concat([d3.from(n2), t2]));
    return "md5" + i2;
  }, "postgresMd5PasswordHash");
  Mi.exports = { prepareValue: a(function(e3) {
    return ft(
      e3
    );
  }, "prepareValueWrapper"), normalizeQueryConfig: Va, postgresMd5PasswordHash: za, md5: Zt };
});
var qi = I((Vh, Ui) => {
  "use strict";
  p3();
  var Jt = (qt(), k(Ut));
  function Ya(r2) {
    if (r2.indexOf(
      "SCRAM-SHA-256"
    ) === -1)
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    let e3 = Jt.randomBytes(18).toString("base64");
    return { mechanism: "SCRAM-SHA-256", clientNonce: e3, response: "n,,n=*,r=" + e3, message: "SASLInitialResponse" };
  }
  a(Ya, "startSession");
  function Za(r2, e3, t2) {
    if (r2.message !== "SASLInitialResponse")
      throw new Error(
        "SASL: Last message was not SASLInitialResponse"
      );
    if (typeof e3 != "string")
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string"
      );
    if (typeof t2 != "string")
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    let n2 = eu(t2);
    if (n2.nonce.startsWith(r2.clientNonce)) {
      if (n2.nonce.length === r2.clientNonce.length)
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    var i2 = d3.from(n2.salt, "base64"), s2 = nu(
      e3,
      i2,
      n2.iteration
    ), o2 = De(s2, "Client Key"), u2 = ru(o2), c3 = "n=*,r=" + r2.clientNonce, h2 = "r=" + n2.nonce + ",s=" + n2.salt + ",i=" + n2.iteration, l3 = "c=biws,r=" + n2.nonce, y2 = c3 + "," + h2 + "," + l3, E = De(u2, y2), _ = ki(
      o2,
      E
    ), P2 = _.toString("base64"), N = De(s2, "Server Key"), J = De(N, y2);
    r2.message = "SASLResponse", r2.serverSignature = J.toString("base64"), r2.response = l3 + ",p=" + P2;
  }
  a(Za, "continueSession");
  function Ja(r2, e3) {
    if (r2.message !== "SASLResponse")
      throw new Error("SASL: Last message was not SASLResponse");
    if (typeof e3 != "string")
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    let { serverSignature: t2 } = tu(
      e3
    );
    if (t2 !== r2.serverSignature)
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
  }
  a(Ja, "finalizeSession");
  function Xa(r2) {
    if (typeof r2 != "string")
      throw new TypeError("SASL: text must be a string");
    return r2.split("").map(
      (e3, t2) => r2.charCodeAt(t2)
    ).every((e3) => e3 >= 33 && e3 <= 43 || e3 >= 45 && e3 <= 126);
  }
  a(Xa, "isPrintableChars");
  function Di(r2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r2);
  }
  a(Di, "isBase64");
  function Oi(r2) {
    if (typeof r2 != "string")
      throw new TypeError(
        "SASL: attribute pairs text must be a string"
      );
    return new Map(r2.split(",").map((e3) => {
      if (!/^.=/.test(e3))
        throw new Error("SASL: Invalid attribute pair entry");
      let t2 = e3[0], n2 = e3.substring(2);
      return [t2, n2];
    }));
  }
  a(Oi, "parseAttributePairs");
  function eu(r2) {
    let e3 = Oi(
      r2
    ), t2 = e3.get("r");
    if (t2) {
      if (!Xa(t2))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    let n2 = e3.get("s");
    if (n2) {
      if (!Di(n2))
        throw new Error(
          "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64"
        );
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    let i2 = e3.get("i");
    if (i2) {
      if (!/^[1-9][0-9]*$/.test(i2))
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    } else
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    let s2 = parseInt(i2, 10);
    return { nonce: t2, salt: n2, iteration: s2 };
  }
  a(eu, "parseServerFirstMessage");
  function tu(r2) {
    let t2 = Oi(r2).get("v");
    if (t2) {
      if (!Di(t2))
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    } else
      throw new Error(
        "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing"
      );
    return { serverSignature: t2 };
  }
  a(tu, "parseServerFinalMessage");
  function ki(r2, e3) {
    if (!d3.isBuffer(r2))
      throw new TypeError(
        "first argument must be a Buffer"
      );
    if (!d3.isBuffer(e3))
      throw new TypeError("second argument must be a Buffer");
    if (r2.length !== e3.length)
      throw new Error("Buffer lengths must match");
    if (r2.length === 0)
      throw new Error("Buffers cannot be empty");
    return d3.from(r2.map((t2, n2) => r2[n2] ^ e3[n2]));
  }
  a(ki, "xorBuffers");
  function ru(r2) {
    return Jt.createHash(
      "sha256"
    ).update(r2).digest();
  }
  a(ru, "sha256");
  function De(r2, e3) {
    return Jt.createHmac(
      "sha256",
      r2
    ).update(e3).digest();
  }
  a(De, "hmacSha256");
  function nu(r2, e3, t2) {
    for (var n2 = De(
      r2,
      d3.concat([e3, d3.from([0, 0, 0, 1])])
    ), i2 = n2, s2 = 0; s2 < t2 - 1; s2++)
      n2 = De(r2, n2), i2 = ki(i2, n2);
    return i2;
  }
  a(nu, "Hi");
  Ui.exports = { startSession: Ya, continueSession: Za, finalizeSession: Ja };
});
var Xt = {};
X2(Xt, { join: () => iu });
function iu(...r2) {
  return r2.join("/");
}
var er = K2(() => {
  "use strict";
  p3();
  a(iu, "join");
});
var tr = {};
X2(tr, { stat: () => su });
function su(r2, e3) {
  e3(new Error("No filesystem"));
}
var rr = K2(
  () => {
    "use strict";
    p3();
    a(su, "stat");
  }
);
var nr = {};
X2(nr, { default: () => ou });
var ou;
var ir = K2(() => {
  "use strict";
  p3();
  ou = {};
});
var Ni = {};
X2(Ni, { StringDecoder: () => sr });
var or;
var sr;
var Qi = K2(() => {
  "use strict";
  p3();
  or = class or {
    constructor(e3) {
      T(this, "td");
      this.td = new TextDecoder(e3);
    }
    write(e3) {
      return this.td.decode(e3, { stream: true });
    }
    end(e3) {
      return this.td.decode(e3);
    }
  };
  a(or, "StringDecoder");
  sr = or;
});
var Gi = I((il, Hi) => {
  "use strict";
  p3();
  var { Transform: au } = (ir(), k(nr)), { StringDecoder: uu } = (Qi(), k(Ni)), we = Symbol("last"), pt = Symbol("decoder");
  function cu(r2, e3, t2) {
    let n2;
    if (this.overflow) {
      if (n2 = this[pt].write(r2).split(this.matcher), n2.length === 1)
        return t2();
      n2.shift(), this.overflow = false;
    } else
      this[we] += this[pt].write(r2), n2 = this[we].split(this.matcher);
    this[we] = n2.pop();
    for (let i2 = 0; i2 < n2.length; i2++)
      try {
        ji(this, this.mapper(n2[i2]));
      } catch (s2) {
        return t2(
          s2
        );
      }
    if (this.overflow = this[we].length > this.maxLength, this.overflow && !this.skipOverflow) {
      t2(new Error("maximum buffer reached"));
      return;
    }
    t2();
  }
  a(cu, "transform");
  function hu(r2) {
    if (this[we] += this[pt].end(), this[we])
      try {
        ji(this, this.mapper(this[we]));
      } catch (e3) {
        return r2(e3);
      }
    r2();
  }
  a(hu, "flush");
  function ji(r2, e3) {
    e3 !== void 0 && r2.push(e3);
  }
  a(ji, "push");
  function Wi(r2) {
    return r2;
  }
  a(Wi, "noop");
  function lu(r2, e3, t2) {
    switch (r2 = r2 || /\r?\n/, e3 = e3 || Wi, t2 = t2 || {}, arguments.length) {
      case 1:
        typeof r2 == "function" ? (e3 = r2, r2 = /\r?\n/) : typeof r2 == "object" && !(r2 instanceof RegExp) && !r2[Symbol.split] && (t2 = r2, r2 = /\r?\n/);
        break;
      case 2:
        typeof r2 == "function" ? (t2 = e3, e3 = r2, r2 = /\r?\n/) : typeof e3 == "object" && (t2 = e3, e3 = Wi);
    }
    t2 = Object.assign({}, t2), t2.autoDestroy = true, t2.transform = cu, t2.flush = hu, t2.readableObjectMode = true;
    let n2 = new au(t2);
    return n2[we] = "", n2[pt] = new uu("utf8"), n2.matcher = r2, n2.mapper = e3, n2.maxLength = t2.maxLength, n2.skipOverflow = t2.skipOverflow || false, n2.overflow = false, n2._destroy = function(i2, s2) {
      this._writableState.errorEmitted = false, s2(i2);
    }, n2;
  }
  a(lu, "split");
  Hi.exports = lu;
});
var Vi = I((al, fe) => {
  "use strict";
  p3();
  var $i = (er(), k(Xt)), fu = (ir(), k(nr)).Stream, pu = Gi(), Ki = (Ge(), k(He)), du = 5432, dt = m2.platform === "win32", rt = m2.stderr, yu = 56, mu = 7, gu = 61440, wu = 32768;
  function bu(r2) {
    return (r2 & gu) == wu;
  }
  a(bu, "isRegFile");
  var Oe = [
    "host",
    "port",
    "database",
    "user",
    "password"
  ], ar = Oe.length, Su = Oe[ar - 1];
  function ur() {
    var r2 = rt instanceof fu && rt.writable === true;
    if (r2) {
      var e3 = Array.prototype.slice.call(arguments).concat(`
`);
      rt.write(Ki.format.apply(Ki, e3));
    }
  }
  a(ur, "warn");
  Object.defineProperty(
    fe.exports,
    "isWin",
    { get: function() {
      return dt;
    }, set: function(r2) {
      dt = r2;
    } }
  );
  fe.exports.warnTo = function(r2) {
    var e3 = rt;
    return rt = r2, e3;
  };
  fe.exports.getFileName = function(r2) {
    var e3 = r2 || m2.env, t2 = e3.PGPASSFILE || (dt ? $i.join(e3.APPDATA || "./", "postgresql", "pgpass.conf") : $i.join(e3.HOME || "./", ".pgpass"));
    return t2;
  };
  fe.exports.usePgPass = function(r2, e3) {
    return Object.prototype.hasOwnProperty.call(m2.env, "PGPASSWORD") ? false : dt ? true : (e3 = e3 || "<unkn>", bu(r2.mode) ? r2.mode & (yu | mu) ? (ur('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', e3), false) : true : (ur(
      'WARNING: password file "%s" is not a plain file',
      e3
    ), false));
  };
  var xu = fe.exports.match = function(r2, e3) {
    return Oe.slice(0, -1).reduce(
      function(t2, n2, i2) {
        return i2 == 1 && Number(r2[n2] || du) === Number(e3[n2]) ? t2 && true : t2 && (e3[n2] === "*" || e3[n2] === r2[n2]);
      },
      true
    );
  };
  fe.exports.getPassword = function(r2, e3, t2) {
    var n2, i2 = e3.pipe(pu());
    function s2(c3) {
      var h2 = Eu(
        c3
      );
      h2 && vu(h2) && xu(r2, h2) && (n2 = h2[Su], i2.end());
    }
    a(s2, "onLine");
    var o2 = a(function() {
      e3.destroy(), t2(n2);
    }, "onEnd"), u2 = a(function(c3) {
      e3.destroy(), ur("WARNING: error on reading file: %s", c3), t2(void 0);
    }, "onErr");
    e3.on("error", u2), i2.on("data", s2).on("end", o2).on(
      "error",
      u2
    );
  };
  var Eu = fe.exports.parseLine = function(r2) {
    if (r2.length < 11 || r2.match(/^\s+#/))
      return null;
    for (var e3 = "", t2 = "", n2 = 0, i2 = 0, s2 = 0, o2 = {}, u2 = false, c3 = a(function(l3, y2, E) {
      var _ = r2.substring(
        y2,
        E
      );
      Object.hasOwnProperty.call(m2.env, "PGPASS_NO_DEESCAPE") || (_ = _.replace(
        /\\([:\\])/g,
        "$1"
      )), o2[Oe[l3]] = _;
    }, "addToObj"), h2 = 0; h2 < r2.length - 1; h2 += 1) {
      if (e3 = r2.charAt(h2 + 1), t2 = r2.charAt(
        h2
      ), u2 = n2 == ar - 1, u2) {
        c3(n2, i2);
        break;
      }
      h2 >= 0 && e3 == ":" && t2 !== "\\" && (c3(n2, i2, h2 + 1), i2 = h2 + 2, n2 += 1);
    }
    return o2 = Object.keys(o2).length === ar ? o2 : null, o2;
  }, vu = fe.exports.isValidEntry = function(r2) {
    for (var e3 = {
      0: function(o2) {
        return o2.length > 0;
      },
      1: function(o2) {
        return o2 === "*" ? true : (o2 = Number(o2), isFinite(
          o2
        ) && o2 > 0 && o2 < 9007199254740992 && Math.floor(o2) === o2);
      },
      2: function(o2) {
        return o2.length > 0;
      },
      3: function(o2) {
        return o2.length > 0;
      },
      4: function(o2) {
        return o2.length > 0;
      }
    }, t2 = 0; t2 < Oe.length; t2 += 1) {
      var n2 = e3[t2], i2 = r2[Oe[t2]] || "", s2 = n2(i2);
      if (!s2)
        return false;
    }
    return true;
  };
});
var Yi = I((ll, cr) => {
  "use strict";
  p3();
  var hl = (er(), k(Xt)), zi = (rr(), k(tr)), yt = Vi();
  cr.exports = function(r2, e3) {
    var t2 = yt.getFileName();
    zi.stat(t2, function(n2, i2) {
      if (n2 || !yt.usePgPass(i2, t2))
        return e3(void 0);
      var s2 = zi.createReadStream(t2);
      yt.getPassword(
        r2,
        s2,
        e3
      );
    });
  };
  cr.exports.warnTo = yt.warnTo;
});
var hr = I((pl, Zi) => {
  "use strict";
  p3();
  var _u = Xe();
  function mt(r2) {
    this._types = r2 || _u, this.text = {}, this.binary = {};
  }
  a(mt, "TypeOverrides");
  mt.prototype.getOverrides = function(r2) {
    switch (r2) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  mt.prototype.setTypeParser = function(r2, e3, t2) {
    typeof e3 == "function" && (t2 = e3, e3 = "text"), this.getOverrides(e3)[r2] = t2;
  };
  mt.prototype.getTypeParser = function(r2, e3) {
    return e3 = e3 || "text", this.getOverrides(e3)[r2] || this._types.getTypeParser(r2, e3);
  };
  Zi.exports = mt;
});
var Ji = {};
X2(Ji, { default: () => Au });
var Au;
var Xi = K2(() => {
  "use strict";
  p3();
  Au = {};
});
var es = {};
X2(es, { parse: () => lr });
function lr(r2, e3 = false) {
  let { protocol: t2 } = new URL(r2), n2 = "http:" + r2.substring(t2.length), {
    username: i2,
    password: s2,
    host: o2,
    hostname: u2,
    port: c3,
    pathname: h2,
    search: l3,
    searchParams: y2,
    hash: E
  } = new URL(n2);
  s2 = decodeURIComponent(s2);
  let _ = i2 + ":" + s2, P2 = e3 ? Object.fromEntries(y2.entries()) : l3;
  return {
    href: r2,
    protocol: t2,
    auth: _,
    username: i2,
    password: s2,
    host: o2,
    hostname: u2,
    port: c3,
    pathname: h2,
    search: l3,
    query: P2,
    hash: E
  };
}
var fr = K2(
  () => {
    "use strict";
    p3();
    a(lr, "parse");
  }
);
var rs = I((bl, ts) => {
  "use strict";
  p3();
  var Cu = (fr(), k(es)), pr = (rr(), k(tr));
  function dr(r2) {
    if (r2.charAt(0) === "/") {
      var t2 = r2.split(" ");
      return { host: t2[0], database: t2[1] };
    }
    var e3 = Cu.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r2) ? encodeURI(r2).replace(
      /\%25(\d\d)/g,
      "%$1"
    ) : r2, true), t2 = e3.query;
    for (var n2 in t2)
      Array.isArray(t2[n2]) && (t2[n2] = t2[n2][t2[n2].length - 1]);
    var i2 = (e3.auth || ":").split(":");
    if (t2.user = i2[0], t2.password = i2.splice(1).join(":"), t2.port = e3.port, e3.protocol == "socket:")
      return t2.host = decodeURI(e3.pathname), t2.database = e3.query.db, t2.client_encoding = e3.query.encoding, t2;
    t2.host || (t2.host = e3.hostname);
    var s2 = e3.pathname;
    if (!t2.host && s2 && /^%2f/i.test(s2)) {
      var o2 = s2.split("/");
      t2.host = decodeURIComponent(
        o2[0]
      ), s2 = o2.splice(1).join("/");
    }
    switch (s2 && s2.charAt(0) === "/" && (s2 = s2.slice(1) || null), t2.database = s2 && decodeURI(s2), (t2.ssl === "true" || t2.ssl === "1") && (t2.ssl = true), t2.ssl === "0" && (t2.ssl = false), (t2.sslcert || t2.sslkey || t2.sslrootcert || t2.sslmode) && (t2.ssl = {}), t2.sslcert && (t2.ssl.cert = pr.readFileSync(t2.sslcert).toString()), t2.sslkey && (t2.ssl.key = pr.readFileSync(
      t2.sslkey
    ).toString()), t2.sslrootcert && (t2.ssl.ca = pr.readFileSync(t2.sslrootcert).toString()), t2.sslmode) {
      case "disable": {
        t2.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        break;
      case "no-verify": {
        t2.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return t2;
  }
  a(dr, "parse");
  ts.exports = dr;
  dr.parse = dr;
});
var gt = I((El, ss) => {
  "use strict";
  p3();
  var Iu = (Xi(), k(Ji)), is2 = et(), ns = rs().parse, V = a(
    function(r2, e3, t2) {
      return t2 === void 0 ? t2 = m2.env["PG" + r2.toUpperCase()] : t2 === false || (t2 = m2.env[t2]), e3[r2] || t2 || is2[r2];
    },
    "val"
  ), Tu = a(function() {
    switch (m2.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return is2.ssl;
  }, "readSSLConfigFromEnvironment"), ke = a(
    function(r2) {
      return "'" + ("" + r2).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    },
    "quoteParamValue"
  ), re = a(function(r2, e3, t2) {
    var n2 = e3[t2];
    n2 != null && r2.push(t2 + "=" + ke(n2));
  }, "add"), mr = class mr {
    constructor(e3) {
      e3 = typeof e3 == "string" ? ns(e3) : e3 || {}, e3.connectionString && (e3 = Object.assign({}, e3, ns(e3.connectionString))), this.user = V("user", e3), this.database = V("database", e3), this.database === void 0 && (this.database = this.user), this.port = parseInt(
        V("port", e3),
        10
      ), this.host = V("host", e3), Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: V("password", e3)
      }), this.binary = V("binary", e3), this.options = V("options", e3), this.ssl = typeof e3.ssl > "u" ? Tu() : e3.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = true), this.ssl === "no-verify" && (this.ssl = { rejectUnauthorized: false }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this.client_encoding = V("client_encoding", e3), this.replication = V("replication", e3), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = V("application_name", e3, "PGAPPNAME"), this.fallback_application_name = V("fallback_application_name", e3, false), this.statement_timeout = V("statement_timeout", e3, false), this.lock_timeout = V(
        "lock_timeout",
        e3,
        false
      ), this.idle_in_transaction_session_timeout = V("idle_in_transaction_session_timeout", e3, false), this.query_timeout = V("query_timeout", e3, false), e3.connectionTimeoutMillis === void 0 ? this.connect_timeout = m2.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e3.connectionTimeoutMillis / 1e3), e3.keepAlive === false ? this.keepalives = 0 : e3.keepAlive === true && (this.keepalives = 1), typeof e3.keepAliveInitialDelayMillis == "number" && (this.keepalives_idle = Math.floor(e3.keepAliveInitialDelayMillis / 1e3));
    }
    getLibpqConnectionString(e3) {
      var t2 = [];
      re(t2, this, "user"), re(t2, this, "password"), re(t2, this, "port"), re(t2, this, "application_name"), re(t2, this, "fallback_application_name"), re(t2, this, "connect_timeout"), re(
        t2,
        this,
        "options"
      );
      var n2 = typeof this.ssl == "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      if (re(t2, n2, "sslmode"), re(t2, n2, "sslca"), re(t2, n2, "sslkey"), re(t2, n2, "sslcert"), re(t2, n2, "sslrootcert"), this.database && t2.push("dbname=" + ke(this.database)), this.replication && t2.push("replication=" + ke(this.replication)), this.host && t2.push("host=" + ke(this.host)), this.isDomainSocket)
        return e3(null, t2.join(" "));
      this.client_encoding && t2.push("client_encoding=" + ke(this.client_encoding)), Iu.lookup(this.host, function(i2, s2) {
        return i2 ? e3(i2, null) : (t2.push("hostaddr=" + ke(s2)), e3(null, t2.join(" ")));
      });
    }
  };
  a(mr, "ConnectionParameters");
  var yr = mr;
  ss.exports = yr;
});
var us = I((Al, as) => {
  "use strict";
  p3();
  var Pu = Xe(), os = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, wr = class wr {
    constructor(e3, t2) {
      this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t2, this.RowCtor = null, this.rowAsArray = e3 === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
    }
    addCommandComplete(e3) {
      var t2;
      e3.text ? t2 = os.exec(e3.text) : t2 = os.exec(e3.command), t2 && (this.command = t2[1], t2[3] ? (this.oid = parseInt(t2[2], 10), this.rowCount = parseInt(t2[3], 10)) : t2[2] && (this.rowCount = parseInt(
        t2[2],
        10
      )));
    }
    _parseRowAsArray(e3) {
      for (var t2 = new Array(e3.length), n2 = 0, i2 = e3.length; n2 < i2; n2++) {
        var s2 = e3[n2];
        s2 !== null ? t2[n2] = this._parsers[n2](s2) : t2[n2] = null;
      }
      return t2;
    }
    parseRow(e3) {
      for (var t2 = {}, n2 = 0, i2 = e3.length; n2 < i2; n2++) {
        var s2 = e3[n2], o2 = this.fields[n2].name;
        s2 !== null ? t2[o2] = this._parsers[n2](
          s2
        ) : t2[o2] = null;
      }
      return t2;
    }
    addRow(e3) {
      this.rows.push(e3);
    }
    addFields(e3) {
      this.fields = e3, this.fields.length && (this._parsers = new Array(e3.length));
      for (var t2 = 0; t2 < e3.length; t2++) {
        var n2 = e3[t2];
        this._types ? this._parsers[t2] = this._types.getTypeParser(n2.dataTypeID, n2.format || "text") : this._parsers[t2] = Pu.getTypeParser(n2.dataTypeID, n2.format || "text");
      }
    }
  };
  a(wr, "Result");
  var gr = wr;
  as.exports = gr;
});
var fs = I((Tl, ls) => {
  "use strict";
  p3();
  var { EventEmitter: Bu } = ge(), cs = us(), hs = tt(), Sr = class Sr extends Bu {
    constructor(e3, t2, n2) {
      super(), e3 = hs.normalizeQueryConfig(e3, t2, n2), this.text = e3.text, this.values = e3.values, this.rows = e3.rows, this.types = e3.types, this.name = e3.name, this.binary = e3.binary, this.portal = e3.portal || "", this.callback = e3.callback, this._rowMode = e3.rowMode, m2.domain && e3.callback && (this.callback = m2.domain.bind(e3.callback)), this._result = new cs(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = false, this._canceledDueToError = false, this._promise = null;
    }
    requiresPreparation() {
      return this.name || this.rows ? true : !this.text || !this.values ? false : this.values.length > 0;
    }
    _checkForMultirow() {
      this._result.command && (Array.isArray(this._results) || (this._results = [this._result]), this._result = new cs(
        this._rowMode,
        this.types
      ), this._results.push(this._result));
    }
    handleRowDescription(e3) {
      this._checkForMultirow(), this._result.addFields(e3.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(e3) {
      let t2;
      if (!this._canceledDueToError) {
        try {
          t2 = this._result.parseRow(e3.fields);
        } catch (n2) {
          this._canceledDueToError = n2;
          return;
        }
        this.emit("row", t2, this._result), this._accumulateRows && this._result.addRow(t2);
      }
    }
    handleCommandComplete(e3, t2) {
      this._checkForMultirow(), this._result.addCommandComplete(e3), this.rows && t2.sync();
    }
    handleEmptyQuery(e3) {
      this.rows && e3.sync();
    }
    handleError(e3, t2) {
      if (this._canceledDueToError && (e3 = this._canceledDueToError, this._canceledDueToError = false), this.callback)
        return this.callback(e3);
      this.emit("error", e3);
    }
    handleReadyForQuery(e3) {
      if (this._canceledDueToError)
        return this.handleError(
          this._canceledDueToError,
          e3
        );
      if (this.callback)
        try {
          this.callback(null, this._results);
        } catch (t2) {
          m2.nextTick(() => {
            throw t2;
          });
        }
      this.emit("end", this._results);
    }
    submit(e3) {
      if (typeof this.text != "string" && typeof this.name != "string")
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      let t2 = e3.parsedStatements[this.name];
      return this.text && t2 && this.text !== t2 ? new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query values must be an array") : (this.requiresPreparation() ? this.prepare(e3) : e3.query(this.text), null);
    }
    hasBeenParsed(e3) {
      return this.name && e3.parsedStatements[this.name];
    }
    handlePortalSuspended(e3) {
      this._getRows(e3, this.rows);
    }
    _getRows(e3, t2) {
      e3.execute(
        { portal: this.portal, rows: t2 }
      ), t2 ? e3.flush() : e3.sync();
    }
    prepare(e3) {
      this.isPreparedStatement = true, this.hasBeenParsed(e3) || e3.parse({ text: this.text, name: this.name, types: this.types });
      try {
        e3.bind({ portal: this.portal, statement: this.name, values: this.values, binary: this.binary, valueMapper: hs.prepareValue });
      } catch (t2) {
        this.handleError(t2, e3);
        return;
      }
      e3.describe(
        { type: "P", name: this.portal || "" }
      ), this._getRows(e3, this.rows);
    }
    handleCopyInResponse(e3) {
      e3.sendCopyFail("No source stream defined");
    }
    handleCopyData(e3, t2) {
    }
  };
  a(Sr, "Query");
  var br = Sr;
  ls.exports = br;
});
var ds = {};
X2(ds, { Socket: () => _e, isIP: () => Lu });
function Lu(r2) {
  return 0;
}
var ps;
var x;
var _e;
var wt = K2(() => {
  "use strict";
  p3();
  ps = We(ge(), 1);
  a(Lu, "isIP");
  x = class x2 extends ps.EventEmitter {
    constructor() {
      super(...arguments);
      T(this, "opts", {});
      T(this, "connecting", false);
      T(this, "pending", true);
      T(this, "writable", true);
      T(this, "encrypted", false);
      T(this, "authorized", false);
      T(this, "destroyed", false);
      T(this, "ws", null);
      T(this, "writeBuffer");
      T(this, "tlsState", 0);
      T(
        this,
        "tlsRead"
      );
      T(this, "tlsWrite");
    }
    static get poolQueryViaFetch() {
      return x2.opts.poolQueryViaFetch ?? x2.defaults.poolQueryViaFetch;
    }
    static set poolQueryViaFetch(t2) {
      x2.opts.poolQueryViaFetch = t2;
    }
    static get fetchEndpoint() {
      return x2.opts.fetchEndpoint ?? x2.defaults.fetchEndpoint;
    }
    static set fetchEndpoint(t2) {
      x2.opts.fetchEndpoint = t2;
    }
    static get fetchConnectionCache() {
      return x2.opts.fetchConnectionCache ?? x2.defaults.fetchConnectionCache;
    }
    static set fetchConnectionCache(t2) {
      x2.opts.fetchConnectionCache = t2;
    }
    static get fetchFunction() {
      return x2.opts.fetchFunction ?? x2.defaults.fetchFunction;
    }
    static set fetchFunction(t2) {
      x2.opts.fetchFunction = t2;
    }
    static get webSocketConstructor() {
      return x2.opts.webSocketConstructor ?? x2.defaults.webSocketConstructor;
    }
    static set webSocketConstructor(t2) {
      x2.opts.webSocketConstructor = t2;
    }
    get webSocketConstructor() {
      return this.opts.webSocketConstructor ?? x2.webSocketConstructor;
    }
    set webSocketConstructor(t2) {
      this.opts.webSocketConstructor = t2;
    }
    static get wsProxy() {
      return x2.opts.wsProxy ?? x2.defaults.wsProxy;
    }
    static set wsProxy(t2) {
      x2.opts.wsProxy = t2;
    }
    get wsProxy() {
      return this.opts.wsProxy ?? x2.wsProxy;
    }
    set wsProxy(t2) {
      this.opts.wsProxy = t2;
    }
    static get coalesceWrites() {
      return x2.opts.coalesceWrites ?? x2.defaults.coalesceWrites;
    }
    static set coalesceWrites(t2) {
      x2.opts.coalesceWrites = t2;
    }
    get coalesceWrites() {
      return this.opts.coalesceWrites ?? x2.coalesceWrites;
    }
    set coalesceWrites(t2) {
      this.opts.coalesceWrites = t2;
    }
    static get useSecureWebSocket() {
      return x2.opts.useSecureWebSocket ?? x2.defaults.useSecureWebSocket;
    }
    static set useSecureWebSocket(t2) {
      x2.opts.useSecureWebSocket = t2;
    }
    get useSecureWebSocket() {
      return this.opts.useSecureWebSocket ?? x2.useSecureWebSocket;
    }
    set useSecureWebSocket(t2) {
      this.opts.useSecureWebSocket = t2;
    }
    static get forceDisablePgSSL() {
      return x2.opts.forceDisablePgSSL ?? x2.defaults.forceDisablePgSSL;
    }
    static set forceDisablePgSSL(t2) {
      x2.opts.forceDisablePgSSL = t2;
    }
    get forceDisablePgSSL() {
      return this.opts.forceDisablePgSSL ?? x2.forceDisablePgSSL;
    }
    set forceDisablePgSSL(t2) {
      this.opts.forceDisablePgSSL = t2;
    }
    static get disableSNI() {
      return x2.opts.disableSNI ?? x2.defaults.disableSNI;
    }
    static set disableSNI(t2) {
      x2.opts.disableSNI = t2;
    }
    get disableSNI() {
      return this.opts.disableSNI ?? x2.disableSNI;
    }
    set disableSNI(t2) {
      this.opts.disableSNI = t2;
    }
    static get pipelineConnect() {
      return x2.opts.pipelineConnect ?? x2.defaults.pipelineConnect;
    }
    static set pipelineConnect(t2) {
      x2.opts.pipelineConnect = t2;
    }
    get pipelineConnect() {
      return this.opts.pipelineConnect ?? x2.pipelineConnect;
    }
    set pipelineConnect(t2) {
      this.opts.pipelineConnect = t2;
    }
    static get subtls() {
      return x2.opts.subtls ?? x2.defaults.subtls;
    }
    static set subtls(t2) {
      x2.opts.subtls = t2;
    }
    get subtls() {
      return this.opts.subtls ?? x2.subtls;
    }
    set subtls(t2) {
      this.opts.subtls = t2;
    }
    static get pipelineTLS() {
      return x2.opts.pipelineTLS ?? x2.defaults.pipelineTLS;
    }
    static set pipelineTLS(t2) {
      x2.opts.pipelineTLS = t2;
    }
    get pipelineTLS() {
      return this.opts.pipelineTLS ?? x2.pipelineTLS;
    }
    set pipelineTLS(t2) {
      this.opts.pipelineTLS = t2;
    }
    static get rootCerts() {
      return x2.opts.rootCerts ?? x2.defaults.rootCerts;
    }
    static set rootCerts(t2) {
      x2.opts.rootCerts = t2;
    }
    get rootCerts() {
      return this.opts.rootCerts ?? x2.rootCerts;
    }
    set rootCerts(t2) {
      this.opts.rootCerts = t2;
    }
    wsProxyAddrForHost(t2, n2) {
      let i2 = this.wsProxy;
      if (i2 === void 0)
        throw new Error("No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string");
      return typeof i2 == "function" ? i2(t2, n2) : `${i2}?address=${t2}:${n2}`;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    connect(t2, n2, i2) {
      this.connecting = true, i2 && this.once("connect", i2);
      let s2 = a(() => {
        this.connecting = false, this.pending = false, this.emit("connect"), this.emit("ready");
      }, "handleWebSocketOpen"), o2 = a((c3, h2 = false) => {
        c3.binaryType = "arraybuffer", c3.addEventListener("error", (l3) => {
          this.emit("error", l3), this.emit("close");
        }), c3.addEventListener("message", (l3) => {
          if (this.tlsState === 0) {
            let y2 = d3.from(l3.data);
            this.emit(
              "data",
              y2
            );
          }
        }), c3.addEventListener("close", () => {
          this.emit("close");
        }), h2 ? s2() : c3.addEventListener(
          "open",
          s2
        );
      }, "configureWebSocket"), u2;
      try {
        u2 = this.wsProxyAddrForHost(n2, typeof t2 == "string" ? parseInt(t2, 10) : t2);
      } catch (c3) {
        this.emit("error", c3), this.emit("close");
        return;
      }
      try {
        let h2 = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u2;
        if (this.webSocketConstructor !== void 0)
          this.ws = new this.webSocketConstructor(h2), o2(this.ws);
        else
          try {
            this.ws = new WebSocket(
              h2
            ), o2(this.ws);
          } catch {
            this.ws = new __unstable_WebSocket(h2), o2(this.ws);
          }
      } catch (c3) {
        let l3 = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u2;
        fetch(l3, { headers: { Upgrade: "websocket" } }).then((y2) => {
          if (this.ws = y2.webSocket, this.ws == null)
            throw c3;
          this.ws.accept(), o2(
            this.ws,
            true
          );
        }).catch((y2) => {
          this.emit("error", new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websocket--undefined. Details: ${y2.message}`)), this.emit("close");
        });
      }
    }
    async startTls(t2) {
      if (this.subtls === void 0)
        throw new Error("For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information.");
      this.tlsState = 1;
      let n2 = this.subtls.TrustedCert.fromPEM(this.rootCerts), i2 = new this.subtls.WebSocketReadQueue(this.ws), s2 = i2.read.bind(
        i2
      ), o2 = this.rawWrite.bind(this), [u2, c3] = await this.subtls.startTls(t2, n2, s2, o2, { useSNI: !this.disableSNI, expectPreData: this.pipelineTLS ? new Uint8Array([83]) : void 0 });
      this.tlsRead = u2, this.tlsWrite = c3, this.tlsState = 2, this.encrypted = true, this.authorized = true, this.emit(
        "secureConnection",
        this
      ), this.tlsReadLoop();
    }
    async tlsReadLoop() {
      for (; ; ) {
        let t2 = await this.tlsRead();
        if (t2 === void 0)
          break;
        {
          let n2 = d3.from(t2);
          this.emit("data", n2);
        }
      }
    }
    rawWrite(t2) {
      if (!this.coalesceWrites) {
        this.ws.send(t2);
        return;
      }
      if (this.writeBuffer === void 0)
        this.writeBuffer = t2, setTimeout(
          () => {
            this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
          },
          0
        );
      else {
        let n2 = new Uint8Array(this.writeBuffer.length + t2.length);
        n2.set(this.writeBuffer), n2.set(t2, this.writeBuffer.length), this.writeBuffer = n2;
      }
    }
    write(t2, n2 = "utf8", i2 = (s2) => {
    }) {
      return t2.length === 0 ? (i2(), true) : (typeof t2 == "string" && (t2 = d3.from(t2, n2)), this.tlsState === 0 ? (this.rawWrite(t2), i2()) : this.tlsState === 1 ? this.once("secureConnection", () => {
        this.write(
          t2,
          n2,
          i2
        );
      }) : (this.tlsWrite(t2), i2()), true);
    }
    end(t2 = d3.alloc(0), n2 = "utf8", i2 = () => {
    }) {
      return this.write(t2, n2, () => {
        this.ws.close(), i2();
      }), this;
    }
    destroy() {
      return this.destroyed = true, this.end();
    }
  };
  a(x, "Socket"), T(x, "defaults", {
    poolQueryViaFetch: false,
    fetchEndpoint: (t2) => "https://" + t2 + "/sql",
    fetchConnectionCache: false,
    fetchFunction: void 0,
    webSocketConstructor: void 0,
    wsProxy: (t2) => t2 + "/v2",
    useSecureWebSocket: true,
    forceDisablePgSSL: true,
    coalesceWrites: true,
    pipelineConnect: "password",
    subtls: void 0,
    rootCerts: "",
    pipelineTLS: false,
    disableSNI: false
  }), T(x, "opts", {});
  _e = x;
});
var zr = I((C) => {
  "use strict";
  p3();
  Object.defineProperty(C, "__esModule", { value: true });
  C.NoticeMessage = C.DataRowMessage = C.CommandCompleteMessage = C.ReadyForQueryMessage = C.NotificationResponseMessage = C.BackendKeyDataMessage = C.AuthenticationMD5Password = C.ParameterStatusMessage = C.ParameterDescriptionMessage = C.RowDescriptionMessage = C.Field = C.CopyResponse = C.CopyDataMessage = C.DatabaseError = C.copyDone = C.emptyQuery = C.replicationStart = C.portalSuspended = C.noData = C.closeComplete = C.bindComplete = C.parseComplete = void 0;
  C.parseComplete = { name: "parseComplete", length: 5 };
  C.bindComplete = { name: "bindComplete", length: 5 };
  C.closeComplete = { name: "closeComplete", length: 5 };
  C.noData = { name: "noData", length: 5 };
  C.portalSuspended = { name: "portalSuspended", length: 5 };
  C.replicationStart = { name: "replicationStart", length: 4 };
  C.emptyQuery = { name: "emptyQuery", length: 4 };
  C.copyDone = { name: "copyDone", length: 4 };
  var Dr = class Dr extends Error {
    constructor(e3, t2, n2) {
      super(
        e3
      ), this.length = t2, this.name = n2;
    }
  };
  a(Dr, "DatabaseError");
  var xr = Dr;
  C.DatabaseError = xr;
  var Or = class Or {
    constructor(e3, t2) {
      this.length = e3, this.chunk = t2, this.name = "copyData";
    }
  };
  a(Or, "CopyDataMessage");
  var Er = Or;
  C.CopyDataMessage = Er;
  var kr = class kr {
    constructor(e3, t2, n2, i2) {
      this.length = e3, this.name = t2, this.binary = n2, this.columnTypes = new Array(i2);
    }
  };
  a(kr, "CopyResponse");
  var vr = kr;
  C.CopyResponse = vr;
  var Ur = class Ur {
    constructor(e3, t2, n2, i2, s2, o2, u2) {
      this.name = e3, this.tableID = t2, this.columnID = n2, this.dataTypeID = i2, this.dataTypeSize = s2, this.dataTypeModifier = o2, this.format = u2;
    }
  };
  a(Ur, "Field");
  var _r = Ur;
  C.Field = _r;
  var qr = class qr {
    constructor(e3, t2) {
      this.length = e3, this.fieldCount = t2, this.name = "rowDescription", this.fields = new Array(
        this.fieldCount
      );
    }
  };
  a(qr, "RowDescriptionMessage");
  var Ar = qr;
  C.RowDescriptionMessage = Ar;
  var Nr = class Nr {
    constructor(e3, t2) {
      this.length = e3, this.parameterCount = t2, this.name = "parameterDescription", this.dataTypeIDs = new Array(this.parameterCount);
    }
  };
  a(Nr, "ParameterDescriptionMessage");
  var Cr = Nr;
  C.ParameterDescriptionMessage = Cr;
  var Qr = class Qr {
    constructor(e3, t2, n2) {
      this.length = e3, this.parameterName = t2, this.parameterValue = n2, this.name = "parameterStatus";
    }
  };
  a(Qr, "ParameterStatusMessage");
  var Ir = Qr;
  C.ParameterStatusMessage = Ir;
  var Wr = class Wr {
    constructor(e3, t2) {
      this.length = e3, this.salt = t2, this.name = "authenticationMD5Password";
    }
  };
  a(Wr, "AuthenticationMD5Password");
  var Tr = Wr;
  C.AuthenticationMD5Password = Tr;
  var jr = class jr {
    constructor(e3, t2, n2) {
      this.length = e3, this.processID = t2, this.secretKey = n2, this.name = "backendKeyData";
    }
  };
  a(
    jr,
    "BackendKeyDataMessage"
  );
  var Pr = jr;
  C.BackendKeyDataMessage = Pr;
  var Hr = class Hr {
    constructor(e3, t2, n2, i2) {
      this.length = e3, this.processId = t2, this.channel = n2, this.payload = i2, this.name = "notification";
    }
  };
  a(Hr, "NotificationResponseMessage");
  var Br = Hr;
  C.NotificationResponseMessage = Br;
  var Gr = class Gr {
    constructor(e3, t2) {
      this.length = e3, this.status = t2, this.name = "readyForQuery";
    }
  };
  a(Gr, "ReadyForQueryMessage");
  var Lr = Gr;
  C.ReadyForQueryMessage = Lr;
  var $r = class $r {
    constructor(e3, t2) {
      this.length = e3, this.text = t2, this.name = "commandComplete";
    }
  };
  a($r, "CommandCompleteMessage");
  var Rr = $r;
  C.CommandCompleteMessage = Rr;
  var Kr = class Kr {
    constructor(e3, t2) {
      this.length = e3, this.fields = t2, this.name = "dataRow", this.fieldCount = t2.length;
    }
  };
  a(Kr, "DataRowMessage");
  var Fr = Kr;
  C.DataRowMessage = Fr;
  var Vr = class Vr {
    constructor(e3, t2) {
      this.length = e3, this.message = t2, this.name = "notice";
    }
  };
  a(Vr, "NoticeMessage");
  var Mr = Vr;
  C.NoticeMessage = Mr;
});
var ys = I((bt) => {
  "use strict";
  p3();
  Object.defineProperty(bt, "__esModule", { value: true });
  bt.Writer = void 0;
  var Zr = class Zr {
    constructor(e3 = 256) {
      this.size = e3, this.offset = 5, this.headerPosition = 0, this.buffer = d3.allocUnsafe(e3);
    }
    ensure(e3) {
      var t2 = this.buffer.length - this.offset;
      if (t2 < e3) {
        var n2 = this.buffer, i2 = n2.length + (n2.length >> 1) + e3;
        this.buffer = d3.allocUnsafe(
          i2
        ), n2.copy(this.buffer);
      }
    }
    addInt32(e3) {
      return this.ensure(4), this.buffer[this.offset++] = e3 >>> 24 & 255, this.buffer[this.offset++] = e3 >>> 16 & 255, this.buffer[this.offset++] = e3 >>> 8 & 255, this.buffer[this.offset++] = e3 >>> 0 & 255, this;
    }
    addInt16(e3) {
      return this.ensure(2), this.buffer[this.offset++] = e3 >>> 8 & 255, this.buffer[this.offset++] = e3 >>> 0 & 255, this;
    }
    addCString(e3) {
      if (!e3)
        this.ensure(1);
      else {
        var t2 = d3.byteLength(e3);
        this.ensure(t2 + 1), this.buffer.write(
          e3,
          this.offset,
          "utf-8"
        ), this.offset += t2;
      }
      return this.buffer[this.offset++] = 0, this;
    }
    addString(e3 = "") {
      var t2 = d3.byteLength(e3);
      return this.ensure(t2), this.buffer.write(e3, this.offset), this.offset += t2, this;
    }
    add(e3) {
      return this.ensure(e3.length), e3.copy(this.buffer, this.offset), this.offset += e3.length, this;
    }
    join(e3) {
      if (e3) {
        this.buffer[this.headerPosition] = e3;
        let t2 = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(t2, this.headerPosition + 1);
      }
      return this.buffer.slice(e3 ? 0 : 5, this.offset);
    }
    flush(e3) {
      var t2 = this.join(e3);
      return this.offset = 5, this.headerPosition = 0, this.buffer = d3.allocUnsafe(this.size), t2;
    }
  };
  a(Zr, "Writer");
  var Yr = Zr;
  bt.Writer = Yr;
});
var gs = I((xt) => {
  "use strict";
  p3();
  Object.defineProperty(xt, "__esModule", { value: true });
  xt.serialize = void 0;
  var Jr = ys(), F = new Jr.Writer(), Ru = a((r2) => {
    F.addInt16(3).addInt16(
      0
    );
    for (let n2 of Object.keys(r2))
      F.addCString(n2).addCString(r2[n2]);
    F.addCString("client_encoding").addCString("UTF8");
    var e3 = F.addCString("").flush(), t2 = e3.length + 4;
    return new Jr.Writer().addInt32(t2).add(e3).flush();
  }, "startup"), Fu = a(() => {
    let r2 = d3.allocUnsafe(8);
    return r2.writeInt32BE(8, 0), r2.writeInt32BE(80877103, 4), r2;
  }, "requestSsl"), Mu = a((r2) => F.addCString(r2).flush(112), "password"), Du = a(function(r2, e3) {
    return F.addCString(r2).addInt32(
      d3.byteLength(e3)
    ).addString(e3), F.flush(112);
  }, "sendSASLInitialResponseMessage"), Ou = a(
    function(r2) {
      return F.addString(r2).flush(112);
    },
    "sendSCRAMClientFinalMessage"
  ), ku = a(
    (r2) => F.addCString(r2).flush(81),
    "query"
  ), ms = [], Uu = a((r2) => {
    let e3 = r2.name || "";
    e3.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e3, e3.length), console.error("This can cause conflicts and silent errors executing queries"));
    let t2 = r2.types || ms;
    for (var n2 = t2.length, i2 = F.addCString(e3).addCString(r2.text).addInt16(n2), s2 = 0; s2 < n2; s2++)
      i2.addInt32(t2[s2]);
    return F.flush(80);
  }, "parse"), Ue = new Jr.Writer(), qu = a(function(r2, e3) {
    for (let t2 = 0; t2 < r2.length; t2++) {
      let n2 = e3 ? e3(r2[t2], t2) : r2[t2];
      n2 == null ? (F.addInt16(0), Ue.addInt32(-1)) : n2 instanceof d3 ? (F.addInt16(1), Ue.addInt32(n2.length), Ue.add(n2)) : (F.addInt16(0), Ue.addInt32(d3.byteLength(
        n2
      )), Ue.addString(n2));
    }
  }, "writeValues"), Nu = a((r2 = {}) => {
    let e3 = r2.portal || "", t2 = r2.statement || "", n2 = r2.binary || false, i2 = r2.values || ms, s2 = i2.length;
    return F.addCString(e3).addCString(t2), F.addInt16(s2), qu(i2, r2.valueMapper), F.addInt16(s2), F.add(Ue.flush()), F.addInt16(n2 ? 1 : 0), F.flush(66);
  }, "bind"), Qu = d3.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]), Wu = a((r2) => {
    if (!r2 || !r2.portal && !r2.rows)
      return Qu;
    let e3 = r2.portal || "", t2 = r2.rows || 0, n2 = d3.byteLength(e3), i2 = 4 + n2 + 1 + 4, s2 = d3.allocUnsafe(1 + i2);
    return s2[0] = 69, s2.writeInt32BE(i2, 1), s2.write(e3, 5, "utf-8"), s2[n2 + 5] = 0, s2.writeUInt32BE(t2, s2.length - 4), s2;
  }, "execute"), ju = a((r2, e3) => {
    let t2 = d3.allocUnsafe(16);
    return t2.writeInt32BE(16, 0), t2.writeInt16BE(1234, 4), t2.writeInt16BE(5678, 6), t2.writeInt32BE(
      r2,
      8
    ), t2.writeInt32BE(e3, 12), t2;
  }, "cancel"), Xr = a(
    (r2, e3) => {
      let n2 = 4 + d3.byteLength(e3) + 1, i2 = d3.allocUnsafe(1 + n2);
      return i2[0] = r2, i2.writeInt32BE(n2, 1), i2.write(e3, 5, "utf-8"), i2[n2] = 0, i2;
    },
    "cstringMessage"
  ), Hu = F.addCString("P").flush(68), Gu = F.addCString("S").flush(68), $u = a((r2) => r2.name ? Xr(68, `${r2.type}${r2.name || ""}`) : r2.type === "P" ? Hu : Gu, "describe"), Ku = a(
    (r2) => {
      let e3 = `${r2.type}${r2.name || ""}`;
      return Xr(67, e3);
    },
    "close"
  ), Vu = a((r2) => F.add(r2).flush(
    100
  ), "copyData"), zu = a((r2) => Xr(102, r2), "copyFail"), St = a((r2) => d3.from([r2, 0, 0, 0, 4]), "codeOnlyBuffer"), Yu = St(72), Zu = St(83), Ju = St(88), Xu = St(99), ec = {
    startup: Ru,
    password: Mu,
    requestSsl: Fu,
    sendSASLInitialResponseMessage: Du,
    sendSCRAMClientFinalMessage: Ou,
    query: ku,
    parse: Uu,
    bind: Nu,
    execute: Wu,
    describe: $u,
    close: Ku,
    flush: () => Yu,
    sync: () => Zu,
    end: () => Ju,
    copyData: Vu,
    copyDone: () => Xu,
    copyFail: zu,
    cancel: ju
  };
  xt.serialize = ec;
});
var ws = I((Et) => {
  "use strict";
  p3();
  Object.defineProperty(Et, "__esModule", { value: true });
  Et.BufferReader = void 0;
  var tc = d3.allocUnsafe(0), tn = class tn {
    constructor(e3 = 0) {
      this.offset = e3, this.buffer = tc, this.encoding = "utf-8";
    }
    setBuffer(e3, t2) {
      this.offset = e3, this.buffer = t2;
    }
    int16() {
      let e3 = this.buffer.readInt16BE(this.offset);
      return this.offset += 2, e3;
    }
    byte() {
      let e3 = this.buffer[this.offset];
      return this.offset++, e3;
    }
    int32() {
      let e3 = this.buffer.readInt32BE(this.offset);
      return this.offset += 4, e3;
    }
    string(e3) {
      let t2 = this.buffer.toString(this.encoding, this.offset, this.offset + e3);
      return this.offset += e3, t2;
    }
    cstring() {
      let e3 = this.offset, t2 = e3;
      for (; this.buffer[t2++] !== 0; )
        ;
      return this.offset = t2, this.buffer.toString(this.encoding, e3, t2 - 1);
    }
    bytes(e3) {
      let t2 = this.buffer.slice(this.offset, this.offset + e3);
      return this.offset += e3, t2;
    }
  };
  a(tn, "BufferReader");
  var en = tn;
  Et.BufferReader = en;
});
var bs = {};
X2(bs, { default: () => rc });
var rc;
var Ss = K2(() => {
  "use strict";
  p3();
  rc = {};
});
var vs = I((qe) => {
  "use strict";
  p3();
  var nc = qe && qe.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(qe, "__esModule", { value: true });
  qe.Parser = void 0;
  var M2 = zr(), ic = ws(), sc = nc((Ss(), k(bs))), rn = 1, oc = 4, xs = rn + oc, Es = d3.allocUnsafe(
    0
  ), sn = class sn {
    constructor(e3) {
      if (this.buffer = Es, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new ic.BufferReader(), e3?.mode === "binary")
        throw new Error("Binary mode not supported yet");
      this.mode = e3?.mode || "text";
    }
    parse(e3, t2) {
      this.mergeBuffer(e3);
      let n2 = this.bufferOffset + this.bufferLength, i2 = this.bufferOffset;
      for (; i2 + xs <= n2; ) {
        let s2 = this.buffer[i2], o2 = this.buffer.readUInt32BE(i2 + rn), u2 = rn + o2;
        if (u2 + i2 <= n2) {
          let c3 = this.handlePacket(
            i2 + xs,
            s2,
            o2,
            this.buffer
          );
          t2(c3), i2 += u2;
        } else
          break;
      }
      i2 === n2 ? (this.buffer = Es, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n2 - i2, this.bufferOffset = i2);
    }
    mergeBuffer(e3) {
      if (this.bufferLength > 0) {
        let t2 = this.bufferLength + e3.byteLength;
        if (t2 + this.bufferOffset > this.buffer.byteLength) {
          let i2;
          if (t2 <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength)
            i2 = this.buffer;
          else {
            let s2 = this.buffer.byteLength * 2;
            for (; t2 >= s2; )
              s2 *= 2;
            i2 = d3.allocUnsafe(s2);
          }
          this.buffer.copy(i2, 0, this.bufferOffset, this.bufferOffset + this.bufferLength), this.buffer = i2, this.bufferOffset = 0;
        }
        e3.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t2;
      } else
        this.buffer = e3, this.bufferOffset = 0, this.bufferLength = e3.byteLength;
    }
    handlePacket(e3, t2, n2, i2) {
      switch (t2) {
        case 50:
          return M2.bindComplete;
        case 49:
          return M2.parseComplete;
        case 51:
          return M2.closeComplete;
        case 110:
          return M2.noData;
        case 115:
          return M2.portalSuspended;
        case 99:
          return M2.copyDone;
        case 87:
          return M2.replicationStart;
        case 73:
          return M2.emptyQuery;
        case 68:
          return this.parseDataRowMessage(e3, n2, i2);
        case 67:
          return this.parseCommandCompleteMessage(
            e3,
            n2,
            i2
          );
        case 90:
          return this.parseReadyForQueryMessage(e3, n2, i2);
        case 65:
          return this.parseNotificationMessage(e3, n2, i2);
        case 82:
          return this.parseAuthenticationResponse(
            e3,
            n2,
            i2
          );
        case 83:
          return this.parseParameterStatusMessage(e3, n2, i2);
        case 75:
          return this.parseBackendKeyData(e3, n2, i2);
        case 69:
          return this.parseErrorMessage(e3, n2, i2, "error");
        case 78:
          return this.parseErrorMessage(e3, n2, i2, "notice");
        case 84:
          return this.parseRowDescriptionMessage(
            e3,
            n2,
            i2
          );
        case 116:
          return this.parseParameterDescriptionMessage(e3, n2, i2);
        case 71:
          return this.parseCopyInMessage(e3, n2, i2);
        case 72:
          return this.parseCopyOutMessage(e3, n2, i2);
        case 100:
          return this.parseCopyData(e3, n2, i2);
        default:
          sc.default.fail(`unknown message code: ${t2.toString(16)}`);
      }
    }
    parseReadyForQueryMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.string(1);
      return new M2.ReadyForQueryMessage(t2, i2);
    }
    parseCommandCompleteMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.cstring();
      return new M2.CommandCompleteMessage(
        t2,
        i2
      );
    }
    parseCopyData(e3, t2, n2) {
      let i2 = n2.slice(e3, e3 + (t2 - 4));
      return new M2.CopyDataMessage(
        t2,
        i2
      );
    }
    parseCopyInMessage(e3, t2, n2) {
      return this.parseCopyMessage(e3, t2, n2, "copyInResponse");
    }
    parseCopyOutMessage(e3, t2, n2) {
      return this.parseCopyMessage(e3, t2, n2, "copyOutResponse");
    }
    parseCopyMessage(e3, t2, n2, i2) {
      this.reader.setBuffer(e3, n2);
      let s2 = this.reader.byte() !== 0, o2 = this.reader.int16(), u2 = new M2.CopyResponse(t2, i2, s2, o2);
      for (let c3 = 0; c3 < o2; c3++)
        u2.columnTypes[c3] = this.reader.int16();
      return u2;
    }
    parseNotificationMessage(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int32(), s2 = this.reader.cstring(), o2 = this.reader.cstring();
      return new M2.NotificationResponseMessage(t2, i2, s2, o2);
    }
    parseRowDescriptionMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int16(), s2 = new M2.RowDescriptionMessage(t2, i2);
      for (let o2 = 0; o2 < i2; o2++)
        s2.fields[o2] = this.parseField();
      return s2;
    }
    parseField() {
      let e3 = this.reader.cstring(), t2 = this.reader.int32(), n2 = this.reader.int16(), i2 = this.reader.int32(), s2 = this.reader.int16(), o2 = this.reader.int32(), u2 = this.reader.int16() === 0 ? "text" : "binary";
      return new M2.Field(e3, t2, n2, i2, s2, o2, u2);
    }
    parseParameterDescriptionMessage(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int16(), s2 = new M2.ParameterDescriptionMessage(t2, i2);
      for (let o2 = 0; o2 < i2; o2++)
        s2.dataTypeIDs[o2] = this.reader.int32();
      return s2;
    }
    parseDataRowMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int16(), s2 = new Array(i2);
      for (let o2 = 0; o2 < i2; o2++) {
        let u2 = this.reader.int32();
        s2[o2] = u2 === -1 ? null : this.reader.string(u2);
      }
      return new M2.DataRowMessage(
        t2,
        s2
      );
    }
    parseParameterStatusMessage(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.cstring(), s2 = this.reader.cstring();
      return new M2.ParameterStatusMessage(t2, i2, s2);
    }
    parseBackendKeyData(e3, t2, n2) {
      this.reader.setBuffer(e3, n2);
      let i2 = this.reader.int32(), s2 = this.reader.int32();
      return new M2.BackendKeyDataMessage(t2, i2, s2);
    }
    parseAuthenticationResponse(e3, t2, n2) {
      this.reader.setBuffer(
        e3,
        n2
      );
      let i2 = this.reader.int32(), s2 = { name: "authenticationOk", length: t2 };
      switch (i2) {
        case 0:
          break;
        case 3:
          s2.length === 8 && (s2.name = "authenticationCleartextPassword");
          break;
        case 5:
          if (s2.length === 12) {
            s2.name = "authenticationMD5Password";
            let u2 = this.reader.bytes(4);
            return new M2.AuthenticationMD5Password(t2, u2);
          }
          break;
        case 10:
          s2.name = "authenticationSASL", s2.mechanisms = [];
          let o2;
          do
            o2 = this.reader.cstring(), o2 && s2.mechanisms.push(o2);
          while (o2);
          break;
        case 11:
          s2.name = "authenticationSASLContinue", s2.data = this.reader.string(t2 - 8);
          break;
        case 12:
          s2.name = "authenticationSASLFinal", s2.data = this.reader.string(t2 - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + i2);
      }
      return s2;
    }
    parseErrorMessage(e3, t2, n2, i2) {
      this.reader.setBuffer(e3, n2);
      let s2 = {}, o2 = this.reader.string(1);
      for (; o2 !== "\0"; )
        s2[o2] = this.reader.cstring(), o2 = this.reader.string(1);
      let u2 = s2.M, c3 = i2 === "notice" ? new M2.NoticeMessage(
        t2,
        u2
      ) : new M2.DatabaseError(u2, t2, i2);
      return c3.severity = s2.S, c3.code = s2.C, c3.detail = s2.D, c3.hint = s2.H, c3.position = s2.P, c3.internalPosition = s2.p, c3.internalQuery = s2.q, c3.where = s2.W, c3.schema = s2.s, c3.table = s2.t, c3.column = s2.c, c3.dataType = s2.d, c3.constraint = s2.n, c3.file = s2.F, c3.line = s2.L, c3.routine = s2.R, c3;
    }
  };
  a(sn, "Parser");
  var nn = sn;
  qe.Parser = nn;
});
var on = I((be) => {
  "use strict";
  p3();
  Object.defineProperty(be, "__esModule", { value: true });
  be.DatabaseError = be.serialize = be.parse = void 0;
  var ac = zr();
  Object.defineProperty(
    be,
    "DatabaseError",
    { enumerable: true, get: function() {
      return ac.DatabaseError;
    } }
  );
  var uc = gs();
  Object.defineProperty(be, "serialize", { enumerable: true, get: function() {
    return uc.serialize;
  } });
  var cc = vs();
  function hc(r2, e3) {
    let t2 = new cc.Parser();
    return r2.on("data", (n2) => t2.parse(
      n2,
      e3
    )), new Promise((n2) => r2.on("end", () => n2()));
  }
  a(hc, "parse");
  be.parse = hc;
});
var _s = {};
X2(_s, { connect: () => lc });
function lc({ socket: r2, servername: e3 }) {
  return r2.startTls(
    e3
  ), r2;
}
var As = K2(() => {
  "use strict";
  p3();
  a(lc, "connect");
});
var cn = I((ef, Ts) => {
  "use strict";
  p3();
  var Cs = (wt(), k(ds)), fc = ge().EventEmitter, {
    parse: pc,
    serialize: q2
  } = on(), Is = q2.flush(), dc = q2.sync(), yc = q2.end(), un = class un extends fc {
    constructor(e3) {
      super(), e3 = e3 || {}, this.stream = e3.stream || new Cs.Socket(), this._keepAlive = e3.keepAlive, this._keepAliveInitialDelayMillis = e3.keepAliveInitialDelayMillis, this.lastBuffer = false, this.parsedStatements = {}, this.ssl = e3.ssl || false, this._ending = false, this._emitMessage = false;
      var t2 = this;
      this.on("newListener", function(n2) {
        n2 === "message" && (t2._emitMessage = true);
      });
    }
    connect(e3, t2) {
      var n2 = this;
      this._connecting = true, this.stream.setNoDelay(true), this.stream.connect(
        e3,
        t2
      ), this.stream.once("connect", function() {
        n2._keepAlive && n2.stream.setKeepAlive(
          true,
          n2._keepAliveInitialDelayMillis
        ), n2.emit("connect");
      });
      let i2 = a(function(s2) {
        n2._ending && (s2.code === "ECONNRESET" || s2.code === "EPIPE") || n2.emit("error", s2);
      }, "reportStreamError");
      if (this.stream.on("error", i2), this.stream.on("close", function() {
        n2.emit("end");
      }), !this.ssl)
        return this.attachListeners(this.stream);
      this.stream.once("data", function(s2) {
        var o2 = s2.toString("utf8");
        switch (o2) {
          case "S":
            break;
          case "N":
            return n2.stream.end(), n2.emit("error", new Error("The server does not support SSL connections"));
          default:
            return n2.stream.end(), n2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        var u2 = (As(), k(_s));
        let c3 = { socket: n2.stream };
        n2.ssl !== true && (Object.assign(
          c3,
          n2.ssl
        ), "key" in n2.ssl && (c3.key = n2.ssl.key)), Cs.isIP(t2) === 0 && (c3.servername = t2);
        try {
          n2.stream = u2.connect(c3);
        } catch (h2) {
          return n2.emit("error", h2);
        }
        n2.attachListeners(n2.stream), n2.stream.on("error", i2), n2.emit("sslconnect");
      });
    }
    attachListeners(e3) {
      e3.on("end", () => {
        this.emit("end");
      }), pc(e3, (t2) => {
        var n2 = t2.name === "error" ? "errorMessage" : t2.name;
        this._emitMessage && this.emit("message", t2), this.emit(n2, t2);
      });
    }
    requestSsl() {
      this.stream.write(q2.requestSsl());
    }
    startup(e3) {
      this.stream.write(q2.startup(e3));
    }
    cancel(e3, t2) {
      this._send(q2.cancel(e3, t2));
    }
    password(e3) {
      this._send(q2.password(e3));
    }
    sendSASLInitialResponseMessage(e3, t2) {
      this._send(q2.sendSASLInitialResponseMessage(
        e3,
        t2
      ));
    }
    sendSCRAMClientFinalMessage(e3) {
      this._send(q2.sendSCRAMClientFinalMessage(e3));
    }
    _send(e3) {
      return this.stream.writable ? this.stream.write(e3) : false;
    }
    query(e3) {
      this._send(q2.query(
        e3
      ));
    }
    parse(e3) {
      this._send(q2.parse(e3));
    }
    bind(e3) {
      this._send(q2.bind(e3));
    }
    execute(e3) {
      this._send(q2.execute(e3));
    }
    flush() {
      this.stream.writable && this.stream.write(Is);
    }
    sync() {
      this._ending = true, this._send(Is), this._send(dc);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      if (this._ending = true, !this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(yc, () => {
        this.stream.end();
      });
    }
    close(e3) {
      this._send(q2.close(e3));
    }
    describe(e3) {
      this._send(q2.describe(e3));
    }
    sendCopyFromChunk(e3) {
      this._send(q2.copyData(e3));
    }
    endCopyFrom() {
      this._send(q2.copyDone());
    }
    sendCopyFail(e3) {
      this._send(q2.copyFail(e3));
    }
  };
  a(un, "Connection");
  var an = un;
  Ts.exports = an;
});
var Ls = I((sf, Bs) => {
  "use strict";
  p3();
  var mc = ge().EventEmitter, nf = (Ge(), k(He)), gc = tt(), hn = qi(), wc = Yi(), bc = hr(), Sc = gt(), Ps = fs(), xc = et(), Ec = cn(), ln = class ln extends mc {
    constructor(e3) {
      super(), this.connectionParameters = new Sc(e3), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(this, "password", { configurable: true, enumerable: false, writable: true, value: this.connectionParameters.password }), this.replication = this.connectionParameters.replication;
      var t2 = e3 || {};
      this._Promise = t2.Promise || b2.Promise, this._types = new bc(t2.types), this._ending = false, this._connecting = false, this._connected = false, this._connectionError = false, this._queryable = true, this.connection = t2.connection || new Ec({ stream: t2.stream, ssl: this.connectionParameters.ssl, keepAlive: t2.keepAlive || false, keepAliveInitialDelayMillis: t2.keepAliveInitialDelayMillis || 0, encoding: this.connectionParameters.client_encoding || "utf8" }), this.queryQueue = [], this.binary = t2.binary || xc.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || false, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this._connectionTimeoutMillis = t2.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(e3) {
      let t2 = a(
        (n2) => {
          m2.nextTick(() => {
            n2.handleError(e3, this.connection);
          });
        },
        "enqueueError"
      );
      this.activeQuery && (t2(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t2), this.queryQueue.length = 0;
    }
    _connect(e3) {
      var t2 = this, n2 = this.connection;
      if (this._connectionCallback = e3, this._connecting || this._connected) {
        let i2 = new Error("Client has already been connected. You cannot reuse a client.");
        m2.nextTick(() => {
          e3(i2);
        });
        return;
      }
      this._connecting = true, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(() => {
        n2._ending = true, n2.stream.destroy(new Error("timeout expired"));
      }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n2.connect(this.host + "/.s.PGSQL." + this.port) : n2.connect(this.port, this.host), n2.on("connect", function() {
        t2.ssl ? n2.requestSsl() : n2.startup(t2.getStartupConf());
      }), n2.on("sslconnect", function() {
        n2.startup(t2.getStartupConf());
      }), this._attachListeners(n2), n2.once("end", () => {
        let i2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i2), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i2) : this._handleErrorEvent(i2) : this._connectionError || this._handleErrorEvent(
          i2
        )), m2.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(e3) {
      if (e3) {
        this._connect(e3);
        return;
      }
      return new this._Promise((t2, n2) => {
        this._connect((i2) => {
          i2 ? n2(i2) : t2();
        });
      });
    }
    _attachListeners(e3) {
      e3.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e3.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e3.on("authenticationSASL", this._handleAuthSASL.bind(this)), e3.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e3.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e3.on("backendKeyData", this._handleBackendKeyData.bind(this)), e3.on("error", this._handleErrorEvent.bind(this)), e3.on(
        "errorMessage",
        this._handleErrorMessage.bind(this)
      ), e3.on("readyForQuery", this._handleReadyForQuery.bind(this)), e3.on("notice", this._handleNotice.bind(this)), e3.on("rowDescription", this._handleRowDescription.bind(this)), e3.on("dataRow", this._handleDataRow.bind(this)), e3.on("portalSuspended", this._handlePortalSuspended.bind(this)), e3.on(
        "emptyQuery",
        this._handleEmptyQuery.bind(this)
      ), e3.on("commandComplete", this._handleCommandComplete.bind(this)), e3.on("parseComplete", this._handleParseComplete.bind(this)), e3.on("copyInResponse", this._handleCopyInResponse.bind(this)), e3.on("copyData", this._handleCopyData.bind(this)), e3.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(e3) {
      let t2 = this.connection;
      typeof this.password == "function" ? this._Promise.resolve().then(
        () => this.password()
      ).then((n2) => {
        if (n2 !== void 0) {
          if (typeof n2 != "string") {
            t2.emit("error", new TypeError("Password must be a string"));
            return;
          }
          this.connectionParameters.password = this.password = n2;
        } else
          this.connectionParameters.password = this.password = null;
        e3();
      }).catch((n2) => {
        t2.emit("error", n2);
      }) : this.password !== null ? e3() : wc(
        this.connectionParameters,
        (n2) => {
          n2 !== void 0 && (this.connectionParameters.password = this.password = n2), e3();
        }
      );
    }
    _handleAuthCleartextPassword(e3) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(e3) {
      this._checkPgPass(() => {
        let t2 = gc.postgresMd5PasswordHash(
          this.user,
          this.password,
          e3.salt
        );
        this.connection.password(t2);
      });
    }
    _handleAuthSASL(e3) {
      this._checkPgPass(() => {
        this.saslSession = hn.startSession(e3.mechanisms), this.connection.sendSASLInitialResponseMessage(
          this.saslSession.mechanism,
          this.saslSession.response
        );
      });
    }
    _handleAuthSASLContinue(e3) {
      hn.continueSession(this.saslSession, this.password, e3.data), this.connection.sendSCRAMClientFinalMessage(
        this.saslSession.response
      );
    }
    _handleAuthSASLFinal(e3) {
      hn.finalizeSession(
        this.saslSession,
        e3.data
      ), this.saslSession = null;
    }
    _handleBackendKeyData(e3) {
      this.processID = e3.processID, this.secretKey = e3.secretKey;
    }
    _handleReadyForQuery(e3) {
      this._connecting && (this._connecting = false, this._connected = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
      let { activeQuery: t2 } = this;
      this.activeQuery = null, this.readyForQuery = true, t2 && t2.handleReadyForQuery(this.connection), this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(e3) {
      if (!this._connectionError) {
        if (this._connectionError = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback)
          return this._connectionCallback(e3);
        this.emit("error", e3);
      }
    }
    _handleErrorEvent(e3) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e3);
      this._queryable = false, this._errorAllQueries(e3), this.emit("error", e3);
    }
    _handleErrorMessage(e3) {
      if (this._connecting)
        return this._handleErrorWhileConnecting(e3);
      let t2 = this.activeQuery;
      if (!t2) {
        this._handleErrorEvent(
          e3
        );
        return;
      }
      this.activeQuery = null, t2.handleError(e3, this.connection);
    }
    _handleRowDescription(e3) {
      this.activeQuery.handleRowDescription(e3);
    }
    _handleDataRow(e3) {
      this.activeQuery.handleDataRow(
        e3
      );
    }
    _handlePortalSuspended(e3) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(e3) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(e3) {
      this.activeQuery.handleCommandComplete(e3, this.connection);
    }
    _handleParseComplete(e3) {
      this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
    }
    _handleCopyInResponse(e3) {
      this.activeQuery.handleCopyInResponse(
        this.connection
      );
    }
    _handleCopyData(e3) {
      this.activeQuery.handleCopyData(e3, this.connection);
    }
    _handleNotification(e3) {
      this.emit("notification", e3);
    }
    _handleNotice(e3) {
      this.emit("notice", e3);
    }
    getStartupConf() {
      var e3 = this.connectionParameters, t2 = { user: e3.user, database: e3.database }, n2 = e3.application_name || e3.fallback_application_name;
      return n2 && (t2.application_name = n2), e3.replication && (t2.replication = "" + e3.replication), e3.statement_timeout && (t2.statement_timeout = String(parseInt(
        e3.statement_timeout,
        10
      ))), e3.lock_timeout && (t2.lock_timeout = String(parseInt(e3.lock_timeout, 10))), e3.idle_in_transaction_session_timeout && (t2.idle_in_transaction_session_timeout = String(parseInt(
        e3.idle_in_transaction_session_timeout,
        10
      ))), e3.options && (t2.options = e3.options), t2;
    }
    cancel(e3, t2) {
      if (e3.activeQuery === t2) {
        var n2 = this.connection;
        this.host && this.host.indexOf("/") === 0 ? n2.connect(this.host + "/.s.PGSQL." + this.port) : n2.connect(this.port, this.host), n2.on("connect", function() {
          n2.cancel(
            e3.processID,
            e3.secretKey
          );
        });
      } else
        e3.queryQueue.indexOf(t2) !== -1 && e3.queryQueue.splice(e3.queryQueue.indexOf(t2), 1);
    }
    setTypeParser(e3, t2, n2) {
      return this._types.setTypeParser(e3, t2, n2);
    }
    getTypeParser(e3, t2) {
      return this._types.getTypeParser(e3, t2);
    }
    escapeIdentifier(e3) {
      return '"' + e3.replace(
        /"/g,
        '""'
      ) + '"';
    }
    escapeLiteral(e3) {
      for (var t2 = false, n2 = "'", i2 = 0; i2 < e3.length; i2++) {
        var s2 = e3[i2];
        s2 === "'" ? n2 += s2 + s2 : s2 === "\\" ? (n2 += s2 + s2, t2 = true) : n2 += s2;
      }
      return n2 += "'", t2 === true && (n2 = " E" + n2), n2;
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true)
        if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
          this.readyForQuery = false, this.hasExecuted = true;
          let e3 = this.activeQuery.submit(this.connection);
          e3 && m2.nextTick(() => {
            this.activeQuery.handleError(e3, this.connection), this.readyForQuery = true, this._pulseQueryQueue();
          });
        } else
          this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
    }
    query(e3, t2, n2) {
      var i2, s2, o2, u2, c3;
      if (e3 == null)
        throw new TypeError("Client was passed a null or undefined query");
      return typeof e3.submit == "function" ? (o2 = e3.query_timeout || this.connectionParameters.query_timeout, s2 = i2 = e3, typeof t2 == "function" && (i2.callback = i2.callback || t2)) : (o2 = this.connectionParameters.query_timeout, i2 = new Ps(
        e3,
        t2,
        n2
      ), i2.callback || (s2 = new this._Promise((h2, l3) => {
        i2.callback = (y2, E) => y2 ? l3(y2) : h2(E);
      }))), o2 && (c3 = i2.callback, u2 = setTimeout(() => {
        var h2 = new Error("Query read timeout");
        m2.nextTick(
          () => {
            i2.handleError(h2, this.connection);
          }
        ), c3(h2), i2.callback = () => {
        };
        var l3 = this.queryQueue.indexOf(i2);
        l3 > -1 && this.queryQueue.splice(l3, 1), this._pulseQueryQueue();
      }, o2), i2.callback = (h2, l3) => {
        clearTimeout(u2), c3(h2, l3);
      }), this.binary && !i2.binary && (i2.binary = true), i2._result && !i2._result._types && (i2._result._types = this._types), this._queryable ? this._ending ? (m2.nextTick(() => {
        i2.handleError(
          new Error("Client was closed and is not queryable"),
          this.connection
        );
      }), s2) : (this.queryQueue.push(i2), this._pulseQueryQueue(), s2) : (m2.nextTick(
        () => {
          i2.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        }
      ), s2);
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(e3) {
      if (this._ending = true, !this.connection._connecting)
        if (e3)
          e3();
        else
          return this._Promise.resolve();
      if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e3)
        this.connection.once("end", e3);
      else
        return new this._Promise((t2) => {
          this.connection.once("end", t2);
        });
    }
  };
  a(ln, "Client");
  var vt = ln;
  vt.Query = Ps;
  Bs.exports = vt;
});
var Ds = I((uf, Ms) => {
  "use strict";
  p3();
  var vc = ge().EventEmitter, Rs = a(function() {
  }, "NOOP"), Fs = a(
    (r2, e3) => {
      let t2 = r2.findIndex(e3);
      return t2 === -1 ? void 0 : r2.splice(t2, 1)[0];
    },
    "removeWhere"
  ), dn = class dn {
    constructor(e3, t2, n2) {
      this.client = e3, this.idleListener = t2, this.timeoutId = n2;
    }
  };
  a(dn, "IdleItem");
  var fn = dn, yn = class yn {
    constructor(e3) {
      this.callback = e3;
    }
  };
  a(yn, "PendingItem");
  var Ne = yn;
  function _c2() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  a(_c2, "throwOnDoubleRelease");
  function _t(r2, e3) {
    if (e3)
      return { callback: e3, result: void 0 };
    let t2, n2, i2 = a(function(o2, u2) {
      o2 ? t2(o2) : n2(u2);
    }, "cb"), s2 = new r2(function(o2, u2) {
      n2 = o2, t2 = u2;
    }).catch((o2) => {
      throw Error.captureStackTrace(
        o2
      ), o2;
    });
    return { callback: i2, result: s2 };
  }
  a(_t, "promisify");
  function Ac(r2, e3) {
    return a(
      function t2(n2) {
        n2.client = e3, e3.removeListener("error", t2), e3.on("error", () => {
          r2.log("additional client error after disconnection due to error", n2);
        }), r2._remove(e3), r2.emit("error", n2, e3);
      },
      "idleListener"
    );
  }
  a(Ac, "makeIdleListener");
  var mn = class mn extends vc {
    constructor(e3, t2) {
      super(), this.options = Object.assign({}, e3), e3 != null && "password" in e3 && Object.defineProperty(
        this.options,
        "password",
        { configurable: true, enumerable: false, writable: true, value: e3.password }
      ), e3 != null && e3.ssl && e3.ssl.key && Object.defineProperty(this.options.ssl, "key", { enumerable: false }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || false, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {
      }, this.Client = this.options.Client || t2 || At().Client, this.Promise = this.options.Promise || b2.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = /* @__PURE__ */ new WeakSet(), this._pendingQueue = [], this._endCallback = void 0, this.ending = false, this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      if (this.log("pulse queue"), this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log(
          "pulse queue on ending"
        ), this._idle.length && this._idle.slice().map((t2) => {
          this._remove(
            t2.client
          );
        }), this._clients.length || (this.ended = true, this._endCallback());
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull())
        return;
      let e3 = this._pendingQueue.shift();
      if (this._idle.length) {
        let t2 = this._idle.pop();
        clearTimeout(t2.timeoutId);
        let n2 = t2.client;
        n2.ref && n2.ref();
        let i2 = t2.idleListener;
        return this._acquireClient(n2, e3, i2, false);
      }
      if (!this._isFull())
        return this.newClient(e3);
      throw new Error("unexpected condition");
    }
    _remove(e3) {
      let t2 = Fs(this._idle, (n2) => n2.client === e3);
      t2 !== void 0 && clearTimeout(t2.timeoutId), this._clients = this._clients.filter((n2) => n2 !== e3), e3.end(), this.emit("remove", e3);
    }
    connect(e3) {
      if (this.ending) {
        let i2 = new Error("Cannot use a pool after calling end on the pool");
        return e3 ? e3(i2) : this.Promise.reject(
          i2
        );
      }
      let t2 = _t(this.Promise, e3), n2 = t2.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length && m2.nextTick(() => this._pulseQueue()), !this.options.connectionTimeoutMillis)
          return this._pendingQueue.push(new Ne(t2.callback)), n2;
        let i2 = a((u2, c3, h2) => {
          clearTimeout(
            o2
          ), t2.callback(u2, c3, h2);
        }, "queueCallback"), s2 = new Ne(i2), o2 = setTimeout(() => {
          Fs(
            this._pendingQueue,
            (u2) => u2.callback === i2
          ), s2.timedOut = true, t2.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        return this._pendingQueue.push(s2), n2;
      }
      return this.newClient(new Ne(t2.callback)), n2;
    }
    newClient(e3) {
      let t2 = new this.Client(this.options);
      this._clients.push(t2);
      let n2 = Ac(this, t2);
      this.log("checking client timeout");
      let i2, s2 = false;
      this.options.connectionTimeoutMillis && (i2 = setTimeout(() => {
        this.log("ending client due to timeout"), s2 = true, t2.connection ? t2.connection.stream.destroy() : t2.end();
      }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t2.connect((o2) => {
        if (i2 && clearTimeout(i2), t2.on("error", n2), o2)
          this.log("client failed to connect", o2), this._clients = this._clients.filter((u2) => u2 !== t2), s2 && (o2.message = "Connection terminated due to connection timeout"), this._pulseQueue(), e3.timedOut || e3.callback(
            o2,
            void 0,
            Rs
          );
        else {
          if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
            let u2 = setTimeout(() => {
              this.log("ending client due to expired lifetime"), this._expired.add(t2), this._idle.findIndex((h2) => h2.client === t2) !== -1 && this._acquireClient(
                t2,
                new Ne((h2, l3, y2) => y2()),
                n2,
                false
              );
            }, this.options.maxLifetimeSeconds * 1e3);
            u2.unref(), t2.once(
              "end",
              () => clearTimeout(u2)
            );
          }
          return this._acquireClient(t2, e3, n2, true);
        }
      });
    }
    _acquireClient(e3, t2, n2, i2) {
      i2 && this.emit("connect", e3), this.emit("acquire", e3), e3.release = this._releaseOnce(e3, n2), e3.removeListener("error", n2), t2.timedOut ? i2 && this.options.verify ? this.options.verify(
        e3,
        e3.release
      ) : e3.release() : i2 && this.options.verify ? this.options.verify(e3, (s2) => {
        if (s2)
          return e3.release(s2), t2.callback(s2, void 0, Rs);
        t2.callback(void 0, e3, e3.release);
      }) : t2.callback(
        void 0,
        e3,
        e3.release
      );
    }
    _releaseOnce(e3, t2) {
      let n2 = false;
      return (i2) => {
        n2 && _c2(), n2 = true, this._release(
          e3,
          t2,
          i2
        );
      };
    }
    _release(e3, t2, n2) {
      if (e3.on("error", t2), e3._poolUseCount = (e3._poolUseCount || 0) + 1, this.emit("release", n2, e3), n2 || this.ending || !e3._queryable || e3._ending || e3._poolUseCount >= this.options.maxUses) {
        e3._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e3), this._pulseQueue();
        return;
      }
      if (this._expired.has(e3)) {
        this.log("remove expired client"), this._expired.delete(e3), this._remove(e3), this._pulseQueue();
        return;
      }
      let s2;
      this.options.idleTimeoutMillis && (s2 = setTimeout(() => {
        this.log("remove idle client"), this._remove(e3);
      }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s2.unref()), this.options.allowExitOnIdle && e3.unref(), this._idle.push(new fn(e3, t2, s2)), this._pulseQueue();
    }
    query(e3, t2, n2) {
      if (typeof e3 == "function") {
        let s2 = _t(this.Promise, e3);
        return S2(function() {
          return s2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        }), s2.result;
      }
      typeof t2 == "function" && (n2 = t2, t2 = void 0);
      let i2 = _t(this.Promise, n2);
      return n2 = i2.callback, this.connect((s2, o2) => {
        if (s2)
          return n2(s2);
        let u2 = false, c3 = a((h2) => {
          u2 || (u2 = true, o2.release(h2), n2(h2));
        }, "onError");
        o2.once("error", c3), this.log("dispatching query");
        try {
          o2.query(e3, t2, (h2, l3) => {
            if (this.log("query dispatched"), o2.removeListener("error", c3), !u2)
              return u2 = true, o2.release(h2), h2 ? n2(h2) : n2(
                void 0,
                l3
              );
          });
        } catch (h2) {
          return o2.release(h2), n2(h2);
        }
      }), i2.result;
    }
    end(e3) {
      if (this.log("ending"), this.ending) {
        let n2 = new Error("Called end on pool more than once");
        return e3 ? e3(n2) : this.Promise.reject(n2);
      }
      this.ending = true;
      let t2 = _t(this.Promise, e3);
      return this._endCallback = t2.callback, this._pulseQueue(), t2.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((e3, t2) => e3 + (this._expired.has(t2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  };
  a(mn, "Pool");
  var pn = mn;
  Ms.exports = pn;
});
var Os = {};
X2(Os, { default: () => Cc });
var Cc;
var ks = K2(() => {
  "use strict";
  p3();
  Cc = {};
});
var Us = I((ff, Ic) => {
  Ic.exports = { name: "pg", version: "8.8.0", description: "PostgreSQL client - pure javascript & libpq with the same API", keywords: [
    "database",
    "libpq",
    "pg",
    "postgre",
    "postgres",
    "postgresql",
    "rdbms"
  ], homepage: "https://github.com/brianc/node-postgres", repository: { type: "git", url: "git://github.com/brianc/node-postgres.git", directory: "packages/pg" }, author: "Brian Carlson <brian.m.carlson@gmail.com>", main: "./lib", dependencies: {
    "buffer-writer": "2.0.0",
    "packet-reader": "1.0.0",
    "pg-connection-string": "^2.5.0",
    "pg-pool": "^3.5.2",
    "pg-protocol": "^1.5.0",
    "pg-types": "^2.1.0",
    pgpass: "1.x"
  }, devDependencies: { async: "2.6.4", bluebird: "3.5.2", co: "4.6.0", "pg-copy-streams": "0.3.0" }, peerDependencies: { "pg-native": ">=3.0.1" }, peerDependenciesMeta: {
    "pg-native": { optional: true }
  }, scripts: { test: "make test-all" }, files: ["lib", "SPONSORS.md"], license: "MIT", engines: { node: ">= 8.0.0" }, gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655" };
});
var Qs = I((pf, Ns) => {
  "use strict";
  p3();
  var qs = ge().EventEmitter, Tc = (Ge(), k(He)), gn = tt(), Qe = Ns.exports = function(r2, e3, t2) {
    qs.call(this), r2 = gn.normalizeQueryConfig(r2, e3, t2), this.text = r2.text, this.values = r2.values, this.name = r2.name, this.callback = r2.callback, this.state = "new", this._arrayMode = r2.rowMode === "array", this._emitRowEvents = false, this.on("newListener", function(n2) {
      n2 === "row" && (this._emitRowEvents = true);
    }.bind(this));
  };
  Tc.inherits(
    Qe,
    qs
  );
  var Pc = { sqlState: "code", statementPosition: "position", messagePrimary: "message", context: "where", schemaName: "schema", tableName: "table", columnName: "column", dataTypeName: "dataType", constraintName: "constraint", sourceFile: "file", sourceLine: "line", sourceFunction: "routine" };
  Qe.prototype.handleError = function(r2) {
    var e3 = this.native.pq.resultErrorFields();
    if (e3)
      for (var t2 in e3) {
        var n2 = Pc[t2] || t2;
        r2[n2] = e3[t2];
      }
    this.callback ? this.callback(r2) : this.emit("error", r2), this.state = "error";
  };
  Qe.prototype.then = function(r2, e3) {
    return this._getPromise().then(r2, e3);
  };
  Qe.prototype.catch = function(r2) {
    return this._getPromise().catch(r2);
  };
  Qe.prototype._getPromise = function() {
    return this._promise ? this._promise : (this._promise = new Promise(function(r2, e3) {
      this._once("end", r2), this._once(
        "error",
        e3
      );
    }.bind(this)), this._promise);
  };
  Qe.prototype.submit = function(r2) {
    this.state = "running";
    var e3 = this;
    this.native = r2.native, r2.native.arrayMode = this._arrayMode;
    var t2 = a(
      function(s2, o2, u2) {
        if (r2.native.arrayMode = false, S2(function() {
          e3.emit("_done");
        }), s2)
          return e3.handleError(s2);
        e3._emitRowEvents && (u2.length > 1 ? o2.forEach((c3, h2) => {
          c3.forEach((l3) => {
            e3.emit(
              "row",
              l3,
              u2[h2]
            );
          });
        }) : o2.forEach(function(c3) {
          e3.emit("row", c3, u2);
        })), e3.state = "end", e3.emit(
          "end",
          u2
        ), e3.callback && e3.callback(null, u2);
      },
      "after"
    );
    if (m2.domain && (t2 = m2.domain.bind(
      t2
    )), this.name) {
      this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error(
        "You supplied %s (%s)",
        this.name,
        this.name.length
      ), console.error("This can cause conflicts and silent errors executing queries"));
      var n2 = (this.values || []).map(gn.prepareValue);
      if (r2.namedQueries[this.name]) {
        if (this.text && r2.namedQueries[this.name] !== this.text) {
          let s2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return t2(s2);
        }
        return r2.native.execute(this.name, n2, t2);
      }
      return r2.native.prepare(
        this.name,
        this.text,
        n2.length,
        function(s2) {
          return s2 ? t2(s2) : (r2.namedQueries[e3.name] = e3.text, e3.native.execute(e3.name, n2, t2));
        }
      );
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        let s2 = new Error("Query values must be an array");
        return t2(s2);
      }
      var i2 = this.values.map(gn.prepareValue);
      r2.native.query(this.text, i2, t2);
    } else
      r2.native.query(this.text, t2);
  };
});
var Gs = I((gf, Hs) => {
  "use strict";
  p3();
  var Bc = (ks(), k(Os)), Lc = hr(), mf = Us(), Ws = ge().EventEmitter, Rc = (Ge(), k(He)), Fc = gt(), js = Qs(), Z2 = Hs.exports = function(r2) {
    Ws.call(this), r2 = r2 || {}, this._Promise = r2.Promise || b2.Promise, this._types = new Lc(r2.types), this.native = new Bc({ types: this._types }), this._queryQueue = [], this._ending = false, this._connecting = false, this._connected = false, this._queryable = true;
    var e3 = this.connectionParameters = new Fc(
      r2
    );
    this.user = e3.user, Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: e3.password
    }), this.database = e3.database, this.host = e3.host, this.port = e3.port, this.namedQueries = {};
  };
  Z2.Query = js;
  Rc.inherits(Z2, Ws);
  Z2.prototype._errorAllQueries = function(r2) {
    let e3 = a(
      (t2) => {
        m2.nextTick(() => {
          t2.native = this.native, t2.handleError(r2);
        });
      },
      "enqueueError"
    );
    this._hasActiveQuery() && (e3(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e3), this._queryQueue.length = 0;
  };
  Z2.prototype._connect = function(r2) {
    var e3 = this;
    if (this._connecting) {
      m2.nextTick(() => r2(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true, this.connectionParameters.getLibpqConnectionString(function(t2, n2) {
      if (t2)
        return r2(
          t2
        );
      e3.native.connect(n2, function(i2) {
        if (i2)
          return e3.native.end(), r2(i2);
        e3._connected = true, e3.native.on("error", function(s2) {
          e3._queryable = false, e3._errorAllQueries(s2), e3.emit("error", s2);
        }), e3.native.on("notification", function(s2) {
          e3.emit("notification", { channel: s2.relname, payload: s2.extra });
        }), e3.emit("connect"), e3._pulseQueryQueue(true), r2();
      });
    });
  };
  Z2.prototype.connect = function(r2) {
    if (r2) {
      this._connect(r2);
      return;
    }
    return new this._Promise(
      (e3, t2) => {
        this._connect((n2) => {
          n2 ? t2(n2) : e3();
        });
      }
    );
  };
  Z2.prototype.query = function(r2, e3, t2) {
    var n2, i2, s2, o2, u2;
    if (r2 == null)
      throw new TypeError("Client was passed a null or undefined query");
    if (typeof r2.submit == "function")
      s2 = r2.query_timeout || this.connectionParameters.query_timeout, i2 = n2 = r2, typeof e3 == "function" && (r2.callback = e3);
    else if (s2 = this.connectionParameters.query_timeout, n2 = new js(r2, e3, t2), !n2.callback) {
      let c3, h2;
      i2 = new this._Promise((l3, y2) => {
        c3 = l3, h2 = y2;
      }), n2.callback = (l3, y2) => l3 ? h2(l3) : c3(y2);
    }
    return s2 && (u2 = n2.callback, o2 = setTimeout(() => {
      var c3 = new Error("Query read timeout");
      m2.nextTick(() => {
        n2.handleError(c3, this.connection);
      }), u2(c3), n2.callback = () => {
      };
      var h2 = this._queryQueue.indexOf(n2);
      h2 > -1 && this._queryQueue.splice(h2, 1), this._pulseQueryQueue();
    }, s2), n2.callback = (c3, h2) => {
      clearTimeout(o2), u2(c3, h2);
    }), this._queryable ? this._ending ? (n2.native = this.native, m2.nextTick(() => {
      n2.handleError(
        new Error("Client was closed and is not queryable")
      );
    }), i2) : (this._queryQueue.push(
      n2
    ), this._pulseQueryQueue(), i2) : (n2.native = this.native, m2.nextTick(() => {
      n2.handleError(
        new Error("Client has encountered a connection error and is not queryable")
      );
    }), i2);
  };
  Z2.prototype.end = function(r2) {
    var e3 = this;
    this._ending = true, this._connected || this.once(
      "connect",
      this.end.bind(this, r2)
    );
    var t2;
    return r2 || (t2 = new this._Promise(function(n2, i2) {
      r2 = a((s2) => s2 ? i2(s2) : n2(), "cb");
    })), this.native.end(function() {
      e3._errorAllQueries(new Error(
        "Connection terminated"
      )), m2.nextTick(() => {
        e3.emit("end"), r2 && r2();
      });
    }), t2;
  };
  Z2.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Z2.prototype._pulseQueryQueue = function(r2) {
    if (this._connected && !this._hasActiveQuery()) {
      var e3 = this._queryQueue.shift();
      if (!e3) {
        r2 || this.emit("drain");
        return;
      }
      this._activeQuery = e3, e3.submit(this);
      var t2 = this;
      e3.once(
        "_done",
        function() {
          t2._pulseQueryQueue();
        }
      );
    }
  };
  Z2.prototype.cancel = function(r2) {
    this._activeQuery === r2 ? this.native.cancel(function() {
    }) : this._queryQueue.indexOf(r2) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r2), 1);
  };
  Z2.prototype.ref = function() {
  };
  Z2.prototype.unref = function() {
  };
  Z2.prototype.setTypeParser = function(r2, e3, t2) {
    return this._types.setTypeParser(r2, e3, t2);
  };
  Z2.prototype.getTypeParser = function(r2, e3) {
    return this._types.getTypeParser(r2, e3);
  };
});
var wn = I((Sf, $s) => {
  "use strict";
  p3();
  $s.exports = Gs();
});
var At = I((Ef, nt) => {
  "use strict";
  p3();
  var Mc = Ls(), Dc = et(), Oc = cn(), kc = Ds(), { DatabaseError: Uc } = on(), qc = a((r2) => {
    var e3;
    return e3 = class extends kc {
      constructor(n2) {
        super(n2, r2);
      }
    }, a(e3, "BoundPool"), e3;
  }, "poolFactory"), bn = a(function(r2) {
    this.defaults = Dc, this.Client = r2, this.Query = this.Client.Query, this.Pool = qc(this.Client), this._pools = [], this.Connection = Oc, this.types = Xe(), this.DatabaseError = Uc;
  }, "PG");
  typeof m2.env.NODE_PG_FORCE_NATIVE < "u" ? nt.exports = new bn(wn()) : (nt.exports = new bn(Mc), Object.defineProperty(nt.exports, "native", { configurable: true, enumerable: false, get() {
    var r2 = null;
    try {
      r2 = new bn(wn());
    } catch (e3) {
      if (e3.code !== "MODULE_NOT_FOUND")
        throw e3;
    }
    return Object.defineProperty(nt.exports, "native", { value: r2 }), r2;
  } }));
});
p3();
var Ct = We(At());
wt();
p3();
fr();
wt();
var zs = We(tt());
var Sn = class Sn2 extends Error {
  constructor() {
    super(...arguments);
    T(this, "name", "NeonDbError");
    T(this, "code", null);
    T(this, "sourceError");
  }
};
a(Sn, "NeonDbError");
var Ae = Sn;
var Ks = "transaction() expects an array of queries, or a function returning an array of queries";
function Ys(r2, {
  arrayMode: e3,
  fullResults: t2,
  fetchOptions: n2,
  isolationLevel: i2,
  readOnly: s2,
  deferrable: o2,
  queryCallback: u2,
  resultCallback: c3
} = {}) {
  if (!r2)
    throw new Error(
      "No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?"
    );
  let h2;
  try {
    h2 = lr(r2);
  } catch {
    throw new Error("Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(
      r2
    ));
  }
  let { protocol: l3, username: y2, password: E, hostname: _, port: P2, pathname: N } = h2;
  if (l3 !== "postgres:" && l3 !== "postgresql:" || !y2 || !E || !_ || !N)
    throw new Error("Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value");
  function J(A, ...g2) {
    let D, H;
    if (typeof A == "string")
      D = A, H = g2[1], g2 = g2[0] ?? [];
    else {
      D = "";
      for (let W = 0; W < A.length; W++)
        D += A[W], W < g2.length && (D += "$" + (W + 1));
    }
    g2 = g2.map((W) => (0, zs.prepareValue)(W));
    let Q = { query: D, params: g2 };
    return u2 && u2(Q), Nc(
      pe,
      Q,
      H
    );
  }
  a(J, "resolve"), J.transaction = async (A, g2) => {
    if (typeof A == "function" && (A = A(J)), !Array.isArray(A))
      throw new Error(Ks);
    let D = A.map((H) => {
      if (H[Symbol.toStringTag] !== "NeonQueryPromise")
        throw new Error(Ks);
      return H.parameterizedQuery;
    });
    return pe(
      D,
      g2
    );
  };
  async function pe(A, g2) {
    let D = n2 ?? {}, { fetchEndpoint: H, fetchConnectionCache: Q, fetchFunction: W } = _e, ue = typeof H == "function" ? H(_, P2) : H, de = Array.isArray(A) ? { queries: A } : A, L = e3 ?? false, G = t2 ?? false, ce = i2, ye = s2, xe = o2;
    g2 !== void 0 && (g2.arrayMode !== void 0 && (L = g2.arrayMode), g2.fullResults !== void 0 && (G = g2.fullResults), g2.fetchOptions !== void 0 && (D = { ...D, ...g2.fetchOptions }), g2.isolationLevel !== void 0 && (ce = g2.isolationLevel), g2.readOnly !== void 0 && (ye = g2.readOnly), g2.deferrable !== void 0 && (xe = g2.deferrable));
    let he = { "Neon-Connection-String": r2, "Neon-Raw-Text-Output": "true", "Neon-Array-Mode": "true" };
    Q === true && (he["Neon-Pool-Opt-In"] = "true"), Array.isArray(A) && (ce !== void 0 && (he["Neon-Batch-Isolation-Level"] = ce), ye !== void 0 && (he["Neon-Batch-Read-Only"] = String(ye)), xe !== void 0 && (he["Neon-Batch-Deferrable"] = String(xe)));
    let ie;
    try {
      ie = await (W ?? fetch)(ue, { method: "POST", body: JSON.stringify(de), headers: he, ...D });
    } catch (se) {
      let $ = new Ae(`Error connecting to database: ${se.message}`);
      throw $.sourceError = se, $;
    }
    if (ie.ok) {
      let se = await ie.json();
      if (Array.isArray(A)) {
        let $ = se.results;
        if (!Array.isArray($))
          throw new Ae("Neon internal error: unexpected result format");
        return $.map((ne2, Ce) => Vs(ne2, {
          arrayMode: L,
          fullResults: G,
          parameterizedQuery: A[Ce],
          resultCallback: c3
        }));
      } else
        return Vs(se, {
          arrayMode: L,
          fullResults: G,
          parameterizedQuery: A,
          resultCallback: c3
        });
    } else {
      let { status: se } = ie;
      if (se === 400) {
        let { message: $, code: ne2 } = await ie.json(), Ce = new Ae($);
        throw Ce.code = ne2, Ce;
      } else {
        let $ = await ie.text();
        throw new Ae(`Server error (HTTP status ${se}): ${$}`);
      }
    }
  }
  return a(
    pe,
    "execute"
  ), J;
}
a(Ys, "neon");
function Nc(r2, e3, t2) {
  return { [Symbol.toStringTag]: "NeonQueryPromise", parameterizedQuery: e3, opts: t2, then: (n2, i2) => r2(e3, t2).then(n2, i2), catch: (n2) => r2(
    e3,
    t2
  ).catch(n2), finally: (n2) => r2(e3, t2).finally(n2) };
}
a(Nc, "createNeonQueryPromise");
function Vs(r2, {
  arrayMode: e3,
  fullResults: t2,
  parameterizedQuery: n2,
  resultCallback: i2
}) {
  let s2 = r2.fields.map((c3) => c3.name), o2 = r2.fields.map((c3) => Se.types.getTypeParser(c3.dataTypeID)), u2 = e3 === true ? r2.rows.map((c3) => c3.map((h2, l3) => h2 === null ? null : o2[l3](h2))) : r2.rows.map((c3) => Object.fromEntries(
    c3.map((h2, l3) => [s2[l3], h2 === null ? null : o2[l3](h2)])
  ));
  return i2 && i2(n2, r2, u2, { arrayMode: e3, fullResults: t2 }), t2 ? (r2.viaNeonFetch = true, r2.rowAsArray = e3, r2.rows = u2, r2) : u2;
}
a(Vs, "processQueryResult");
var Js = We(gt());
var Se = We(At());
var En = class En2 extends Ct.Client {
  constructor(t2) {
    super(t2);
    this.config = t2;
  }
  get neonConfig() {
    return this.connection.stream;
  }
  connect(t2) {
    let { neonConfig: n2 } = this;
    n2.forceDisablePgSSL && (this.ssl = this.connection.ssl = false), this.ssl && n2.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
    let i2 = this.config?.host !== void 0 || this.config?.connectionString !== void 0 || m2.env.PGHOST !== void 0, s2 = m2.env.USER ?? m2.env.USERNAME;
    if (!i2 && this.host === "localhost" && this.user === s2 && this.database === s2 && this.password === null)
      throw new Error(`No database host or connection string was set, and key parameters have default values (host: localhost, user: ${s2}, db: ${s2}, password: null). Is an environment variable missing? Alternatively, if you intended to connect with these parameters, please set the host to 'localhost' explicitly.`);
    let o2 = super.connect(t2), u2 = n2.pipelineTLS && this.ssl, c3 = n2.pipelineConnect === "password";
    if (!u2 && !n2.pipelineConnect)
      return o2;
    let h2 = this.connection;
    if (u2 && h2.on("connect", () => h2.stream.emit("data", "S")), c3) {
      h2.removeAllListeners(
        "authenticationCleartextPassword"
      ), h2.removeAllListeners("readyForQuery"), h2.once(
        "readyForQuery",
        () => h2.on("readyForQuery", this._handleReadyForQuery.bind(this))
      );
      let l3 = this.ssl ? "sslconnect" : "connect";
      h2.on(l3, () => {
        this._handleAuthCleartextPassword(), this._handleReadyForQuery();
      });
    }
    return o2;
  }
  async _handleAuthSASLContinue(t2) {
    let n2 = this.saslSession, i2 = this.password, s2 = t2.data;
    if (n2.message !== "SASLInitialResponse" || typeof i2 != "string" || typeof s2 != "string")
      throw new Error("SASL: protocol error");
    let o2 = Object.fromEntries(s2.split(",").map(($) => {
      if (!/^.=/.test($))
        throw new Error("SASL: Invalid attribute pair entry");
      let ne2 = $[0], Ce = $.substring(2);
      return [ne2, Ce];
    })), u2 = o2.r, c3 = o2.s, h2 = o2.i;
    if (!u2 || !/^[!-+--~]+$/.test(u2))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable");
    if (!c3 || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(c3))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64");
    if (!h2 || !/^[1-9][0-9]*$/.test(h2))
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count");
    if (!u2.startsWith(n2.clientNonce))
      throw new Error(
        "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce"
      );
    if (u2.length === n2.clientNonce.length)
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    let l3 = parseInt(h2, 10), y2 = d3.from(c3, "base64"), E = new TextEncoder(), _ = E.encode(i2), P2 = await w2.subtle.importKey("raw", _, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), N = new Uint8Array(await w2.subtle.sign("HMAC", P2, d3.concat([y2, d3.from(
      [0, 0, 0, 1]
    )]))), J = N;
    for (var pe = 0; pe < l3 - 1; pe++)
      N = new Uint8Array(await w2.subtle.sign(
        "HMAC",
        P2,
        N
      )), J = d3.from(J.map(($, ne2) => J[ne2] ^ N[ne2]));
    let A = J, g2 = await w2.subtle.importKey(
      "raw",
      A,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    ), D = new Uint8Array(await w2.subtle.sign("HMAC", g2, E.encode("Client Key"))), H = await w2.subtle.digest(
      "SHA-256",
      D
    ), Q = "n=*,r=" + n2.clientNonce, W = "r=" + u2 + ",s=" + c3 + ",i=" + l3, ue = "c=biws,r=" + u2, de = Q + "," + W + "," + ue, L = await w2.subtle.importKey(
      "raw",
      H,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign"]
    );
    var G = new Uint8Array(await w2.subtle.sign("HMAC", L, E.encode(de))), ce = d3.from(D.map(($, ne2) => D[ne2] ^ G[ne2])), ye = ce.toString("base64");
    let xe = await w2.subtle.importKey("raw", A, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), he = await w2.subtle.sign("HMAC", xe, E.encode("Server Key")), ie = await w2.subtle.importKey("raw", he, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var se = d3.from(await w2.subtle.sign("HMAC", ie, E.encode(de)));
    n2.message = "SASLResponse", n2.serverSignature = se.toString("base64"), n2.response = ue + ",p=" + ye, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
  }
};
a(En, "NeonClient");
var xn = En;
function Qc(r2, e3) {
  if (e3)
    return {
      callback: e3,
      result: void 0
    };
  let t2, n2, i2 = a(function(o2, u2) {
    o2 ? t2(o2) : n2(u2);
  }, "cb"), s2 = new r2(function(o2, u2) {
    n2 = o2, t2 = u2;
  });
  return { callback: i2, result: s2 };
}
a(Qc, "promisify");
var vn = class vn2 extends Ct.Pool {
  constructor() {
    super(...arguments);
    T(this, "Client", xn);
    T(this, "hasFetchUnsupportedListeners", false);
  }
  on(t2, n2) {
    return t2 !== "error" && (this.hasFetchUnsupportedListeners = true), super.on(t2, n2);
  }
  query(t2, n2, i2) {
    if (!_e.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t2 == "function")
      return super.query(t2, n2, i2);
    typeof n2 == "function" && (i2 = n2, n2 = void 0);
    let s2 = Qc(
      this.Promise,
      i2
    );
    i2 = s2.callback;
    try {
      let o2 = new Js.default(this.options), u2 = encodeURIComponent, c3 = encodeURI, h2 = `postgresql://${u2(o2.user)}:${u2(o2.password)}@${u2(o2.host)}/${c3(o2.database)}`, l3 = typeof t2 == "string" ? t2 : t2.text, y2 = n2 ?? t2.values ?? [];
      Ys(h2, { fullResults: true, arrayMode: t2.rowMode === "array" })(l3, y2).then((_) => i2(void 0, _)).catch((_) => i2(_));
    } catch (o2) {
      i2(o2);
    }
    return s2.result;
  }
};
a(vn, "NeonPool");
var export_ClientBase = Se.ClientBase;
var export_Connection = Se.Connection;
var export_DatabaseError = Se.DatabaseError;
var export_Query = Se.Query;
var export_defaults = Se.defaults;
var export_types = Se.types;

// ../node_modules/drizzle-orm/entity.js
init_checked_fetch();
init_modules_watch_stub();
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../node_modules/drizzle-orm/logger.js
init_checked_fetch();
init_modules_watch_stub();
var _a;
var ConsoleLogWriter = class {
  write(message3) {
    console.log(message3);
  }
};
_a = entityKind;
__publicField(ConsoleLogWriter, _a, "ConsoleLogWriter");
var _a2;
var DefaultLogger = class {
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p4) => {
      try {
        return JSON.stringify(p4);
      } catch {
        return String(p4);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
_a2 = entityKind;
__publicField(DefaultLogger, _a2, "DefaultLogger");
var _a3;
var NoopLogger = class {
  logQuery() {
  }
};
_a3 = entityKind;
__publicField(NoopLogger, _a3, "NoopLogger");

// ../node_modules/drizzle-orm/pg-core/db.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/query-builders/delete.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/query-promise.js
init_checked_fetch();
init_modules_watch_stub();
var _a4;
var QueryPromise = class {
  [(_a4 = entityKind, Symbol.toStringTag)] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};
__publicField(QueryPromise, _a4, "QueryPromise");

// ../node_modules/drizzle-orm/table.js
init_checked_fetch();
init_modules_watch_stub();
var TableName = Symbol.for("drizzle:Name");
var Schema2 = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var _a5;
var Table = class {
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [(_a5 = entityKind, TableName)];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema2];
  /** @internal */
  [Columns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  [IsDrizzleTable] = true;
  constructor(name, schema4, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema2] = schema4;
    this[BaseName] = baseName;
  }
};
__publicField(Table, _a5, "Table");
/** @internal */
__publicField(Table, "Symbol", {
  Name: TableName,
  Schema: Schema2,
  OriginalName,
  Columns,
  BaseName,
  IsAlias,
  ExtraConfigBuilder
});
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}

// ../node_modules/drizzle-orm/tracing.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/tracing-utils.js
init_checked_fetch();
init_modules_watch_stub();
function iife(fn, ...args) {
  return fn(...args);
}

// ../node_modules/drizzle-orm/version.js
init_checked_fetch();
init_modules_watch_stub();
var version = "0.29.3";

// ../node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span) => {
          try {
            return fn(span);
          } catch (e3) {
            span.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e3 instanceof Error ? e3.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e3;
          } finally {
            span.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// ../node_modules/drizzle-orm/utils.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/column.js
init_checked_fetch();
init_modules_watch_stub();
var _a6;
var Column = class {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
};
_a6 = entityKind;
__publicField(Column, _a6, "Column");

// ../node_modules/drizzle-orm/sql/sql.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/relations.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/primary-keys.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/table.js
init_checked_fetch();
init_modules_watch_stub();
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var _a7;
var PgTable = class extends Table {
  /**@internal */
  [(_a7 = entityKind, InlineForeignKeys)] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__publicField(PgTable, _a7, "PgTable");
/** @internal */
__publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys
}));
function pgTableWithSchema(name, columns, extraConfig, schema4, baseName = name) {
  const rawTable = new PgTable(name, schema4, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, void 0);
};

// ../node_modules/drizzle-orm/pg-core/primary-keys.js
var _a8;
var PrimaryKeyBuilder = class {
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
};
_a8 = entityKind;
__publicField(PrimaryKeyBuilder, _a8, "PgPrimaryKeyBuilder");
var _a9;
var PrimaryKey = class {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
_a9 = entityKind;
__publicField(PrimaryKey, _a9, "PgPrimaryKey");

// ../node_modules/drizzle-orm/sql/expressions/conditions.js
init_checked_fetch();
init_modules_watch_stub();
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c3) => c3 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or2(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c3) => c3 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt2 = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v3) => bindIfParam(v3, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v3) => bindIfParam(v3, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// ../node_modules/drizzle-orm/sql/expressions/select.js
init_checked_fetch();
init_modules_watch_stub();
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../node_modules/drizzle-orm/relations.js
var _a10;
var Relation = class {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  referencedTableName;
  fieldName;
};
_a10 = entityKind;
__publicField(Relation, _a10, "Relation");
var _a11;
var Relations = class {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
};
_a11 = entityKind;
__publicField(Relations, _a11, "Relations");
var _a12;
var _One = class extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var One = _One;
_a12 = entityKind;
__publicField(One, _a12, "One");
var _a13;
var _Many = class extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = _Many;
_a13 = entityKind;
__publicField(Many, _a13, "Many");
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt: gt2,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or: or2,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema4, configHelpers) {
  if (Object.keys(schema4).length === 1 && "default" in schema4 && !is(schema4["default"], Table)) {
    schema4 = schema4["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema4)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(
    table,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key)
      ])
    )
  );
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(
      sourceTable,
      table,
      config,
      config?.fields.reduce((res, f2) => res && f2.notNull, true) ?? false
    );
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema4, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema4[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder2.mapFromDriverValue(value);
    }
  }
  return result;
}

// ../node_modules/drizzle-orm/subquery.js
init_checked_fetch();
init_modules_watch_stub();
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");
var _a14;
var Subquery = class {
  /** @internal */
  [(_a14 = entityKind, SubqueryConfig)];
  constructor(sql2, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql2,
      selection,
      alias,
      isWith
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
__publicField(Subquery, _a14, "Subquery");
var _a15;
var WithSubquery = class extends Subquery {
};
_a15 = entityKind;
__publicField(WithSubquery, _a15, "WithSubquery");

// ../node_modules/drizzle-orm/view-common.js
init_checked_fetch();
init_modules_watch_stub();
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../node_modules/drizzle-orm/sql/sql.js
var _a16;
var FakePrimitiveParam = class {
};
_a16 = entityKind;
__publicField(FakePrimitiveParam, _a16, "FakePrimitiveParam");
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
var _a17;
var StringChunk = class {
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a17 = entityKind;
__publicField(StringChunk, _a17, "StringChunk");
var _a18;
var _SQL = class {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p4] of chunk.entries()) {
          result.push(p4);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== void 0) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (is(chunk, Relation)) {
        return this.buildQueryFromSourceParams([
          chunk.sourceTable,
          new StringChunk("."),
          sql.identifier(chunk.fieldName)
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
};
var SQL = _SQL;
_a18 = entityKind;
__publicField(SQL, _a18, "SQL");
var _a19;
var Name = class {
  constructor(value) {
    this.value = value;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a19 = entityKind;
__publicField(Name, _a19, "Name");
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var _a20;
var Param = class {
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder2 = noopEncoder) {
    this.value = value;
    this.encoder = encoder2;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a20 = entityKind;
__publicField(Param, _a20, "Param");
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder2) {
    return new Param(value, encoder2);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var _a21;
var Placeholder = class {
  constructor(name2) {
    this.name = name2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a21 = entityKind;
__publicField(Placeholder, _a21, "Placeholder");
function fillPlaceholders(params, values) {
  return params.map((p4) => {
    if (is(p4, Placeholder)) {
      if (!(p4.name in values)) {
        throw new Error(`No value for placeholder "${p4.name}" was provided`);
      }
      return values[p4.name];
    }
    return p4;
  });
}
var _a22;
var View = class {
  /** @internal */
  [(_a22 = entityKind, ViewBaseConfig)];
  constructor({ name: name2, schema: schema4, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema: schema4,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
__publicField(View, _a22, "View");
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index2, key] of leftKeys.entries()) {
    if (key !== rightKeys[index2]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}

// ../node_modules/drizzle-orm/pg-core/query-builders/delete.js
var _a23;
var PgDeleteBase = class extends QueryPromise {
  constructor(table, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table };
  }
  config;
  /** 
   * Adds a `where` clause to the query.
   * 
   * Calling this method will delete only those rows that fulfill a specified condition.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   * 
   * @param where the `where` clause.
   * 
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   * 
   * ```ts
   * // Delete all cars with green color
   * await db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   * 
   * You can logically combine conditional operators with `and()` and `or()` operators:
   * 
   * ```ts
   * // Delete all BMW cars with a green color
   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   * 
   * // Delete all cars with the green or blue color
   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
  */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
_a23 = entityKind;
__publicField(PgDeleteBase, _a23, "PgDelete");

// ../node_modules/drizzle-orm/pg-core/query-builders/insert.js
init_checked_fetch();
init_modules_watch_stub();
var _a24;
var PgInsertBuilder = class {
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect);
  }
};
_a24 = entityKind;
__publicField(PgInsertBuilder, _a24, "PgInsertBuilder");
var _a25;
var PgInsertBase = class extends QueryPromise {
  constructor(table, values, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values };
  }
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   * 
   * Calling this method simply avoids inserting a row as its alternative action.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   * 
   * @param config The `target` and `where` clauses.
   * 
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   * 
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config = {}) {
    if (config.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
      const whereSql = config.where ? sql` where ${config.where}` : void 0;
      this.config.onConflict = sql`(${sql.raw(targetColumn)}) do nothing${whereSql}`;
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   * 
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts} 
   * 
   * @param config The `target`, `set` and `where` clauses.
   * 
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({ 
   *     target: cars.id, 
   *     set: { brand: 'Porsche' } 
   *   });
   * 
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config) {
    const whereSql = config.where ? sql` where ${config.where}` : void 0;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
    this.config.onConflict = sql`(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
};
_a25 = entityKind;
__publicField(PgInsertBase, _a25, "PgInsert");

// ../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/dialect.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/alias.js
init_checked_fetch();
init_modules_watch_stub();
var _a26;
var ColumnAliasProxyHandler = class {
  constructor(table) {
    this.table = table;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
_a26 = entityKind;
__publicField(ColumnAliasProxyHandler, _a26, "ColumnAliasProxyHandler");
var _a27;
var TableAliasProxyHandler = class {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(
          columns[key],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
_a27 = entityKind;
__publicField(TableAliasProxyHandler, _a27, "TableAliasProxyHandler");
var _a28;
var RelationTableAliasProxyHandler = class {
  constructor(alias) {
    this.alias = alias;
  }
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
_a28 = entityKind;
__publicField(RelationTableAliasProxyHandler, _a28, "RelationTableAliasProxyHandler");
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c3) => {
    if (is(c3, Column)) {
      return aliasedTableColumn(c3, alias);
    }
    if (is(c3, SQL)) {
      return mapColumnsInSQLToAlias(c3, alias);
    }
    if (is(c3, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c3, alias);
    }
    return c3;
  }));
}

// ../node_modules/drizzle-orm/errors.js
init_checked_fetch();
init_modules_watch_stub();
var _a29;
var DrizzleError = class extends Error {
  constructor({ message: message3, cause }) {
    super(message3);
    this.name = "DrizzleError";
    this.cause = cause;
  }
};
_a29 = entityKind;
__publicField(DrizzleError, _a29, "DrizzleError");
var _a30;
var TransactionRollbackError = class extends DrizzleError {
  constructor() {
    super({ message: "Rollback" });
  }
};
_a30 = entityKind;
__publicField(TransactionRollbackError, _a30, "TransactionRollbackError");

// ../node_modules/drizzle-orm/pg-core/columns/common.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/column-builder.js
init_checked_fetch();
init_modules_watch_stub();
var _a31;
var ColumnBuilder = class {
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
};
_a31 = entityKind;
__publicField(ColumnBuilder, _a31, "ColumnBuilder");

// ../node_modules/drizzle-orm/pg-core/foreign-keys.js
init_checked_fetch();
init_modules_watch_stub();
var _a32;
var ForeignKeyBuilder = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey(table, this);
  }
};
_a32 = entityKind;
__publicField(ForeignKeyBuilder, _a32, "PgForeignKeyBuilder");
var _a33;
var ForeignKey = class {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
_a33 = entityKind;
__publicField(ForeignKey, _a33, "PgForeignKey");

// ../node_modules/drizzle-orm/pg-core/unique-constraint.js
init_checked_fetch();
init_modules_watch_stub();
function unique(name) {
  return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
  return `${table[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var _a34;
var UniqueConstraintBuilder = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
_a34 = entityKind;
__publicField(UniqueConstraintBuilder, _a34, "PgUniqueConstraintBuilder");
var _a35;
var UniqueOnConstraintBuilder = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
_a35 = entityKind;
__publicField(UniqueOnConstraintBuilder, _a35, "PgUniqueOnConstraintBuilder");
var _a36;
var UniqueConstraint = class {
  constructor(table, columns, nullsNotDistinct, name) {
    this.table = table;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};
_a36 = entityKind;
__publicField(UniqueConstraint, _a36, "PgUniqueConstraint");

// ../node_modules/drizzle-orm/pg-core/utils/array.js
init_checked_fetch();
init_modules_watch_stub();
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom; i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../node_modules/drizzle-orm/pg-core/columns/common.js
var _a37;
var PgColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife(
        (ref2, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table);
        },
        ref,
        actions
      );
    });
  }
};
_a37 = entityKind;
__publicField(PgColumnBuilder, _a37, "PgColumnBuilder");
var _a38;
var PgColumn = class extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
};
_a38 = entityKind;
__publicField(PgColumn, _a38, "PgColumn");
var _a39;
var PgArrayBuilder = class extends PgColumnBuilder {
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(
      table,
      this.config,
      baseColumn
    );
  }
};
_a39 = entityKind;
__publicField(PgArrayBuilder, _a39, "PgArrayBuilder");
var _a40;
var _PgArray = class extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v3) => this.baseColumn.mapFromDriverValue(v3));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a2 = value.map(
      (v3) => v3 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v3, true) : this.baseColumn.mapToDriverValue(v3)
    );
    if (isNestedArray)
      return a2;
    return makePgArray(a2);
  }
};
var PgArray = _PgArray;
_a40 = entityKind;
__publicField(PgArray, _a40, "PgArray");

// ../node_modules/drizzle-orm/pg-core/columns/boolean.js
init_checked_fetch();
init_modules_watch_stub();
var _a41;
var PgBooleanBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  /** @internal */
  build(table) {
    return new PgBoolean(table, this.config);
  }
};
_a41 = entityKind;
__publicField(PgBooleanBuilder, _a41, "PgBooleanBuilder");
var _a42;
var PgBoolean = class extends PgColumn {
  getSQLType() {
    return "boolean";
  }
};
_a42 = entityKind;
__publicField(PgBoolean, _a42, "PgBoolean");
function boolean(name) {
  return new PgBooleanBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/columns/date.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/columns/date.common.js
init_checked_fetch();
init_modules_watch_stub();
var _a43;
var PgDateColumnBaseBuilder = class extends PgColumnBuilder {
  defaultNow() {
    return this.default(sql`now()`);
  }
};
_a43 = entityKind;
__publicField(PgDateColumnBaseBuilder, _a43, "PgDateColumnBaseBuilder");

// ../node_modules/drizzle-orm/pg-core/columns/date.js
var _a44;
var PgDateBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "date", "PgDate");
  }
  /** @internal */
  build(table) {
    return new PgDate(table, this.config);
  }
};
_a44 = entityKind;
__publicField(PgDateBuilder, _a44, "PgDateBuilder");
var _a45;
var PgDate = class extends PgColumn {
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
};
_a45 = entityKind;
__publicField(PgDate, _a45, "PgDate");
var _a46;
var PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  /** @internal */
  build(table) {
    return new PgDateString(
      table,
      this.config
    );
  }
};
_a46 = entityKind;
__publicField(PgDateStringBuilder, _a46, "PgDateStringBuilder");
var _a47;
var PgDateString = class extends PgColumn {
  getSQLType() {
    return "date";
  }
};
_a47 = entityKind;
__publicField(PgDateString, _a47, "PgDateString");

// ../node_modules/drizzle-orm/pg-core/columns/json.js
init_checked_fetch();
init_modules_watch_stub();
var _a48;
var PgJsonBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJson");
  }
  /** @internal */
  build(table) {
    return new PgJson(table, this.config);
  }
};
_a48 = entityKind;
__publicField(PgJsonBuilder, _a48, "PgJsonBuilder");
var _a49;
var PgJson = class extends PgColumn {
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
_a49 = entityKind;
__publicField(PgJson, _a49, "PgJson");

// ../node_modules/drizzle-orm/pg-core/columns/jsonb.js
init_checked_fetch();
init_modules_watch_stub();
var _a50;
var PgJsonbBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  /** @internal */
  build(table) {
    return new PgJsonb(table, this.config);
  }
};
_a50 = entityKind;
__publicField(PgJsonbBuilder, _a50, "PgJsonbBuilder");
var _a51;
var PgJsonb = class extends PgColumn {
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
_a51 = entityKind;
__publicField(PgJsonb, _a51, "PgJsonb");

// ../node_modules/drizzle-orm/pg-core/columns/numeric.js
init_checked_fetch();
init_modules_watch_stub();
var _a52;
var PgNumericBuilder = class extends PgColumnBuilder {
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumeric(table, this.config);
  }
};
_a52 = entityKind;
__publicField(PgNumericBuilder, _a52, "PgNumericBuilder");
var _a53;
var PgNumeric = class extends PgColumn {
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
_a53 = entityKind;
__publicField(PgNumeric, _a53, "PgNumeric");

// ../node_modules/drizzle-orm/pg-core/columns/text.js
init_checked_fetch();
init_modules_watch_stub();
var _a54;
var PgTextBuilder = class extends PgColumnBuilder {
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new PgText(table, this.config);
  }
};
_a54 = entityKind;
__publicField(PgTextBuilder, _a54, "PgTextBuilder");
var _a55;
var PgText = class extends PgColumn {
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
};
_a55 = entityKind;
__publicField(PgText, _a55, "PgText");
function text(name, config = {}) {
  return new PgTextBuilder(name, config);
}

// ../node_modules/drizzle-orm/pg-core/columns/time.js
init_checked_fetch();
init_modules_watch_stub();
var _a56;
var PgTimeBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTime(table, this.config);
  }
};
_a56 = entityKind;
__publicField(PgTimeBuilder, _a56, "PgTimeBuilder");
var _a57;
var PgTime = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
_a57 = entityKind;
__publicField(PgTime, _a57, "PgTime");

// ../node_modules/drizzle-orm/pg-core/columns/timestamp.js
init_checked_fetch();
init_modules_watch_stub();
var _a58;
var PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestamp(table, this.config);
  }
};
_a58 = entityKind;
__publicField(PgTimestampBuilder, _a58, "PgTimestampBuilder");
var _a59;
var PgTimestamp = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return this.withTimezone ? value.toUTCString() : value.toISOString();
  };
};
_a59 = entityKind;
__publicField(PgTimestamp, _a59, "PgTimestamp");
var _a60;
var PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestampString(
      table,
      this.config
    );
  }
};
_a60 = entityKind;
__publicField(PgTimestampStringBuilder, _a60, "PgTimestampStringBuilder");
var _a61;
var PgTimestampString = class extends PgColumn {
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
_a61 = entityKind;
__publicField(PgTimestampString, _a61, "PgTimestampString");
function timestamp2(name, config = {}) {
  if (config.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

// ../node_modules/drizzle-orm/pg-core/columns/uuid.js
init_checked_fetch();
init_modules_watch_stub();
var _a62;
var PgUUIDBuilder = class extends PgColumnBuilder {
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  /**
   * Adds `default gen_random_uuid()` to the column definition.
   */
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  /** @internal */
  build(table) {
    return new PgUUID(table, this.config);
  }
};
_a62 = entityKind;
__publicField(PgUUIDBuilder, _a62, "PgUUIDBuilder");
var _a63;
var PgUUID = class extends PgColumn {
  getSQLType() {
    return "uuid";
  }
};
_a63 = entityKind;
__publicField(PgUUID, _a63, "PgUUID");
function uuid(name) {
  return new PgUUIDBuilder(name);
}

// ../node_modules/drizzle-orm/pg-core/view-base.js
init_checked_fetch();
init_modules_watch_stub();
var _a64;
var PgViewBase = class extends View {
};
_a64 = entityKind;
__publicField(PgViewBase, _a64, "PgViewBase");

// ../node_modules/drizzle-orm/pg-core/dialect.js
var _a65;
var PgDialect = class {
  async migrate(migrations, session) {
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(
      sql`select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`
    );
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(
            sql`insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table, where, returning }) {
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set2) {
    const setEntries = Object.entries(set2);
    const setSize = setEntries.length;
    return sql.join(
      setEntries.flatMap(([colName, value], i2) => {
        const col = table[Table.Symbol.Columns][colName];
        const res = sql`${sql.identifier(col.name)} = ${value}`;
        if (i2 < setSize - 1) {
          return [res, sql.raw(", ")];
        }
        return [res];
      })
    );
  }
  buildUpdateQuery({ table, set: set2, where, returning }) {
    const setSql = this.buildUpdateSet(table, set2);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(
            new SQL(
              query.queryChunks.map((c3) => {
                if (is(c3, PgColumn)) {
                  return sql.identifier(c3.name);
                }
                return c3;
              })
            )
          );
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f2 of fieldsList) {
      if (is(f2.field, Column) && getTableName(f2.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
        ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
      ))(f2.field.table)) {
        const tableName = getTableName(f2.field.table);
        throw new Error(
          `Your "${f2.path.join("->")}" field references a column "${tableName}"."${f2.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql`with `];
      for (const [i2, w3] of withList.entries()) {
        withSqlChunks.push(sql`${sql.identifier(w3[SubqueryConfig].alias)} as (${w3[SubqueryConfig].sql})`);
        if (i2 < withList.length - 1) {
          withSqlChunks.push(sql`, `);
        }
      }
      withSqlChunks.push(sql` `);
      withSql = sql.join(withSqlChunks);
    }
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
        if (table[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
        if (is(table2, PgTable)) {
          const tableName = table2[PgTable.Symbol.Name];
          const tableSchema = table2[PgTable.Symbol.Schema];
          const origTableName = table2[PgTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
          );
        } else if (is(table2, View)) {
          const viewName = table2[ViewBaseConfig].name;
          const viewSchema = table2[ViewBaseConfig].schema;
          const origViewName = table2[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
          );
        } else {
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`
          );
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(
          sql` of ${sql.join(
            Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
            sql`, `
          )}`
        );
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : void 0;
    const withNoDataSql = withNoData ? sql` with no data` : void 0;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder2) {
    if (is(encoder2, PgJsonb) || is(encoder2, PgJson)) {
      return "json";
    } else if (is(encoder2, PgNumeric)) {
      return "decimal";
    } else if (is(encoder2, PgTime)) {
      return "time";
    } else if (is(encoder2, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder2, PgDate)) {
      return "date";
    } else if (is(encoder2, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  // buildRelationalQueryWithPK({
  // 	fullSchema,
  // 	schema,
  // 	tableNamesMap,
  // 	table,
  // 	tableConfig,
  // 	queryConfig: config,
  // 	tableAlias,
  // 	isRoot = false,
  // 	joinOn,
  // }: {
  // 	fullSchema: Record<string, unknown>;
  // 	schema: TablesRelationalConfig;
  // 	tableNamesMap: Record<string, string>;
  // 	table: PgTable;
  // 	tableConfig: TableRelationalConfig;
  // 	queryConfig: true | DBQueryConfig<'many', true>;
  // 	tableAlias: string;
  // 	isRoot?: boolean;
  // 	joinOn?: SQL;
  // }): BuildRelationalQueryResult<PgTable, PgColumn> {
  // 	// For { "<relation>": true }, return a table with selection of all columns
  // 	if (config === true) {
  // 		const selectionEntries = Object.entries(tableConfig.columns);
  // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
  // 			[key, value],
  // 		) => ({
  // 			dbKey: value.name,
  // 			tsKey: key,
  // 			field: value as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection,
  // 		};
  // 	}
  // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// let selectionForBuild = selection;
  // 	const aliasedColumns = Object.fromEntries(
  // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
  // 	);
  // 	const aliasedRelations = Object.fromEntries(
  // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
  // 	);
  // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
  // 	let where, hasUserDefinedWhere;
  // 	if (config.where) {
  // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
  // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
  // 		hasUserDefinedWhere = !!where;
  // 	}
  // 	where = and(joinOn, where);
  // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
  // 	let joins: Join[] = [];
  // 	let selectedColumns: string[] = [];
  // 	// Figure out which columns to select
  // 	if (config.columns) {
  // 		let isIncludeMode = false;
  // 		for (const [field, value] of Object.entries(config.columns)) {
  // 			if (value === undefined) {
  // 				continue;
  // 			}
  // 			if (field in tableConfig.columns) {
  // 				if (!isIncludeMode && value === true) {
  // 					isIncludeMode = true;
  // 				}
  // 				selectedColumns.push(field);
  // 			}
  // 		}
  // 		if (selectedColumns.length > 0) {
  // 			selectedColumns = isIncludeMode
  // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
  // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
  // 		}
  // 	} else {
  // 		// Select all columns if selection is not specified
  // 		selectedColumns = Object.keys(tableConfig.columns);
  // 	}
  // 	// for (const field of selectedColumns) {
  // 	// 	const column = tableConfig.columns[field]! as PgColumn;
  // 	// 	fieldsSelection.push({ tsKey: field, value: column });
  // 	// }
  // 	let initiallySelectedRelations: {
  // 		tsKey: string;
  // 		queryConfig: true | DBQueryConfig<'many', false>;
  // 		relation: Relation;
  // 	}[] = [];
  // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// Figure out which relations to select
  // 	if (config.with) {
  // 		initiallySelectedRelations = Object.entries(config.with)
  // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
  // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
  // 	}
  // 	const manyRelations = initiallySelectedRelations.filter((r) =>
  // 		is(r.relation, Many)
  // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
  // 	);
  // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
  // 	const isInnermostQuery = manyRelations.length < 2;
  // 	const selectedExtras: {
  // 		tsKey: string;
  // 		value: SQL.Aliased;
  // 	}[] = [];
  // 	// Figure out which extras to select
  // 	if (isInnermostQuery && config.extras) {
  // 		const extras = typeof config.extras === 'function'
  // 			? config.extras(aliasedFields, { sql })
  // 			: config.extras;
  // 		for (const [tsKey, value] of Object.entries(extras)) {
  // 			selectedExtras.push({
  // 				tsKey,
  // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
  // 			});
  // 		}
  // 	}
  // 	// Transform `fieldsSelection` into `selection`
  // 	// `fieldsSelection` shouldn't be used after this point
  // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
  // 	// 	selection.push({
  // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
  // 	// 		tsKey,
  // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
  // 	// 		relationTableTsKey: undefined,
  // 	// 		isJson: false,
  // 	// 		isExtra,
  // 	// 		selection: [],
  // 	// 	});
  // 	// }
  // 	let orderByOrig = typeof config.orderBy === 'function'
  // 		? config.orderBy(aliasedFields, orderByOperators)
  // 		: config.orderBy ?? [];
  // 	if (!Array.isArray(orderByOrig)) {
  // 		orderByOrig = [orderByOrig];
  // 	}
  // 	const orderBy = orderByOrig.map((orderByValue) => {
  // 		if (is(orderByValue, Column)) {
  // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
  // 		}
  // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
  // 	});
  // 	const limit = isInnermostQuery ? config.limit : undefined;
  // 	const offset = isInnermostQuery ? config.offset : undefined;
  // 	// For non-root queries without additional config except columns, return a table with selection
  // 	if (
  // 		!isRoot
  // 		&& initiallySelectedRelations.length === 0
  // 		&& selectedExtras.length === 0
  // 		&& !where
  // 		&& orderBy.length === 0
  // 		&& limit === undefined
  // 		&& offset === undefined
  // 	) {
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection: selectedColumns.map((key) => ({
  // 				dbKey: tableConfig.columns[key]!.name,
  // 				tsKey: key,
  // 				field: tableConfig.columns[key] as PgColumn,
  // 				relationTableTsKey: undefined,
  // 				isJson: false,
  // 				selection: [],
  // 			})),
  // 		};
  // 	}
  // 	const selectedRelationsWithoutPK:
  // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of initiallySelectedRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length > 0) {
  // 			continue;
  // 		}
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithoutPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 			nestedQueryRelation: relation,
  // 		});
  // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
  // 		joins.push({
  // 			on: sql`true`,
  // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: true,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
  // 		is(r.relation, One)
  // 	);
  // 	// Process all One relations with PKs, because they can all be joined on the same level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of oneRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length === 0) {
  // 			continue;
  // 		}
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
  // 			sql.join(
  // 				builtRelation.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelation.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: is(builtRelation.sql, SQL)
  // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
  // 				: aliasedTable(builtRelation.sql, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: is(builtRelation.sql, SQL),
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	let distinct: PgSelectConfig['distinct'];
  // 	let tableFrom: PgTable | Subquery = table;
  // 	// Process first Many relation - each one requires a nested subquery
  // 	const manyRelation = manyRelations[0];
  // 	if (manyRelation) {
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			relation,
  // 		} = manyRelation;
  // 		distinct = {
  // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
  // 		};
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const builtRelationSelectionField = sql`case when ${
  // 			sql.identifier(relationTableAlias)
  // 		} is null then '[]' else json_agg(json_build_array(${
  // 			sql.join(
  // 				builtRelationJoin.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: isLateralJoin
  // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
  // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: isLateralJoin,
  // 		});
  // 		// Build the "from" subquery with the remaining Many relations
  // 		const builtTableFrom = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table,
  // 			tableConfig,
  // 			queryConfig: {
  // 				...config,
  // 				where: undefined,
  // 				orderBy: undefined,
  // 				limit: undefined,
  // 				offset: undefined,
  // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
  // 					(result, { tsKey, queryConfig: configValue }) => {
  // 						result[tsKey] = configValue;
  // 						return result;
  // 					},
  // 					{},
  // 				),
  // 			},
  // 			tableAlias,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field: builtRelationSelectionField,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelationJoin.selection,
  // 		});
  // 		// selection = builtTableFrom.selection.map((item) =>
  // 		// 	is(item.field, SQL.Aliased)
  // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 		// 		: item
  // 		// );
  // 		// selectionForBuild = [{
  // 		// 	dbKey: '*',
  // 		// 	tsKey: '*',
  // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
  // 		// 	selection: [],
  // 		// 	isJson: false,
  // 		// 	relationTableTsKey: undefined,
  // 		// }];
  // 		// const newSelectionItem: (typeof selection)[number] = {
  // 		// 	dbKey: selectedRelationTsKey,
  // 		// 	tsKey: selectedRelationTsKey,
  // 		// 	field,
  // 		// 	relationTableTsKey: relationTableTsName,
  // 		// 	isJson: true,
  // 		// 	selection: builtRelationJoin.selection,
  // 		// };
  // 		// selection.push(newSelectionItem);
  // 		// selectionForBuild.push(newSelectionItem);
  // 		tableFrom = is(builtTableFrom.sql, PgTable)
  // 			? builtTableFrom.sql
  // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
  // 	}
  // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
  // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
  // 	}
  // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
  // 	function prepareSelectedColumns() {
  // 		return selectedColumns.map((key) => ({
  // 			dbKey: tableConfig.columns[key]!.name,
  // 			tsKey: key,
  // 			field: tableConfig.columns[key] as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	function prepareSelectedExtras() {
  // 		return selectedExtras.map((item) => ({
  // 			dbKey: item.value.fieldAlias,
  // 			tsKey: item.tsKey,
  // 			field: item.value,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	if (isRoot) {
  // 		selection = [
  // 			...prepareSelectedColumns(),
  // 			...prepareSelectedExtras(),
  // 		];
  // 	}
  // 	if (hasUserDefinedWhere || orderBy.length > 0) {
  // 		tableFrom = new Subquery(
  // 			this.buildSelectQuery({
  // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 				fields: {},
  // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 					path: [],
  // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 				})),
  // 				joins,
  // 				distinct,
  // 			}),
  // 			{},
  // 			tableAlias,
  // 		);
  // 		selectionForBuild = selection.map((item) =>
  // 			is(item.field, SQL.Aliased)
  // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 				: item
  // 		);
  // 		joins = [];
  // 		distinct = undefined;
  // 	}
  // 	const result = this.buildSelectQuery({
  // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 		fields: {},
  // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 			path: [],
  // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 		})),
  // 		where,
  // 		limit,
  // 		offset,
  // 		joins,
  // 		orderBy,
  // 		distinct,
  // 	});
  // 	return {
  // 		tableTsKey: tableConfig.tsName,
  // 		sql: result,
  // 		selection,
  // 	};
  // }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema: schema4,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
      );
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c3) => config.columns?.[c3] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema4, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i2) => eq(
              aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema: schema4,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema4[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(
        selection.map(
          ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
_a65 = entityKind;
__publicField(PgDialect, _a65, "PgDialect");

// ../node_modules/drizzle-orm/pg-core/query-builders/select.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/query-builders/query-builder.js
init_checked_fetch();
init_modules_watch_stub();
var _a66;
var TypedQueryBuilder = class {
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};
_a66 = entityKind;
__publicField(TypedQueryBuilder, _a66, "TypedQueryBuilder");

// ../node_modules/drizzle-orm/selection-proxy.js
init_checked_fetch();
init_modules_watch_stub();
var _a67;
var _SelectionProxyHandler = class {
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery[SubqueryConfig],
        selection: new Proxy(
          subquery[SubqueryConfig].selection,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value,
          new ColumnAliasProxyHandler(
            new Proxy(
              value.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};
var SelectionProxyHandler = _SelectionProxyHandler;
_a67 = entityKind;
__publicField(SelectionProxyHandler, _a67, "SelectionProxyHandler");

// ../node_modules/drizzle-orm/pg-core/query-builders/select.js
var _a68;
var PgSelectBuilder = class {
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  /**
   * Specify the table, subquery, or other target that you're
   * building a select query against.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
   */
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]])
      );
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
_a68 = entityKind;
__publicField(PgSelectBuilder, _a68, "PgSelectBuilder");
var _a69;
var PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on2) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on2 === "function") {
        on2 = on2(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on: on2, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   * 
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   * 
   * @param table the table to join.
   * @param on the `on` clause.
   * 
   * @example
   * 
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * 
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left");
  /**
   * Executes a `right join` operation by adding another table to the current query.
   * 
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   * 
   * @param table the table to join.
   * @param on the `on` clause.
   * 
   * @example
   * 
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * 
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right");
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   * 
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   * 
   * @param table the table to join.
   * @param on the `on` clause.
   * 
   * @example
   * 
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * 
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner");
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   * 
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   * 
   * @param table the table to join.
   * @param on the `on` clause.
   * 
   * @example
   * 
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * 
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   * 
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   * 
   * @example
   * 
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/pg-core'
   * 
   * await union(
   *   db.select({ name: users.name }).from(users), 
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   * 
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   * 
   * @example
   * 
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/pg-core'
   * 
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   * 
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   * 
   * @example
   * 
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/pg-core'
   * 
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `intersect all` set operator to the query.
   * 
   * Calling this method will retain only the rows that are present in both result sets including all duplicates.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
   * 
   * @example
   * 
   * ```ts
   * // Select all products and quantities that are ordered by both regular and VIP customers
   * await db.select({ 
   *   productId: regularCustomerOrders.productId, 
   *   quantityOrdered: regularCustomerOrders.quantityOrdered
   * })
   * .from(regularCustomerOrders)
   * .intersectAll(
   *   db.select({ 
   *     productId: vipCustomerOrders.productId, 
   *     quantityOrdered: vipCustomerOrders.quantityOrdered 
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { intersectAll } from 'drizzle-orm/pg-core'
   * 
   * await intersectAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  intersectAll = this.createSetOperator("intersect", true);
  /**
   * Adds `except` set operator to the query.
   * 
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   * 
   * @example
   * 
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/pg-core'
   * 
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /**
   * Adds `except all` set operator to the query.
   * 
   * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
   * 
   * @example
   * 
   * ```ts
   * // Select all products that are ordered by regular customers but not by VIP customers
   * await db.select({
   *   productId: regularCustomerOrders.productId,
   *   quantityOrdered: regularCustomerOrders.quantityOrdered,
   * })
   * .from(regularCustomerOrders)
   * .exceptAll(
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered,
   *   })
   *   .from(vipCustomerOrders)
   * );
   * // or
   * import { exceptAll } from 'drizzle-orm/pg-core'
   * 
   * await exceptAll(
   *   db.select({
   *     productId: regularCustomerOrders.productId,
   *     quantityOrdered: regularCustomerOrders.quantityOrdered
   *   })
   *   .from(regularCustomerOrders),
   *   db.select({
   *     productId: vipCustomerOrders.productId,
   *     quantityOrdered: vipCustomerOrders.quantityOrdered
   *   })
   *   .from(vipCustomerOrders)
   * );
   * ```
   */
  exceptAll = this.createSetOperator("except", true);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /** 
   * Adds a `where` clause to the query.
   * 
   * Calling this method will select only those rows that fulfill a specified condition.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   * 
   * @param where the `where` clause.
   * 
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   * 
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   * 
   * You can logically combine conditional operators with `and()` and `or()` operators:
   * 
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   * 
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
  */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   * 
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   * 
   * @param having the `having` clause.
   * 
   * @example
   * 
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   * 
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   * 
   * @param limit the `limit` clause.
   * 
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   * 
   * Calling this method will skip a number of rows when returning results from this query.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   * 
   * @param offset the `offset` clause.
   * 
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /**
   * Adds a `for` clause to the query.
   * 
   * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
   * 
   * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
   * 
   * @param strength the lock strength.
   * @param config the lock configuration.
   */
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias),
      new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
};
_a69 = entityKind;
__publicField(PgSelectQueryBuilderBase, _a69, "PgSelectQueryBuilder");
var _a70;
var PgSelectBase = class extends PgSelectQueryBuilderBase {
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  /**
   * Create a prepared statement for this query. This allows
   * the database to remember this query for the given session
   * and call it by name, rather than specifying the full query.
   *
   * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
   */
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
_a70 = entityKind;
__publicField(PgSelectBase, _a70, "PgSelect");
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var _a71;
var QueryBuilder = class {
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on2, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: { on: on2 }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on2, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on: on2 }
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect();
    }
    return this.dialect;
  }
};
_a71 = entityKind;
__publicField(QueryBuilder, _a71, "PgQueryBuilder");

// ../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
init_checked_fetch();
init_modules_watch_stub();
var _a72;
var PgRefreshMaterializedView = class extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  config;
  concurrently() {
    if (this.config.withNoData !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== void 0) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
_a72 = entityKind;
__publicField(PgRefreshMaterializedView, _a72, "PgRefreshMaterializedView");

// ../node_modules/drizzle-orm/pg-core/query-builders/update.js
init_checked_fetch();
init_modules_watch_stub();
var _a73;
var PgUpdateBuilder = class {
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  set(values) {
    return new PgUpdateBase(
      this.table,
      mapUpdateSet(this.table, values),
      this.session,
      this.dialect
    );
  }
};
_a73 = entityKind;
__publicField(PgUpdateBuilder, _a73, "PgUpdateBuilder");
var _a74;
var PgUpdateBase = class extends QueryPromise {
  constructor(table, set2, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table };
  }
  config;
  /**
   * Adds a 'where' clause to the query.
   * 
   * Calling this method will update only those rows that fulfill a specified condition.
   * 
   * See docs: {@link https://orm.drizzle.team/docs/update}
   * 
   * @param where the 'where' clause.
   * 
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   * 
   * ```ts
   * // Update all cars with green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * await db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   * 
   * You can logically combine conditional operators with `and()` and `or()` operators:
   * 
   * ```ts
   * // Update all BMW cars with a green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   * 
   * // Update all cars with the green or blue color
   * await db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
};
_a74 = entityKind;
__publicField(PgUpdateBase, _a74, "PgUpdate");

// ../node_modules/drizzle-orm/pg-core/query-builders/query.js
init_checked_fetch();
init_modules_watch_stub();
var _a75;
var RelationalQueryBuilder = class {
  constructor(fullSchema, schema4, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema4;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  findMany(config) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config ? config : {},
      "many"
    );
  }
  findFirst(config) {
    return new PgRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config ? { ...config, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
_a75 = entityKind;
__publicField(RelationalQueryBuilder, _a75, "PgRelationalQueryBuilder");
var _a76;
var PgRelationalQuery = class extends QueryPromise {
  constructor(fullSchema, schema4, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema4;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(
        builtQuery,
        void 0,
        name,
        (rawRows, mapColumnValue) => {
          const rows = rawRows.map(
            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
          );
          if (this.mode === "first") {
            return rows[0];
          }
          return rows;
        }
      );
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  /** @internal */
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
};
_a76 = entityKind;
__publicField(PgRelationalQuery, _a76, "PgRelationalQuery");

// ../node_modules/drizzle-orm/pg-core/db.js
var _a77;
var PgDatabase = class {
  constructor(dialect, session, schema4) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema4 ? { schema: schema4.schema, tableNamesMap: schema4.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          schema4.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema4.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    return { select };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on2, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on: on2 }
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query) {
    return this.session.execute(query.getSQL());
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
};
_a77 = entityKind;
__publicField(PgDatabase, _a77, "PgDatabase");

// ../node_modules/drizzle-orm/neon-http/session.js
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/drizzle-orm/pg-core/indexes.js
init_checked_fetch();
init_modules_watch_stub();
var _a78;
var IndexBuilderOn = class {
  constructor(unique2, name) {
    this.unique = unique2;
    this.name = name;
  }
  on(...columns) {
    return new IndexBuilder(columns, this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns, this.unique, true, this.name);
  }
};
_a78 = entityKind;
__publicField(IndexBuilderOn, _a78, "PgIndexBuilderOn");
var _a79;
var IndexBuilder = class {
  /** @internal */
  config;
  constructor(columns, unique2, only, name) {
    this.config = {
      name,
      columns,
      unique: unique2,
      only
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  using(method) {
    this.config.using = method;
    return this;
  }
  asc() {
    this.config.order = "asc";
    return this;
  }
  desc() {
    this.config.order = "desc";
    return this;
  }
  nullsFirst() {
    this.config.nulls = "first";
    return this;
  }
  nullsLast() {
    this.config.nulls = "last";
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index(this.config, table);
  }
};
_a79 = entityKind;
__publicField(IndexBuilder, _a79, "PgIndexBuilder");
var _a80;
var Index = class {
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
};
_a80 = entityKind;
__publicField(Index, _a80, "PgIndex");
function index(name) {
  return new IndexBuilderOn(false, name);
}

// ../node_modules/drizzle-orm/pg-core/session.js
init_checked_fetch();
init_modules_watch_stub();
var _a81;
var PreparedQuery = class {
  /** @internal */
  joinsNotNullableMap;
};
_a81 = entityKind;
__publicField(PreparedQuery, _a81, "PgPreparedQuery");
var _a82;
var PgSession = class {
  constructor(dialect) {
    this.dialect = dialect;
  }
  execute(query) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0
        );
      });
      return prepared.execute();
    });
  }
  all(query) {
    return this.prepareQuery(
      this.dialect.sqlToQuery(query),
      void 0,
      void 0
    ).all();
  }
};
_a82 = entityKind;
__publicField(PgSession, _a82, "PgSession");
var _a83;
var PgTransaction = class extends PgDatabase {
  constructor(dialect, session, schema4, nestedIndex = 0) {
    super(dialect, session, schema4);
    this.schema = schema4;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
  /** @internal */
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
};
_a83 = entityKind;
__publicField(PgTransaction, _a83, "PgTransaction");

// ../node_modules/drizzle-orm/neon-http/session.js
var _a84;
var NeonHttpPreparedQuery = class extends PreparedQuery {
  constructor(client, queryString, params, logger, fields, name, customResultMapper) {
    super();
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this.name = name;
    this.customResultMapper = customResultMapper;
    this.rawQuery = {
      arrayMode: false,
      fullResults: true
    };
    this.query = { arrayMode: true, fullResults: true };
  }
  rawQuery;
  query;
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    const { fields, client, queryString, query, rawQuery, joinsNotNullableMap, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return client(queryString, params, rawQuery);
    }
    const result = await client(queryString, params, query);
    return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    return this.client(this.queryString, params, this.rawQuery).then((result) => result.rows);
  }
  values(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    return this.client(this.queryString, params).then((result) => result.rows);
  }
};
_a84 = entityKind;
__publicField(NeonHttpPreparedQuery, _a84, "NeonHttpPreparedQuery");
var _a85;
var NeonHttpSession = class extends PgSession {
  constructor(client, dialect, schema4, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema4;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
  }
  logger;
  prepareQuery(query, fields, name, customResultMapper) {
    return new NeonHttpPreparedQuery(
      this.client,
      query.sql,
      query.params,
      this.logger,
      fields,
      name,
      customResultMapper
    );
  }
  // change return type to QueryRows<true>
  async query(query, params) {
    this.logger.logQuery(query, params);
    const result = await this.client(query, params, { arrayMode: true });
    return result;
  }
  // change return type to QueryRows<false>
  async queryObjects(query, params) {
    return this.client(query, params);
  }
  async transaction(_transaction, _config = {}) {
    throw new Error("No transactions support in neon-http driver");
  }
};
_a85 = entityKind;
__publicField(NeonHttpSession, _a85, "NeonHttpSession");
var _a86;
var NeonTransaction = class extends PgTransaction {
  async transaction(_transaction) {
    throw new Error("No transactions support in neon-http driver");
  }
};
_a86 = entityKind;
__publicField(NeonTransaction, _a86, "NeonHttpTransaction");

// ../node_modules/drizzle-orm/neon-http/driver.js
var _a87;
var NeonHttpDriver = class {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
    this.initMappers();
  }
  createSession(schema4) {
    return new NeonHttpSession(this.client, this.dialect, schema4, { logger: this.options.logger });
  }
  initMappers() {
    export_types.setTypeParser(export_types.builtins.TIMESTAMPTZ, (val) => val);
    export_types.setTypeParser(export_types.builtins.TIMESTAMP, (val) => val);
    export_types.setTypeParser(export_types.builtins.DATE, (val) => val);
  }
};
_a87 = entityKind;
__publicField(NeonHttpDriver, _a87, "NeonDriver");
function drizzle(client, config = {}) {
  const dialect = new PgDialect();
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema4;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config.schema,
      createTableRelationsHelpers
    );
    schema4 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NeonHttpDriver(client, dialect, { logger });
  const session = driver.createSession(schema4);
  return new PgDatabase(dialect, session, schema4);
}

// lib/schema.ts
var schema_exports = {};
__export(schema_exports, {
  channel: () => channel,
  conversation: () => conversation,
  conversationRelations: () => conversationRelations,
  slackConnection: () => slackConnection,
  slackOauthState: () => slackOauthState,
  zendeskConnection: () => zendeskConnection
});
init_checked_fetch();
init_modules_watch_stub();
var slackOauthState = pgTable("slack_oauth_states", {
  id: uuid("id").primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true
  }).defaultNow().notNull()
});
var slackConnection = pgTable("slack_connections", {
  id: uuid("id").defaultRandom().primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true
  }).defaultNow().notNull(),
  updatedAt: timestamp2("updated_at", {
    mode: "date",
    withTimezone: true
  }),
  slackTeamId: text("slack_team_id").notNull().unique(),
  name: text("name"),
  domain: text("domain"),
  emailDomain: text("email_domain"),
  iconUrl: text("icon_url"),
  slackEnterpriseId: text("slack_enterprise_id"),
  slackEnterpriseName: text("slack_enterprise_name"),
  token: text("token").notNull(),
  authedUserId: text("authed_user_id"),
  botUserId: text("bot_user_id").notNull(),
  status: text("status")
});
var zendeskConnection = pgTable("zendesk_connections", {
  id: uuid("id").defaultRandom().primaryKey().notNull(),
  createdAt: timestamp2("created_at", {
    mode: "date",
    withTimezone: true
  }).defaultNow().notNull(),
  updatedAt: timestamp2("updated_at", {
    mode: "date",
    withTimezone: true
  }),
  slackConnectionId: uuid("slack_connection_id").notNull().unique().references(() => slackConnection.id, {
    onDelete: "cascade"
  }),
  zendeskDomain: text("zendesk_domain").notNull(),
  zendeskEmail: text("zendesk_email").notNull(),
  zendeskApiKey: text("zendesk_api_key").notNull(),
  zendeskTriggerId: text("zendesk_trigger_id"),
  zendeskWebhookId: text("zendesk_webhook_id"),
  webhookBearerToken: text("webhook_bearer_token").unique(),
  status: text("status")
});
var channel = pgTable(
  "channels",
  {
    id: uuid("id").defaultRandom().defaultRandom().primaryKey().notNull(),
    createdAt: timestamp2("created_at", {
      mode: "date",
      withTimezone: true
    }).defaultNow().notNull(),
    updatedAt: timestamp2("updated_at", {
      mode: "date",
      withTimezone: true
    }),
    slackChannelIdentifier: text("slack_channel_identifier").notNull(),
    slackConnectionId: uuid("slack_connection_id").notNull().references(() => slackConnection.id, { onDelete: "cascade" }),
    type: text("type"),
    isMember: boolean("is_member"),
    name: text("name"),
    isShared: boolean("is_shared"),
    defaultAssigneeEmail: text("default_assignee_email"),
    latestActivityAt: timestamp2("latest_activity_at", {
      mode: "date",
      withTimezone: true
    }),
    tags: text("tags").array()
  },
  (table) => ({
    channels_slack_connection_slack_channel_unique: unique().on(
      table.slackConnectionId,
      table.slackChannelIdentifier
    ),
    idx_channels_slack_connection_is_member: index().on(
      table.slackConnectionId,
      table.isMember
    )
  })
);
var conversation = pgTable(
  "conversations",
  {
    id: uuid("id").defaultRandom().defaultRandom().primaryKey().notNull(),
    createdAt: timestamp2("created_at", {
      mode: "date",
      withTimezone: true
    }).defaultNow().notNull(),
    updatedAt: timestamp2("updated_at", {
      mode: "date",
      withTimezone: true
    }),
    channelId: uuid("channel_id").notNull().references(() => channel.id, { onDelete: "cascade" }),
    zendeskTicketId: text("zendesk_ticket_id").notNull(),
    slackParentMessageId: text("slack_parent_message_id").notNull(),
    slackAuthorUserId: text("slack_author_user_id").notNull(),
    latestSlackMessageId: text("latest_slack_message_id")
  },
  (table) => ({
    conversations_channel_zendesk_ticket_unique: unique().on(
      table.channelId,
      table.zendeskTicketId
    ),
    conversations_channel_slack_message_unique: unique().on(
      table.channelId,
      table.slackParentMessageId
    )
  })
);
var conversationRelations = relations(conversation, ({ one }) => ({
  channel: one(channel, {
    fields: [conversation.channelId],
    references: [channel.id]
  })
}));

// lib/drizzle.ts
function initializeDb(env) {
  const sql2 = Ys(env.POSTGRES_URL);
  const db = drizzle(sql2, { schema: schema_exports });
  return db;
}

// node_modules/@logtail/edge/dist/es6/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@logtail/edge/dist/es6/edge.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs
init_checked_fetch();
init_modules_watch_stub();
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  var high = view.getInt32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs
var _a88;
var _b;
var _c;
var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a88 = process === null || process === void 0 ? void 0 : process.env) === null || _a88 === void 0 ? void 0 : _a88["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
function utf8EncodeTEencode(str, output, outputOffset) {
  output.set(sharedTextEncoder.encode(str), outputOffset);
}
function utf8EncodeTEencodeInto(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs
init_checked_fetch();
init_modules_watch_stub();
var ExtData = (
  /** @class */
  function() {
    function ExtData2(type, data) {
      this.type = type;
      this.data = data;
    }
    return ExtData2;
  }()
);

// node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs
init_checked_fetch();
init_modules_watch_stub();
var __extends = function() {
  var extendStatics = function(d4, b3) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
      d5.__proto__ = b4;
    } || function(d5, b4) {
      for (var p4 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p4))
          d5[p4] = b4[p4];
    };
    return extendStatics(d4, b3);
  };
  return function(d4, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d4, b3);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var DecodeError = (
  /** @class */
  function(_super) {
    __extends(DecodeError2, _super);
    function DecodeError2(message3) {
      var _this = _super.call(this, message3) || this;
      var proto = Object.create(DecodeError2.prototype);
      Object.setPrototypeOf(_this, proto);
      Object.defineProperty(_this, "name", {
        configurable: true,
        enumerable: false,
        value: DecodeError2.name
      });
      return _this;
    }
    return DecodeError2;
  }(Error)
);

// node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp(_a89) {
  var sec = _a89.sec, nsec = _a89.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs
var ExtensionCodec = (
  /** @class */
  function() {
    function ExtensionCodec2() {
      this.builtInEncoders = [];
      this.builtInDecoders = [];
      this.encoders = [];
      this.decoders = [];
      this.register(timestampExtension);
    }
    ExtensionCodec2.prototype.register = function(_a89) {
      var type = _a89.type, encode4 = _a89.encode, decode3 = _a89.decode;
      if (type >= 0) {
        this.encoders[type] = encode4;
        this.decoders[type] = decode3;
      } else {
        var index2 = 1 + type;
        this.builtInEncoders[index2] = encode4;
        this.builtInDecoders[index2] = decode3;
      }
    };
    ExtensionCodec2.prototype.tryToEncode = function(object, context) {
      for (var i2 = 0; i2 < this.builtInEncoders.length; i2++) {
        var encodeExt = this.builtInEncoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = -1 - i2;
            return new ExtData(type, data);
          }
        }
      }
      for (var i2 = 0; i2 < this.encoders.length; i2++) {
        var encodeExt = this.encoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = i2;
            return new ExtData(type, data);
          }
        }
      }
      if (object instanceof ExtData) {
        return object;
      }
      return null;
    };
    ExtensionCodec2.prototype.decode = function(data, type, context) {
      var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
      if (decodeExt) {
        return decodeExt(data, type, context);
      } else {
        return new ExtData(type, data);
      }
    };
    ExtensionCodec2.defaultCodec = new ExtensionCodec2();
    return ExtensionCodec2;
  }()
);

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs
init_checked_fetch();
init_modules_watch_stub();
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}

// node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = (
  /** @class */
  function() {
    function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
      if (extensionCodec === void 0) {
        extensionCodec = ExtensionCodec.defaultCodec;
      }
      if (context === void 0) {
        context = void 0;
      }
      if (maxDepth === void 0) {
        maxDepth = DEFAULT_MAX_DEPTH;
      }
      if (initialBufferSize === void 0) {
        initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;
      }
      if (sortKeys === void 0) {
        sortKeys = false;
      }
      if (forceFloat32 === void 0) {
        forceFloat32 = false;
      }
      if (ignoreUndefined === void 0) {
        ignoreUndefined = false;
      }
      if (forceIntegerToFloat === void 0) {
        forceIntegerToFloat = false;
      }
      this.extensionCodec = extensionCodec;
      this.context = context;
      this.maxDepth = maxDepth;
      this.initialBufferSize = initialBufferSize;
      this.sortKeys = sortKeys;
      this.forceFloat32 = forceFloat32;
      this.ignoreUndefined = ignoreUndefined;
      this.forceIntegerToFloat = forceIntegerToFloat;
      this.pos = 0;
      this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
      this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder2.prototype.reinitializeState = function() {
      this.pos = 0;
    };
    Encoder2.prototype.encodeSharedRef = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.subarray(0, this.pos);
    };
    Encoder2.prototype.encode = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.slice(0, this.pos);
    };
    Encoder2.prototype.doEncode = function(object, depth) {
      if (depth > this.maxDepth) {
        throw new Error("Too deep objects in depth ".concat(depth));
      }
      if (object == null) {
        this.encodeNil();
      } else if (typeof object === "boolean") {
        this.encodeBoolean(object);
      } else if (typeof object === "number") {
        this.encodeNumber(object);
      } else if (typeof object === "string") {
        this.encodeString(object);
      } else {
        this.encodeObject(object, depth);
      }
    };
    Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
      var requiredSize = this.pos + sizeToWrite;
      if (this.view.byteLength < requiredSize) {
        this.resizeBuffer(requiredSize * 2);
      }
    };
    Encoder2.prototype.resizeBuffer = function(newSize) {
      var newBuffer = new ArrayBuffer(newSize);
      var newBytes = new Uint8Array(newBuffer);
      var newView = new DataView(newBuffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    };
    Encoder2.prototype.encodeNil = function() {
      this.writeU8(192);
    };
    Encoder2.prototype.encodeBoolean = function(object) {
      if (object === false) {
        this.writeU8(194);
      } else {
        this.writeU8(195);
      }
    };
    Encoder2.prototype.encodeNumber = function(object) {
      if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
        if (object >= 0) {
          if (object < 128) {
            this.writeU8(object);
          } else if (object < 256) {
            this.writeU8(204);
            this.writeU8(object);
          } else if (object < 65536) {
            this.writeU8(205);
            this.writeU16(object);
          } else if (object < 4294967296) {
            this.writeU8(206);
            this.writeU32(object);
          } else {
            this.writeU8(207);
            this.writeU64(object);
          }
        } else {
          if (object >= -32) {
            this.writeU8(224 | object + 32);
          } else if (object >= -128) {
            this.writeU8(208);
            this.writeI8(object);
          } else if (object >= -32768) {
            this.writeU8(209);
            this.writeI16(object);
          } else if (object >= -2147483648) {
            this.writeU8(210);
            this.writeI32(object);
          } else {
            this.writeU8(211);
            this.writeI64(object);
          }
        }
      } else {
        if (this.forceFloat32) {
          this.writeU8(202);
          this.writeF32(object);
        } else {
          this.writeU8(203);
          this.writeF64(object);
        }
      }
    };
    Encoder2.prototype.writeStringHeader = function(byteLength) {
      if (byteLength < 32) {
        this.writeU8(160 + byteLength);
      } else if (byteLength < 256) {
        this.writeU8(217);
        this.writeU8(byteLength);
      } else if (byteLength < 65536) {
        this.writeU8(218);
        this.writeU16(byteLength);
      } else if (byteLength < 4294967296) {
        this.writeU8(219);
        this.writeU32(byteLength);
      } else {
        throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
      }
    };
    Encoder2.prototype.encodeString = function(object) {
      var maxHeaderSize = 1 + 4;
      var strLength = object.length;
      if (strLength > TEXT_ENCODER_THRESHOLD) {
        var byteLength = utf8Count(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        utf8EncodeTE(object, this.bytes, this.pos);
        this.pos += byteLength;
      } else {
        var byteLength = utf8Count(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        utf8EncodeJs(object, this.bytes, this.pos);
        this.pos += byteLength;
      }
    };
    Encoder2.prototype.encodeObject = function(object, depth) {
      var ext = this.extensionCodec.tryToEncode(object, this.context);
      if (ext != null) {
        this.encodeExtension(ext);
      } else if (Array.isArray(object)) {
        this.encodeArray(object, depth);
      } else if (ArrayBuffer.isView(object)) {
        this.encodeBinary(object);
      } else if (typeof object === "object") {
        this.encodeMap(object, depth);
      } else {
        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
      }
    };
    Encoder2.prototype.encodeBinary = function(object) {
      var size = object.byteLength;
      if (size < 256) {
        this.writeU8(196);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(197);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(198);
        this.writeU32(size);
      } else {
        throw new Error("Too large binary: ".concat(size));
      }
      var bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeArray = function(object, depth) {
      var size = object.length;
      if (size < 16) {
        this.writeU8(144 + size);
      } else if (size < 65536) {
        this.writeU8(220);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(221);
        this.writeU32(size);
      } else {
        throw new Error("Too large array: ".concat(size));
      }
      for (var _i2 = 0, object_1 = object; _i2 < object_1.length; _i2++) {
        var item = object_1[_i2];
        this.doEncode(item, depth + 1);
      }
    };
    Encoder2.prototype.countWithoutUndefined = function(object, keys) {
      var count = 0;
      for (var _i2 = 0, keys_1 = keys; _i2 < keys_1.length; _i2++) {
        var key = keys_1[_i2];
        if (object[key] !== void 0) {
          count++;
        }
      }
      return count;
    };
    Encoder2.prototype.encodeMap = function(object, depth) {
      var keys = Object.keys(object);
      if (this.sortKeys) {
        keys.sort();
      }
      var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
      if (size < 16) {
        this.writeU8(128 + size);
      } else if (size < 65536) {
        this.writeU8(222);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(223);
        this.writeU32(size);
      } else {
        throw new Error("Too large map object: ".concat(size));
      }
      for (var _i2 = 0, keys_2 = keys; _i2 < keys_2.length; _i2++) {
        var key = keys_2[_i2];
        var value = object[key];
        if (!(this.ignoreUndefined && value === void 0)) {
          this.encodeString(key);
          this.doEncode(value, depth + 1);
        }
      }
    };
    Encoder2.prototype.encodeExtension = function(ext) {
      var size = ext.data.length;
      if (size === 1) {
        this.writeU8(212);
      } else if (size === 2) {
        this.writeU8(213);
      } else if (size === 4) {
        this.writeU8(214);
      } else if (size === 8) {
        this.writeU8(215);
      } else if (size === 16) {
        this.writeU8(216);
      } else if (size < 256) {
        this.writeU8(199);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(200);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(201);
        this.writeU32(size);
      } else {
        throw new Error("Too large extension object: ".concat(size));
      }
      this.writeI8(ext.type);
      this.writeU8a(ext.data);
    };
    Encoder2.prototype.writeU8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setUint8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU8a = function(values) {
      var size = values.length;
      this.ensureBufferSizeToWrite(size);
      this.bytes.set(values, this.pos);
      this.pos += size;
    };
    Encoder2.prototype.writeI8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setInt8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setUint16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeI16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setInt16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeU32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setUint32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeI32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setInt32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setFloat32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setFloat64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeU64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setUint64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeI64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setInt64(this.view, this.pos, value);
      this.pos += 8;
    };
    return Encoder2;
  }()
);

// node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs
var defaultEncodeOptions = {};
function encode(value, options) {
  if (options === void 0) {
    options = defaultEncodeOptions;
  }
  var encoder2 = new Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
  return encoder2.encodeSharedRef(value);
}

// node_modules/@logtail/types/dist/es6/types.js
init_checked_fetch();
init_modules_watch_stub();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["Error"] = "error";
  LogLevel2["Warn"] = "warn";
  LogLevel2["Info"] = "info";
  LogLevel2["Debug"] = "debug";
  LogLevel2["Fatal"] = "fatal";
  LogLevel2["Http"] = "http";
  LogLevel2["Verbose"] = "verbose";
  LogLevel2["Silly"] = "silly";
  LogLevel2["Trace"] = "trace";
})(LogLevel || (LogLevel = {}));

// node_modules/@logtail/core/dist/es6/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@logtail/core/dist/es6/base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@logtail/tools/dist/es6/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@logtail/tools/dist/es6/queue.js
init_checked_fetch();
init_modules_watch_stub();
var Queue = class {
  constructor() {
    this.length = 0;
  }
  /**
   * Pushes a value into the queue.
   * @param value - Any object to push into the queue
   */
  push(value) {
    const node = { value };
    this.last = this.last ? this.last.next = node : this.first = node;
    this.length++;
  }
  /**
   * Remove a value from the start of the queue (FIFO) and return it
   */
  shift() {
    if (this.first) {
      const { value } = this.first;
      this.first = this.first.next;
      if (!--this.length) {
        this.last = void 0;
      }
      return value;
    }
  }
};

// node_modules/@logtail/tools/dist/es6/batch.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_BUFFER_SIZE = 1e3;
var DEFAULT_FLUSH_TIMEOUT = 1e3;
var DEFAULT_RETRY_COUNT = 3;
var DEFAULT_RETRY_BACKOFF = 100;
var calculateJsonLogSizeBytes = (log) => JSON.stringify(log).length + 1;
function makeBatch(size = DEFAULT_BUFFER_SIZE, flushTimeout = DEFAULT_FLUSH_TIMEOUT, retryCount = DEFAULT_RETRY_COUNT, retryBackoff = DEFAULT_RETRY_BACKOFF, sizeBytes = 0, calculateLogSizeBytes = calculateJsonLogSizeBytes) {
  let timeout;
  let cb;
  let buffer = [];
  let bufferSizeBytes = 0;
  let retry = 0;
  let minRetryBackoff = 0;
  async function flush() {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = null;
    const currentBuffer = buffer;
    const currentBufferSizeKB = bufferSizeBytes;
    buffer = [];
    bufferSizeBytes = 0;
    try {
      await cb(currentBuffer.map((d4) => d4.log));
      currentBuffer.forEach((d4) => d4.resolve(d4.log));
      retry = 0;
    } catch (e3) {
      if (retry < retryCount) {
        retry++;
        minRetryBackoff = Date.now() + retryBackoff;
        buffer = buffer.concat(currentBuffer);
        bufferSizeBytes += currentBufferSizeKB;
        await setupTimeout();
        return;
      }
      currentBuffer.map((d4) => d4.reject(e3));
      retry = 0;
    }
  }
  async function setupTimeout() {
    if (timeout) {
      return;
    }
    return new Promise((resolve) => {
      timeout = setTimeout(async function() {
        await flush();
        resolve();
      }, flushTimeout);
    });
  }
  return {
    initPusher: function(fn) {
      cb = fn;
      return async function(log) {
        return new Promise(async (resolve, reject) => {
          buffer.push({ log, resolve, reject });
          if (sizeBytes > 0) {
            bufferSizeBytes += calculateLogSizeBytes(log);
          }
          const isBufferFullEnough = buffer.length >= size || sizeBytes > 0 && bufferSizeBytes >= sizeBytes;
          if (isBufferFullEnough && Date.now() > minRetryBackoff) {
            await flush();
          } else {
            await setupTimeout();
          }
          return resolve;
        });
      };
    },
    flush
  };
}

// node_modules/@logtail/tools/dist/es6/burstProtection.js
init_checked_fetch();
init_modules_watch_stub();
var RESOLUTION = 64;
function makeBurstProtection(milliseconds, max, functionName = "The function") {
  if (milliseconds <= 0 || max <= 0) {
    return (fn) => fn;
  }
  let callCounts = [0];
  let lastErrorOutput = 0;
  let lastIntervalTime = Date.now();
  function updateCallCounts() {
    const now = Date.now();
    const intervalLength = milliseconds / RESOLUTION;
    if (now < lastIntervalTime + intervalLength) {
      return;
    }
    const intervalCountSinceLast = Math.floor((now - lastIntervalTime) / intervalLength);
    callCounts = Array(Math.min(intervalCountSinceLast, RESOLUTION)).fill(0).concat(callCounts).slice(0, RESOLUTION);
    lastIntervalTime += intervalCountSinceLast * intervalLength;
  }
  function getTotalCallCount() {
    return callCounts.reduce((total, item) => total + item);
  }
  function incrementCallCount() {
    callCounts[0]++;
  }
  return (fn) => {
    return async (...args) => {
      updateCallCounts();
      if (getTotalCallCount() < max) {
        incrementCallCount();
        return await fn(...args);
      }
      const now = Date.now();
      if (lastErrorOutput < now - milliseconds) {
        lastErrorOutput = now;
        console.error(`${functionName} was called more than ${max} times during last ${milliseconds}ms. Ignoring.`);
      }
    };
  };
}

// node_modules/@logtail/tools/dist/es6/throttle.js
init_checked_fetch();
init_modules_watch_stub();
function makeThrottle(max) {
  let current = 0;
  const queue = new Queue();
  function throttle(fn) {
    return async (...args) => {
      return new Promise((resolve, reject) => {
        async function handler() {
          if (current < max) {
            current++;
            try {
              resolve(await fn(...args));
            } catch (e3) {
              reject(e3);
            }
            current--;
            if (queue.length > 0) {
              queue.shift()();
            }
          } else {
            queue.push(handler);
          }
        }
        return handler();
      });
    };
  }
  return throttle;
}

// node_modules/@logtail/core/dist/es6/base.js
var import_serialize_error = __toESM(require_serialize_error());
var defaultOptions = {
  // Default sync endpoint (protocol + domain)
  endpoint: "https://in.logs.betterstack.com",
  // Maximum number of logs to sync in a single request to Better Stack
  batchSize: 1e3,
  // Size of logs (in KiB) to trigger sync to Better Stack (0 to disable)
  batchSizeKiB: 0,
  // Max interval (in milliseconds) before a batch of logs proceeds to syncing
  batchInterval: 1e3,
  // Maximum number of times to retry a failed sync request
  retryCount: 3,
  // Minimum number of milliseconds to wait before retrying a failed sync request
  retryBackoff: 100,
  // Maximum number of sync requests to make concurrently
  syncMax: 5,
  // Length of the checked window for logs burst protection in milliseconds (0 to disable)
  burstProtectionMilliseconds: 5e3,
  // Maximum number of accepted logs in the specified time window (0 to disable)
  burstProtectionMax: 1e4,
  // If true, errors when sending logs will be ignored
  // Has precedence over throwExceptions
  ignoreExceptions: false,
  // If true, errors when sending logs will result in a thrown exception
  throwExceptions: false,
  // Maximum depth (number of attribute levels) of a context object
  contextObjectMaxDepth: 50,
  // Produce a warn log when context object max depth is reached
  contextObjectMaxDepthWarn: true,
  // Produce a warning when circular reference is found in context object
  contextObjectCircularRefWarn: true,
  // If true, all logs will be sent to standard console output functions (console.info, console.warn, ...)
  sendLogsToConsoleOutput: false,
  // If true, all logs will be sent to Better Stack
  sendLogsToBetterStack: true,
  // Function to be used to calculate size of logs in bytes (to evaluate batchSizeLimitKiB)
  calculateLogSizeBytes: calculateJsonLogSizeBytes
};
var Logtail = class {
  /* CONSTRUCTOR */
  /**
   * Initializes a new Logtail instance
   *
   * @param sourceToken: string - Private source token for logging to Better Stack
   * @param options?: ILogtailOptions - Optionally specify Logtail options
   */
  constructor(sourceToken, options) {
    this._middleware = [];
    this._countLogged = 0;
    this._countSynced = 0;
    this._countDropped = 0;
    if (typeof sourceToken !== "string" || sourceToken === "") {
      throw new Error("Logtail source token missing");
    }
    this._sourceToken = sourceToken;
    this._options = Object.assign(Object.assign({}, defaultOptions), options);
    const throttle = makeThrottle(this._options.syncMax);
    const throttler = throttle((logs) => {
      return this._sync(logs);
    });
    this._logBurstProtection = makeBurstProtection(this._options.burstProtectionMilliseconds, this._options.burstProtectionMax, "Logging");
    this.log = this._logBurstProtection(this.log.bind(this));
    const batcher = makeBatch(this._options.batchSize, this._options.batchInterval, this._options.retryCount, this._options.retryBackoff, this._options.batchSizeKiB * 1024, this._options.calculateLogSizeBytes);
    this._batch = batcher.initPusher((logs) => {
      return throttler(logs);
    });
    this._flush = batcher.flush;
  }
  /* PUBLIC METHODS */
  /**
   * Flush batched logs to Logtail
   */
  async flush() {
    return this._flush();
  }
  /**
   * Number of entries logged
   *
   * @returns number
   */
  get logged() {
    return this._countLogged;
  }
  /**
   * Number of log entries synced with Better Stack
   *
   * @returns number
   */
  get synced() {
    return this._countSynced;
  }
  /**
   * Number of entries dropped
   *
   * @returns number
   */
  get dropped() {
    return this._countDropped;
  }
  /**
   * Log an entry, to be synced with Better Stack
   *
   * @param message: string - Log message
   * @param level (LogLevel) - Level to log at (debug|info|warn|error)
   * @param context: (Context) - Context (optional)
   * @returns Promise<ILogtailLog> after syncing
   */
  async log(message3, level = LogLevel.Info, context = {}) {
    if (typeof context !== "object") {
      const wrappedContext = { extra: context };
      context = wrappedContext;
    }
    if (context instanceof Error) {
      const wrappedContext = { error: context };
      context = wrappedContext;
    }
    if (this._options.sendLogsToConsoleOutput) {
      switch (level) {
        case "debug":
          console.debug(message3, context);
          break;
        case "info":
          console.info(message3, context);
          break;
        case "warn":
          console.warn(message3, context);
          break;
        case "error":
          console.error(message3, context);
          break;
        default:
          console.log(`[${level.toUpperCase()}]`, message3, context);
          break;
      }
    }
    if (typeof this._sync !== "function") {
      throw new Error("No Logtail logger sync function provided");
    }
    this._countLogged++;
    let log = Object.assign(Object.assign({
      // Implicit date timestamp
      dt: /* @__PURE__ */ new Date(),
      // Explicit level
      level
    }, context), message3 instanceof Error ? (0, import_serialize_error.serializeError)(message3) : { message: message3 });
    let transformedLog = log;
    for (const middleware of this._middleware) {
      let newTransformedLog = await middleware(transformedLog);
      if (newTransformedLog == null) {
        return transformedLog;
      }
      transformedLog = newTransformedLog;
    }
    transformedLog = this.serialize(transformedLog, this._options.contextObjectMaxDepth);
    if (!this._options.sendLogsToBetterStack) {
      return transformedLog;
    }
    try {
      await this._batch(transformedLog);
      this._countSynced++;
    } catch (e3) {
      this._countDropped++;
      if (!this._options.ignoreExceptions) {
        if (this._options.throwExceptions) {
          throw e3;
        } else {
          console.error(e3);
        }
      }
    }
    return transformedLog;
  }
  serialize(value, maxDepth, visitedObjects = /* @__PURE__ */ new WeakSet()) {
    if (value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string") {
      return value;
    } else if (value instanceof Date) {
      if (isNaN(value.getTime())) {
        return value.toString();
      }
      return value.toISOString();
    } else if (value instanceof Error) {
      return (0, import_serialize_error.serializeError)(value);
    } else if ((typeof value === "object" || Array.isArray(value)) && (maxDepth < 1 || visitedObjects.has(value))) {
      if (visitedObjects.has(value)) {
        if (this._options.contextObjectCircularRefWarn) {
          console.warn(`[Logtail] Found a circular reference when serializing logs. Please do not use circular references in your logs.`);
        }
        return "<omitted circular reference>";
      }
      if (this._options.contextObjectMaxDepthWarn) {
        console.warn(`[Logtail] Max depth of ${this._options.contextObjectMaxDepth} reached when serializing logs. Please do not use excessive object depth in your logs.`);
      }
      return `<omitted context beyond configured max depth: ${this._options.contextObjectMaxDepth}>`;
    } else if (Array.isArray(value)) {
      visitedObjects.add(value);
      const serializedArray = value.map((item) => this.serialize(item, maxDepth - 1, visitedObjects));
      visitedObjects.delete(value);
      return serializedArray;
    } else if (typeof value === "object") {
      const serializedObject = {};
      visitedObjects.add(value);
      Object.entries(value).forEach((item) => {
        const key = item[0];
        const value2 = item[1];
        const serializedValue = this.serialize(value2, maxDepth - 1, visitedObjects);
        if (serializedValue !== void 0) {
          serializedObject[key] = serializedValue;
        }
      });
      visitedObjects.delete(value);
      return serializedObject;
    } else if (typeof value === "undefined") {
      return void 0;
    } else {
      return `<omitted unserializable ${typeof value}>`;
    }
  }
  /**
   *
   * Debug level log, to be synced with Better Stack
   *
   * @param message: string - Log message
   * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
   * @returns Promise<ILogtailLog> after syncing
   */
  async debug(message3, context = {}) {
    return this.log(message3, LogLevel.Debug, context);
  }
  /**
   *
   * Info level log, to be synced with Better Stack
   *
   * @param message: string - Log message
   * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
   * @returns Promise<ILogtailLog> after syncing
   */
  async info(message3, context = {}) {
    return this.log(message3, LogLevel.Info, context);
  }
  /**
   *
   * Warning level log, to be synced with Better Stack
   *
   * @param message: string - Log message
   * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
   * @returns Promise<ILogtailLog> after syncing
   */
  async warn(message3, context = {}) {
    return this.log(message3, LogLevel.Warn, context);
  }
  /**
   *
   * Warning level log, to be synced with Better Stack
   *
   * @param message: string - Log message
   * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
   * @returns Promise<ILogtailLog> after syncing
   */
  async error(message3, context = {}) {
    return this.log(message3, LogLevel.Error, context);
  }
  /**
   * Sets the sync method - i.e. the final step in the pipeline to get logs
   * over to Better Stack
   *
   * @param fn - Pipeline function to use as sync method
   */
  setSync(fn) {
    this._sync = fn;
  }
  /**
   * Add a middleware function to the logging pipeline
   *
   * @param fn - Function to add to the log pipeline
   * @returns void
   */
  use(fn) {
    this._middleware.push(fn);
  }
  /**
   * Remove a function from the pipeline
   *
   * @param fn - Pipeline function
   * @returns void
   */
  remove(fn) {
    this._middleware = this._middleware.filter((p4) => p4 !== fn);
  }
};
var base_default = class extends Logtail {
  async log(message3, level = LogLevel.Info, context = {}) {
    return super.log(message3, level, context);
  }
};

// node_modules/@logtail/edge/dist/es6/context.js
init_checked_fetch();
init_modules_watch_stub();
var import_stack_trace = __toESM(require_stack_trace());
function getStackContext(logtail) {
  const stackFrame = getCallingFrame(logtail);
  if (stackFrame === null)
    return {};
  return {
    context: {
      runtime: {
        file: stackFrame.getFileName(),
        type: stackFrame.getTypeName(),
        method: stackFrame.getMethodName(),
        function: stackFrame.getFunctionName(),
        line: stackFrame.getLineNumber(),
        column: stackFrame.getColumnNumber()
      }
    }
  };
}
function getCallingFrame(logtail) {
  for (let fn of [logtail.warn, logtail.error, logtail.info, logtail.debug, logtail.log]) {
    const stack = import_stack_trace.default.get(fn);
    if (stack.length > 0)
      return getRelevantStackFrame(stack);
  }
  return null;
}
function getRelevantStackFrame(frames) {
  let reversedFrames = frames.reverse();
  let index2 = reversedFrames.findIndex((frame) => frame.getTypeName() === "EdgeWithExecutionContext");
  if (index2 > 0)
    return reversedFrames[index2 - 1];
  return frames[0];
}

// node_modules/@logtail/edge/dist/es6/edgeWithExecutionContext.js
init_checked_fetch();
init_modules_watch_stub();
var EdgeWithExecutionContext = class {
  constructor(logger, ctx) {
    this.logger = logger;
    this.ctx = ctx;
  }
  async log(message3, level, context = {}) {
    return this.logger.log(message3, level, context, this.ctx);
  }
  async debug(message3, context = {}) {
    return this.logger.debug(message3, context, this.ctx);
  }
  async info(message3, context = {}) {
    return this.logger.info(message3, context, this.ctx);
  }
  async warn(message3, context = {}) {
    return this.logger.warn(message3, context, this.ctx);
  }
  async error(message3, context = {}) {
    return this.logger.error(message3, context, this.ctx);
  }
};

// node_modules/@logtail/edge/dist/es6/edge.js
var Edge = class extends base_default {
  constructor(sourceToken, options) {
    var _a89;
    super(sourceToken, options);
    this._warnedAboutMissingCtx = false;
    this.warnAboutMissingExecutionContext = (_a89 = options === null || options === void 0 ? void 0 : options.warnAboutMissingExecutionContext) !== null && _a89 !== void 0 ? _a89 : true;
    const sync = async (logs) => {
      const res = await fetch(this._options.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/msgpack",
          Authorization: `Bearer ${this._sourceToken}`,
          "User-Agent": "logtail-js(edge)"
        },
        body: this.encodeAsMsgpack(logs)
      });
      if (res.ok) {
        return logs;
      }
      throw new Error(res.statusText);
    };
    this.setSync(sync);
  }
  withExecutionContext(ctx) {
    return new EdgeWithExecutionContext(this, ctx);
  }
  /**
   * @param message (string | Error) - Log message
   * @param level (ILogLevel) - Level to log at (debug|info|warn|error)
   * @param context (Context | Error | any) - Log context for passing structured data
   * @param ctx (ExecutionContext) - Execution context of particular worker request
   * @returns Promise<ILogtailLog> after syncing
   */
  async log(message3, level, context = {}, ctx) {
    const stackContext = getStackContext(this);
    context = Object.assign(Object.assign({}, stackContext), context);
    const log = super.log(message3, level, context);
    if (ctx) {
      ctx.waitUntil(log);
    } else if (this.warnAboutMissingExecutionContext && !this._warnedAboutMissingCtx) {
      this._warnedAboutMissingCtx = true;
      const warningMessage = "ExecutionContext hasn't been passed to the `log` method, which means syncing logs cannot be guaranteed. To ensure your logs will reach Better Stack, use `logger.withExecutionContext(ctx)` to log in your handler function. See https://betterstack.com/docs/logs/js-edge-execution-context/ for details.";
      console.warn(warningMessage);
      this.log(warningMessage, LogLevel.Warn, stackContext).catch(() => {
      });
      await this.flush();
    }
    return await log;
  }
  async debug(message3, context = {}, ctx) {
    return this.log(message3, LogLevel.Debug, context, ctx);
  }
  async info(message3, context = {}, ctx) {
    return this.log(message3, LogLevel.Info, context, ctx);
  }
  async warn(message3, context = {}, ctx) {
    return this.log(message3, LogLevel.Warn, context, ctx);
  }
  async error(message3, context = {}, ctx) {
    return this.log(message3, LogLevel.Error, context, ctx);
  }
  encodeAsMsgpack(logs) {
    const encoded = encode(logs);
    return new Uint8Array(encoded.buffer, encoded.byteOffset, encoded.byteLength);
  }
};

// src/endpoints/zendeskEvents.ts
var ZendeskEventHandler = class extends K {
  async handle(request, env, context, data) {
    const baseLogger = new Edge(env.BETTER_STACK_SOURCE_TOKEN);
    const logger = baseLogger.withExecutionContext(context);
    const db = initializeDb(env);
    const requestBody = await request.json();
    logger.info(JSON.stringify(requestBody, null, 2));
    if (typeof requestBody.current_user_external_id === "string" && requestBody.current_user_external_id.startsWith("zensync")) {
      logger.info("Message from Zensync, skipping");
      return new Response("Ok", { status: 200 });
    }
    const ticketLastUpdatedAt = requestBody.last_updated_at;
    if (!ticketLastUpdatedAt) {
      logger.error("Missing last_updated_at");
      return new Response("Missing last_updated_at", { status: 400 });
    }
    if (requestBody.last_updated_at === requestBody.created_at) {
      logger.info("Message is not an update, skipping");
      return new Response("Ok", { status: 200 });
    }
    const slackConnectionId = await authenticateRequest(request, db, logger);
    if (!slackConnectionId) {
      return new Response("Unauthorized", { status: 401 });
    }
    const conversationInfo = await db.query.conversation.findFirst({
      where: eq(conversation.id, requestBody.external_id),
      with: {
        channel: true
      }
    });
    if (!conversationInfo?.slackParentMessageId) {
      logger.error(`No conversation found for id ${requestBody.external_id}`);
      return new Response("No conversation found", { status: 404 });
    }
    logger.info(
      `ConversationInfo retrieved: ${JSON.stringify(conversationInfo)}`
    );
    if (!conversationInfo.channel || !conversationInfo.channel.slackChannelIdentifier || conversationInfo.channel.slackConnectionId !== slackConnectionId) {
      logger.warn(`Invalid Ids: ${slackConnectionId} !== ${conversationInfo}`);
      return new Response("Invalid Ids", { status: 401 });
    }
    if (!conversationInfo.channel || !conversationInfo.channel.slackChannelIdentifier || conversationInfo.channel.slackConnectionId !== slackConnectionId) {
      logger.warn(`Invalid Ids: ${slackConnectionId} !== ${conversationInfo}`);
      return new Response("Invalid Ids", { status: 401 });
    }
    const slackConnectionInfo = await db.query.slackConnection.findFirst({
      where: eq(slackConnection.id, slackConnectionId)
    });
    if (!slackConnectionInfo) {
      logger.error(`No Slack connection found for id ${slackConnectionId}`);
      return new Response("No Slack connection found", { status: 404 });
    }
    logger.info(
      `SlackConnectionInfo retrieved: ${JSON.stringify(slackConnectionInfo)}`
    );
    try {
      await sendSlackMessage(
        requestBody,
        slackConnectionInfo,
        conversationInfo.slackParentMessageId,
        conversationInfo.channel.slackChannelIdentifier,
        logger
      );
    } catch (error) {
      logger.error(error);
      return new Response("Error", { status: 500 });
    }
    return new Response("Ok", { status: 202 });
  }
};
async function getSlackUser(connection, email, logger) {
  try {
    const response = await fetch(
      `https://slack.com/api/users.lookupByEmail?email=${email}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${connection.token}`
        }
      }
    );
    const responseData = await response.json();
    logger.info(`Slack user response: ${JSON.stringify(responseData)}`);
    if (!responseData.ok) {
      throw new Error(`Error getting Slack user: ${responseData.error}`);
    }
    const username = responseData.user.profile.display_name || responseData.user.profile.real_name || void 0;
    const imageUrl = responseData.user.profile.image_192;
    return { username, imageUrl };
  } catch (error) {
    logger.error("Error in getSlackUser:", error);
    throw error;
  }
}
async function authenticateRequest(request, db, logger) {
  const authorizationHeader = request.headers.get("authorization");
  const bearerToken = authorizationHeader?.replace("Bearer ", "");
  if (!bearerToken) {
    logger.error("Missing bearer token");
    return null;
  }
  const connection = await db.query.zendeskConnection.findFirst({
    where: eq(zendeskConnection.webhookBearerToken, bearerToken)
  });
  if (!connection) {
    logger.error("Invalid bearer token");
    return null;
  }
  return connection.slackConnectionId;
}
async function sendSlackMessage(requestBody, connection, parentMessageId, slackChannelId, logger) {
  let username;
  let imageUrl;
  try {
    if (requestBody.current_user_email) {
      const slackUser = await getSlackUser(
        connection,
        requestBody.current_user_email,
        logger
      );
      username = slackUser.username || requestBody.current_user_name;
      imageUrl = slackUser.imageUrl;
    }
  } catch (error) {
    logger.warn("Error getting Slack user:", error);
  }
  try {
    const body = JSON.stringify({
      channel: slackChannelId,
      text: requestBody.message,
      thread_ts: parentMessageId,
      username,
      icon_url: imageUrl
    });
    logger.info(`Sending Slack message: ${body}`);
    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${connection.token}`
      },
      body
    });
    logger.info(`Slack response: ${JSON.stringify(response)}`);
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error posting message: ${responseData.error}`);
    }
  } catch (error) {
    logger.error("Error in sendSlackMessage:", error);
    throw error;
  }
  logger.info("Message posted successfully");
}

// src/endpoints/slackInteractivity.ts
init_checked_fetch();
init_modules_watch_stub();

// lib/utils.ts
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/clsx/dist/clsx.mjs
init_checked_fetch();
init_modules_watch_stub();

// lib/utils.ts
async function verifySlackRequest(request, env) {
  const signingSecret = env.SLACK_SIGNING_SECRET;
  const timestamp3 = request.headers.get("x-slack-request-timestamp");
  const slackSignature = request.headers.get("x-slack-signature");
  const body = await request.text();
  const basestring = `v0:${timestamp3}:${body}`;
  const encoder2 = new TextEncoder();
  const keyData = encoder2.encode(signingSecret);
  const data = encoder2.encode(basestring);
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signatureBuffer = await crypto.subtle.sign("HMAC", cryptoKey, data);
  const mySignature = Array.from(new Uint8Array(signatureBuffer)).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  const computedSignature = `v0=${mySignature}`;
  return timingSafeEqual(computedSignature, slackSignature || "");
}
function timingSafeEqual(a2, b3) {
  if (a2.length !== b3.length) {
    return false;
  }
  let mismatch = 0;
  for (let i2 = 0; i2 < a2.length; i2++) {
    mismatch |= a2.charCodeAt(i2) ^ b3.charCodeAt(i2);
  }
  return mismatch === 0;
}
async function fetchZendeskCredentials(slackConnectionId, db) {
  const zendeskCredentials = await db.query.zendeskConnection.findFirst({
    where: eq(zendeskConnection.slackConnectionId, slackConnectionId)
  });
  const zendeskDomain = zendeskCredentials?.zendeskDomain;
  const zendeskEmail = zendeskCredentials?.zendeskEmail;
  const zendeskApiKey = zendeskCredentials?.zendeskApiKey;
  if (!zendeskDomain || !zendeskEmail || !zendeskApiKey) {
    console.log(
      `No Zendesk credentials found for slack connection ${slackConnectionId}`
    );
    return null;
  }
  return zendeskCredentials;
}
async function findSlackConnectionByTeamId(teamId, db) {
  if (!teamId) {
    console.error("No team_id found");
    return void 0;
  }
  try {
    const connection = await db.query.slackConnection.findFirst({
      where: eq(slackConnection.slackTeamId, teamId)
    });
    return connection;
  } catch (error) {
    console.error("Error querying SlackConnections:", error);
    return void 0;
  }
}

// src/endpoints/slackInteractivity.ts
var SlackInteractivityHandler = class extends K {
  async handle(request, env, context, data) {
    const baseLogger = new Edge(env.BETTER_STACK_SOURCE_TOKEN);
    const logger = baseLogger.withExecutionContext(context);
    const db = initializeDb(env);
    const textClone = request.clone();
    if (!await verifySlackRequest(textClone, env)) {
      logger.warn("Slack verification failed!");
      return new Response("Verification failed", { status: 200 });
    }
    const requestBody = await request.formData();
    const payloadString = requestBody.get("payload");
    if (typeof payloadString !== "string") {
      return new Response("Invalid payload", { status: 400 });
    }
    const payload = JSON.parse(payloadString);
    logger.info(JSON.stringify(payload, null, 2));
    const slackConnectionDetails = await findSlackConnectionByTeamId(
      payload.team?.id,
      db
    );
    if (!slackConnectionDetails) {
      logger.warn(`No organization found for team ID: ${payload.team?.id}.`);
      return new Response("Invalid team_id", { status: 404 });
    }
    const actionId = getFirstActionId(payload);
    logger.info(`Action ID: ${actionId}`);
    if (actionId === "configure-zendesk" /* CONFIGURE_ZENDESK_BUTTON_TAPPED */) {
      try {
        await openZendeskConfigurationModal(
          payload,
          slackConnectionDetails,
          db,
          logger
        );
      } catch (error) {
        returnGenericError(error, logger);
      }
    } else if (payload.type === "view_submission" && payload.view?.callback_id === "zendesk-configuration-modal" /* ZENDESK_CONFIGURATION_MODAL_ID */) {
      try {
        await saveZendeskCredentials(
          payload,
          slackConnectionDetails,
          env,
          db,
          logger
        );
      } catch (error) {
        returnGenericError(error, logger);
      }
    }
    return new Response(null, { status: 200 });
  }
};
function returnGenericError(error, logger) {
  logger.error("Error saving Zendesk credentials:", error);
  return Response.json(
    {
      response_action: "errors",
      errors: {
        "zendesk-email-input": "Unable to set up Zendesk connection",
        "zendesk-api-key-input": "Unable to set up Zendesk connection"
      }
    },
    { status: 200 }
  );
}
function extractZendeskDomain(input) {
  const urlPattern = /^(?:https?:\/\/)?([^\.]+)\.zendesk\.com$/;
  const match = input.match(urlPattern);
  if (match) {
    return match[1];
  } else {
    return input;
  }
}
function getFirstActionId(payload) {
  if (payload && payload.actions && Array.isArray(payload.actions)) {
    if (payload.actions.length > 0 && payload.actions[0].action_id) {
      return payload.actions[0].action_id;
    }
  }
  return null;
}
async function saveZendeskCredentials(payload, connection, env, db, logger) {
  const values = payload.view?.state.values;
  const rawZendeskDomain = values?.zendesk_domain["zendesk-domain-input"]?.value;
  const rawZendeskAdminEmail = values?.zendesk_admin_email["zendesk-email-input"]?.value;
  const rawZendeskApiKey = values?.zendesk_api_key["zendesk-api-key-input"]?.value;
  const zendeskDomain = extractZendeskDomain(
    rawZendeskDomain?.replace(/\s/g, "").toLowerCase()
  );
  const zendeskEmail = rawZendeskAdminEmail?.replace(/\s/g, "").toLowerCase();
  const zendeskKey = rawZendeskApiKey?.replace(/\s/g, "");
  const zendeskAuthToken = btoa(`${zendeskEmail}/token:${zendeskKey}`);
  let uuid2 = crypto.randomUUID();
  let zendeskTriggerId;
  let zendeskWebhookId;
  try {
    const webhookPayload = JSON.stringify({
      webhook: {
        endpoint: `${env.ROOT_URL}/api/v1/zendesk/events`,
        http_method: "POST",
        name: "Slack-to-Zendesk Sync",
        request_format: "json",
        status: "active",
        subscriptions: ["conditional_ticket_events"],
        authentication: {
          type: "bearer_token",
          data: {
            token: uuid2
          },
          add_position: "header"
        }
      }
    });
    const zendeskWebhookResponse = await fetch(
      `https://${zendeskDomain}.zendesk.com/api/v2/webhooks`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${zendeskAuthToken}`
        },
        body: webhookPayload
      }
    );
    if (!zendeskWebhookResponse.ok) {
      logger.error(
        `Zendesk Webhook API failed with status: ${zendeskWebhookResponse.status}`
      );
      logger.error(`Response: ${await zendeskWebhookResponse.text()}`);
      throw new Error("Failed to set Zendesk webhook");
    }
    const webhookResponseJson = await zendeskWebhookResponse.json();
    logger.info("Zendesk webhook created:", webhookResponseJson);
    zendeskWebhookId = webhookResponseJson.webhook.id;
    if (!zendeskWebhookId) {
      throw new Error("Failed to find webhook id");
    }
    const triggerPayload = JSON.stringify({
      trigger: {
        title: "Zensync - Slack-to-Zendesk Sync [DO NOT EDIT]",
        description: "Two-way sync between Slack and Zendesk. Contact your admin or email support@slacktozendesk.com for help.",
        active: true,
        conditions: {
          all: [
            {
              field: "status",
              operator: "less_than",
              value: "closed"
            },
            {
              field: "role",
              operator: "is",
              value: "agent"
            },
            {
              field: "current_tags",
              operator: "includes",
              value: "zensync"
            },
            {
              field: "current_via_id",
              operator: "is_not",
              value: "5"
            },
            {
              field: "comment_is_public",
              operator: "is",
              value: "true"
            }
          ]
        },
        actions: [
          {
            field: "notification_webhook",
            value: [
              zendeskWebhookId,
              '{\n  "ticket_id": "{{ticket.id}}",\n  "external_id": "{{ticket.external_id}}",\n  "last_updated_at": "{{ticket.updated_at_with_timestamp}}",\n  "created_at": "{{ticket.created_at_with_timestamp}}",\n  "requester_email": "{{ticket.requester.email}}",\n  "requester_external_id": "{{ticket.requester.external_id}}",\n  "current_user_email": "{{current_user.email}}",\n  "current_user_name": "{{current_user.name}}",\n  "current_user_external_id": "{{current_user.external_id}}",\n  "message": "{{ticket.latest_public_comment}}",\n  "is_public": "{{ticket.latest_public_comment.is_public}}",\n  "attachments": [\n    {% for attachment in ticket.latest_public_comment.attachments %}\n    {\n      "filename": "{{attachment.filename}}",\n      "url": "{{attachment.url}}"\n    }{% if forloop.last == false %},{% endif %}\n    {% endfor %}\n  ],\n  "via": "{{ticket.via}}"\n}\n'
            ]
          }
        ]
      }
    });
    const zendeskTriggerResponse = await fetch(
      `https://${zendeskDomain}.zendesk.com/api/v2/triggers`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${zendeskAuthToken}`
        },
        body: triggerPayload
      }
    );
    if (!zendeskTriggerResponse.ok) {
      logger.error(
        `Zendesk Trigger API failed with status: ${zendeskTriggerResponse.status}`
      );
      logger.error(`Response: ${await zendeskTriggerResponse.text()}`);
      throw new Error("Failed to set Zendesk trigger");
    }
    const triggerResponseJson = await zendeskTriggerResponse.json();
    logger.info("Zendesk trigger created:", triggerResponseJson);
    zendeskTriggerId = triggerResponseJson.trigger.id ?? null;
  } catch (error) {
    logger.info(error);
    return Response.json(
      { message: "Invalid Zendesk Credentials" },
      { status: 400 }
    );
  }
  await db.insert(zendeskConnection).values({
    zendeskApiKey: zendeskKey,
    zendeskDomain,
    zendeskEmail,
    slackConnectionId: connection.id,
    status: "ACTIVE",
    zendeskTriggerId,
    zendeskWebhookId,
    webhookBearerToken: uuid2
  }).onConflictDoUpdate({
    target: zendeskConnection.slackConnectionId,
    set: {
      zendeskApiKey: zendeskKey,
      zendeskDomain,
      zendeskEmail,
      webhookBearerToken: uuid2,
      zendeskTriggerId,
      zendeskWebhookId,
      status: "ACTIVE"
    }
  });
}
async function openZendeskConfigurationModal(payload, connection, db, logger) {
  logger.info("Opening Zendesk configuration modal");
  const triggerId = payload.trigger_id;
  if (!triggerId) {
    logger.warn("No trigger_id found in payload");
    return;
  }
  const zendeskInfo = await fetchZendeskCredentials(connection.id, db);
  try {
    const body = JSON.stringify({
      trigger_id: triggerId,
      view: {
        type: "modal",
        callback_id: "zendesk-configuration-modal" /* ZENDESK_CONFIGURATION_MODAL_ID */,
        title: {
          type: "plain_text",
          text: "Zendesk Connection",
          emoji: true
        },
        submit: {
          type: "plain_text",
          text: "Connect",
          emoji: true
        },
        close: {
          type: "plain_text",
          text: "Cancel",
          emoji: true
        },
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: "Visit our <https://slacktozendesk.com/docs|documentation> for any questions or help connecting to Zendesk."
            }
          },
          {
            type: "input",
            block_id: "zendesk_domain",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-domain-input" /* ZENDESK_DOMAIN_TEXT_FIELD */,
              initial_value: `${zendeskInfo?.zendeskDomain ?? ""}`,
              placeholder: {
                type: "plain_text",
                text: "slacktozendesk.zendesk.com"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Domain Prefix",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: 'Example: If your Zendesk domain is yourcompany.zendesk.com, you would just enter "yourcompany" here.'
            }
          },
          {
            type: "input",
            block_id: "zendesk_admin_email",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-email-input" /* ZENDESK_EMAIL_TEXT_FIELD */,
              initial_value: `${zendeskInfo?.zendeskEmail ?? ""}`,
              placeholder: {
                type: "plain_text",
                text: "ryan@slacktozendesk.com"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk Admin Email",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: "Enter the email address of the Zendesk admin that created the API key."
            }
          },
          {
            type: "input",
            block_id: "zendesk_api_key",
            element: {
              type: "plain_text_input",
              action_id: "zendesk-api-key-input" /* ZENDESK_API_KEY_TEXT_FIELD */,
              placeholder: {
                type: "plain_text",
                text: "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022"
              }
            },
            label: {
              type: "plain_text",
              text: "Zendesk API Key",
              emoji: true
            },
            hint: {
              type: "plain_text",
              text: "The Zendesk API key your admin created."
            }
          }
        ]
      }
    });
    logger.info(`Opening Slack modal: ${body}`);
    const response = await fetch("https://slack.com/api/views.open", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${connection.token}`
      },
      body
    });
    logger.info(`Slack response: ${JSON.stringify(response)}`);
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error opening modal: ${responseData}`);
    }
  } catch (error) {
    logger.error("Error in openZendeskConfigurationModal:", error);
    throw error;
  }
}

// src/endpoints/slackAuthRedirect.ts
init_checked_fetch();
init_modules_watch_stub();
var SlackAuthRedirect = class extends K {
  async handle(request, env, context, data) {
    const baseLogger = new Edge(env.BETTER_STACK_SOURCE_TOKEN);
    const logger = baseLogger.withExecutionContext(context);
    const state = crypto.randomUUID();
    try {
      const db = initializeDb(env);
      await db.insert(slackOauthState).values({
        id: state
      });
    } catch (error) {
      logger.log(error);
      return new Response(JSON.stringify({ error: "Error saving state." }), {
        status: 500,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
    const scopes = [
      "team:read",
      "channels:read",
      "groups:read",
      "channels:history",
      "groups:history",
      "reactions:read",
      "chat:write",
      "chat:write.customize",
      "users:read.email",
      "users:read",
      "users.profile:read",
      "files:read",
      "files:write"
    ].join(",");
    const redirectUrl = `https://slack.com/oauth/v2/authorize?client_id=${env.SLACK_CLIENT_ID}&scope=${encodeURIComponent(scopes)}&state=${state}`;
    return Response.redirect(redirectUrl);
  }
};

// src/endpoints/slackAuthCallback.ts
init_checked_fetch();
init_modules_watch_stub();
var SlackAuthCallback = class extends K {
  async handle(request, env, context, data) {
    const baseLogger = new Edge(env.BETTER_STACK_SOURCE_TOKEN);
    const logger = baseLogger.withExecutionContext(context);
    const url = new URL(request.url);
    const code = url.searchParams.get("code");
    const state = url.searchParams.get("state");
    if (!code || !state) {
      return new Response(
        "Missing required parameters: code and state. Try again.",
        {
          status: 400
        }
      );
    }
    const db = initializeDb(env);
    const slackOauthStateResponse = await db.query.slackOauthState.findFirst({
      where: eq(slackOauthState.id, state)
    });
    if (!slackOauthStateResponse || (/* @__PURE__ */ new Date()).getTime() - new Date(slackOauthStateResponse.createdAt).getTime() > 6e5) {
      return new Response("Invalid or expired state. Try again.", {
        status: 401
      });
    }
    let accessToken;
    let authedUser;
    let botUserId;
    try {
      const params = new URLSearchParams();
      params.append("client_id", env.SLACK_CLIENT_ID);
      params.append("client_secret", env.SLACK_CLIENT_SECRET);
      params.append("code", code);
      const response2 = await fetch("https://slack.com/api/oauth.v2.access", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params
      });
      const responseData = await response2.json();
      if (!responseData.ok) {
        return new Response("Failed to authenticate.", { status: 401 });
      }
      accessToken = responseData.access_token;
      authedUser = responseData.authed_user.id;
      botUserId = responseData.bot_user_id;
      if (!accessToken || !botUserId) {
        logger.info(
          `Error fetching access token or bot user id: ${JSON.stringify(
            responseData,
            null,
            2
          )}`
        );
        return new Response("Missing access token.", { status: 404 });
      }
    } catch (error) {
      logger.info(error);
      return new Response("Authentication failed.", { status: 400 });
    }
    logger.info("Access token received");
    const response = await fetch("https://slack.com/api/team.info", {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    });
    try {
      const teamInfoResponse = await response.json();
      if (!teamInfoResponse.ok || !teamInfoResponse.team) {
        logger.info(
          `Error fetching team info: ${JSON.stringify(
            teamInfoResponse,
            null,
            2
          )}`
        );
        return new Response("Invalid access token or permissions.", {
          status: 401
        });
      }
      const team = teamInfoResponse.team;
      await db.insert(slackConnection).values({
        slackTeamId: team.id,
        name: team.name,
        domain: team.domain,
        iconUrl: team.icon.image_132,
        emailDomain: team.email_domain,
        slackEnterpriseId: team.enterprise_id,
        slackEnterpriseName: team.enterprise_name,
        token: accessToken,
        authedUserId: authedUser,
        botUserId,
        status: "ACTIVE"
      }).onConflictDoUpdate({
        target: slackConnection.slackTeamId,
        set: {
          name: team.name,
          domain: team.domain,
          iconUrl: team.icon.image_132,
          emailDomain: team.email_domain,
          slackEnterpriseId: team.enterprise_id,
          slackEnterpriseName: team.enterprise_name,
          token: accessToken,
          authedUserId: authedUser,
          botUserId,
          status: "ACTIVE"
        }
      });
    } catch (error) {
      logger.error(error);
      return new Response("Error saving access token.", { status: 500 });
    }
    return new Response("Success", { status: 200 });
  }
};
__publicField(SlackAuthCallback, "schema", {
  parameters: {
    code: M(String),
    state: M(String)
  }
});

// src/endpoints/slackEvents.ts
init_checked_fetch();
init_modules_watch_stub();
var import_qstash = __toESM(require_dist2());
var SlackEventHandler = class extends K {
  async handle(request, env, context, data) {
    const baseLogger = new Edge(env.BETTER_STACK_SOURCE_TOKEN);
    const logger = baseLogger.withExecutionContext(context);
    const jsonClone = request.clone();
    const textClone = request.clone();
    const requestBody = await jsonClone.json();
    logger.info(JSON.stringify(requestBody, null, 2));
    if (requestBody.type === "url_verification") {
      return new Response(requestBody.challenge, {
        status: 200,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    if (!await verifySlackRequest(textClone, env)) {
      logger.warn("Slack verification failed!");
      return new Response("Verification failed", { status: 200 });
    }
    const db = initializeDb(env);
    const connectionDetails = await findSlackConnectionByTeamId(
      requestBody.team_id,
      db
    );
    if (!connectionDetails) {
      logger.warn(
        `No slack connection found for team ID: ${requestBody.team_id}.`
      );
      return new Response("Invalid team_id", { status: 404 });
    }
    const eventType = requestBody.event?.type;
    const eventSubtype = requestBody.event?.subtype;
    if (eventType === "app_home_opened") {
      logger.info(`Handling app_home_opened event`);
      try {
        await handleAppHomeOpened(requestBody, connectionDetails, db, logger);
      } catch (error) {
        logger.error("Error handling app_home_opened:", error);
        return new Response("Internal Server Error", { status: 500 });
      }
    } else if (isMessageToQueue(eventType, eventSubtype) || eventType === "message" && isPayloadEligibleForTicket(requestBody, connectionDetails, logger)) {
      logger.info(`Publishing event ${eventType}:${eventSubtype} to qstash`);
      try {
        const qstash = new import_qstash.Client({ token: env.QSTASH_TOKEN });
        await qstash.publishJSON({
          url: `https://zensync.vercel.app/api/v1/slack/worker/messages`,
          //TODO: use env.ROOT_URL
          body: {
            eventBody: requestBody,
            connectionDetails
          },
          contentBasedDeduplication: true
        });
      } catch (error) {
        logger.error("Error publishing message qstash:", error);
        return new Response("Internal Server Error", { status: 500 });
      }
    } else if (eventSubtype === "file_share") {
      logger.info(`Publishing event ${eventType}:${eventSubtype} to qstash`);
      try {
        const qstash = new import_qstash.Client({ token: env.QSTASH_TOKEN });
        await qstash.publishJSON({
          url: `https://zensync.vercel.app/api/v1/slack/worker/files`,
          //TODO: use env.ROOT_URL
          body: {
            eventBody: requestBody,
            connectionDetails
          },
          contentBasedDeduplication: true,
          retries: 1,
          failureCallback: `https://zensync.vercel.app/api/v1/slack/worker/messages`
          //TODO: use env.ROOT_URL
        });
      } catch (error) {
        logger.error("Error publishing file to qstash:", error);
        return new Response("Internal Server Error", { status: 500 });
      }
    } else {
      logger.info(
        `No processable event type found for event: ${JSON.stringify(
          requestBody.event,
          null,
          2
        )}`
      );
    }
    return new Response("Ok", { status: 202 });
  }
};
function isPayloadEligibleForTicket(request, connection, logger) {
  const eventData = request.event;
  if (connection.botUserId === eventData.user) {
    logger.info("Ignoring message from Zensync");
    return false;
  }
  const eligibleSubtypes = /* @__PURE__ */ new Set([
    "message_replied",
    "message_changed",
    "message_deleted",
    void 0
  ]);
  const subtype = eventData.subtype;
  if (eligibleSubtypes.has(subtype)) {
    return true;
  }
  logger.info(`Ignoring message subtype: ${subtype}`);
  return false;
}
function isMessageToQueue(eventType, eventSubtype) {
  const specificEventsToHandle = [
    "member_joined_channel",
    "channel_left",
    "channel_archive",
    "channel_unarchive",
    "channel_deleted",
    "channel_rename",
    "channel_id_changed"
  ];
  return specificEventsToHandle.includes(eventType) || specificEventsToHandle.includes(eventSubtype);
}
async function fetchHomeTabData(slackConnection2, db, logger) {
  try {
    const zendeskInfo = await fetchZendeskCredentials(slackConnection2.id, db);
    const channelInfos = await db.query.channel.findMany({
      where: and(
        eq(channel.slackConnectionId, slackConnection2.id),
        eq(channel.isMember, true)
      ),
      orderBy: [desc(channel.name)],
      limit: 1e3
      // This is artificaially set just to not blow up the home tab
    });
    return [zendeskInfo, channelInfos];
  } catch (error) {
    logger.error("Error fetching home tab data from database:", error);
    throw error;
  }
}
async function handleAppHomeOpened(requestBody, connection, db, logger) {
  const slackUserId = requestBody.event?.user;
  if (!slackUserId) {
    logger.error("No user found in event body");
    return;
  }
  try {
    const [zendeskInfo, channelInfos] = await fetchHomeTabData(
      connection,
      db,
      logger
    );
    const viewJson = {
      type: "home",
      blocks: [
        {
          type: "header",
          text: {
            type: "plain_text",
            text: "Welcome to Zensync :wave:",
            emoji: true
          }
        },
        {
          type: "divider"
        },
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: "Manage your connection with Zendesk through the button below. Refer to our <https://slacktozendesk.com/docs|docs> for more information."
          }
        },
        {
          type: "actions",
          elements: [
            {
              type: "button",
              text: {
                type: "plain_text",
                text: zendeskInfo?.status !== "ACTIVE" ? "Connect to Zendesk" : "Edit Zendesk Connection",
                emoji: true
              },
              action_id: "configure-zendesk" /* CONFIGURE_ZENDESK_BUTTON_TAPPED */,
              ...zendeskInfo?.status !== "ACTIVE" && { style: "primary" }
            }
          ]
        },
        {
          type: "divider"
        },
        {
          type: "header",
          text: {
            type: "plain_text",
            text: `Connected channels (${channelInfos.length})`,
            emoji: true
          }
        },
        {
          type: "context",
          elements: [
            {
              type: "mrkdwn",
              text: "Use command `/invite @zensync` any channel to connect it with Zendesk."
            }
          ]
        },
        {
          type: "divider"
        },
        ...createChannelSections(channelInfos)
      ]
    };
    const body = JSON.stringify({
      user_id: slackUserId,
      view: viewJson
    });
    logger.info(`Publishing Slack View: ${body}`);
    const response = await fetch("https://slack.com/api/views.publish", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${connection.token}`
      },
      body
    });
    logger.info(`Slack response: ${JSON.stringify(response)}`);
    const responseData = await response.json();
    if (!responseData.ok) {
      throw new Error(`Error publishig view: ${responseData}`);
    }
  } catch (error) {
    logger.error("Error in handleAppHomeOpened:", error);
    throw error;
  }
}
function createChannelSections(channelInfos) {
  if (channelInfos.length === 0) {
    return [];
  }
  return channelInfos.map((info) => {
    return [
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*<fakeLink.toHotelPage.com|#${info.name}>*
Owner: ${info.defaultAssigneeEmail}
Tags: \`enterprise\``
        },
        accessory: {
          type: "button",
          text: {
            type: "plain_text",
            emoji: true,
            text: "Edit"
          }
        }
      },
      {
        type: "context",
        elements: [
          {
            type: "plain_text",
            emoji: true,
            text: `Last active on ${info.latestActivityAt ?? info.createdAt}`
          }
        ]
      },
      {
        type: "divider"
      }
    ];
  }).flat();
}

// src/endpoints/queueTest.ts
init_checked_fetch();
init_modules_watch_stub();
var QueueTestHandler = class extends K {
  async handle(request, env, context, data) {
    console.log("Handler started!");
    try {
      await env.TEST_QUEUE_BINDING.send("Hello, world!");
    } catch (e3) {
      console.log("Error writing to queue!");
      console.error(e3);
      return new Response("Error writing to queue!", { status: 500 });
    }
    return new Response("Success!");
  }
};

// src/queues/queueTest.ts
init_checked_fetch();
init_modules_watch_stub();
var QueueMessageHandler = class {
  async handle(batch, env) {
    console.log("Queue consumer started!");
    switch (batch.queue) {
      case "log-queue":
        break;
      case "debug-queue":
        break;
      case "email-reset":
        break;
      default:
        console.log(`Unknown queue: ${batch.queue}`);
    }
    try {
      for (const message3 of batch.messages) {
        console.log(`Processing message: ${JSON.stringify(message3.body)}`);
      }
    } catch (e3) {
      console.log("Error processing queue message!");
      console.error(e3);
    }
  }
};

// src/index.ts
var router = h();
var message2 = new QueueMessageHandler();
router.post(`/v1/zendesk/events`, ZendeskEventHandler);
router.post(`/v1/slack/interactivity`, SlackInteractivityHandler);
router.get(`/v1/slack/auth/redirect`, SlackAuthRedirect);
router.get(`/v1/slack/auth/callback`, SlackAuthCallback);
router.post(`/v1/slack/events`, SlackEventHandler);
router.get(`/queues`, QueueTestHandler);
router.all(
  "*",
  () => Response.json(
    {
      success: false,
      error: "Route not found"
    },
    { status: 404 }
  )
);
var worker = {
  fetch: router.handle,
  queue: message2.handle.bind(message2)
};
var src_default = worker;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e3) {
  return {
    name: e3?.name,
    message: e3?.message ?? String(e3),
    stack: e3?.stack,
    cause: e3?.cause === void 0 ? void 0 : reduceError(e3.cause)
  };
}
var jsonError2 = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e3) {
    const error = reduceError(e3);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError2;
var wrap3 = void 0;

// .wrangler/tmp/bundle-7bl23J/middleware-insertion-facade.js
var envWrappers = [wrap3].filter(Boolean);
var facade = {
  ...src_default,
  envWrappers,
  middleware: [
    middleware_miniflare3_json_error_default,
    ...src_default.middleware ? src_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default = facade;

// node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-7bl23J/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__ = function(request, env, ctx) {
  if (middleware_insertion_facade_default.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default.fetch(request, env, ctx);
};
function getMaskedEnv(rawEnv) {
  let env = rawEnv;
  if (middleware_insertion_facade_default.envWrappers && middleware_insertion_facade_default.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default.envWrappers) {
      env = wrapFn(env);
    }
  }
  return env;
}
var registeredMiddleware = false;
var facade2 = {
  ...middleware_insertion_facade_default.tail && {
    tail: maskHandlerEnv(middleware_insertion_facade_default.tail)
  },
  ...middleware_insertion_facade_default.trace && {
    trace: maskHandlerEnv(middleware_insertion_facade_default.trace)
  },
  ...middleware_insertion_facade_default.scheduled && {
    scheduled: maskHandlerEnv(middleware_insertion_facade_default.scheduled)
  },
  ...middleware_insertion_facade_default.queue && {
    queue: maskHandlerEnv(middleware_insertion_facade_default.queue)
  },
  ...middleware_insertion_facade_default.test && {
    test: maskHandlerEnv(middleware_insertion_facade_default.test)
  },
  ...middleware_insertion_facade_default.email && {
    email: maskHandlerEnv(middleware_insertion_facade_default.email)
  },
  fetch(request, rawEnv, ctx) {
    const env = getMaskedEnv(rawEnv);
    if (middleware_insertion_facade_default.middleware && middleware_insertion_facade_default.middleware.length > 0) {
      if (!registeredMiddleware) {
        registeredMiddleware = true;
        for (const middleware of middleware_insertion_facade_default.middleware) {
          __facade_register__(middleware);
        }
      }
      const __facade_modules_dispatch__ = function(type, init) {
        if (type === "scheduled" && middleware_insertion_facade_default.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(
        request,
        env,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__
      );
    } else {
      return __facade_modules_fetch__(request, env, ctx);
    }
  }
};
function maskHandlerEnv(handler) {
  return (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);
}
var middleware_loader_entry_default = facade2;
export {
  middleware_loader_entry_default as default,
  router
};
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@neondatabase/serverless/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=index.js.map
